//[MACROS_CONFIGURATION:=====================================]//
//[CONFIGURATION_MACROS:=====================================]//

    #define mcv_m_eci ( 1 )         //:ECI:Error_Check_Inputs://

    //:**************************************************:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:TODO: [If/When] code starts to mysteriously crash,:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      create your own validation for all of the   :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      vulkan function calls and then prey that    :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      you discover a problem.                     :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:**************************************************:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//[=====================================:MACROS_CONFIGURATION]//
//[=====================================:CONFIGURATION_MACROS]//
//[CODING_STYLE|=============================================]//
//[                                                          ]//
//[ Namespaces:                                              ]//
//[                                                          ]//
//[     1. All global tokens begin with "MCV_".              ]//
//[     2. All global tokens have a category namespace.      ]//
//[         MCV_F : Function                                 ]//
//[         MCV_D : Data (AKA: Variable)                     ]//
//[         MCV_U : Unit Test                                ]//
//[         MCV_T : Type                                     ]//
//[         MCV_M : Macro                                    ]//
//[     3. Public  tokens all   capital. EX: MCV_F_WHATEVER  ]//
//[     4. Private tokens all lowercase. EX: mcv_f_whatever  ]//
//[     5. DONT MIX CAPITAL & LOWERCASE: This_Is_Not_Allowed ]//
//[                                                          ]//
//[ Sub_Namespaces:                                          ]//
//[                                                          ]//
//[     mcv_d_n : Number Of (Usually For Array)              ]//
//[     mcv_d_c : Capacity Of Array                          ]//
//[     mcv_d_a : Array Itself                               ]//
//[                                                          ]//
//[     mcv_d_c : c for "create info"                        ]//
//[     mcv_d_o : o for "object" belonging to "create info"  ]//
//[                                                          ]//
//[=============================================|CODING_STYLE]//
//|FUNCTION_INDEX:===========================================|//
//|                                                          |//
//|     mcv_f_err     : ERRor (Halts Program Execution)      |//
//|     mcv_f_say     : SAY   (Informational Message  )      |//
//|     mcv_f_chk     : CHecK (Check Validity Of Something)  |//
//|     mcv_f_gpa     : Get_Proc_Address (Generic  )         |//
//|     mcv_f_gpa_vul : Get_Proc_Address (Vulkan   )         |//
//|     mcv_f_gpa_g32 : Get_Proc_Address (GDI32    )         |//
//|     mcv_f_gpa_u32 : Get_Proc_Address (USER32   )         |//
//|     mcv_f_gpa_k32 : Get_Proc_Address (KERNEL32 )         |//
//|                                                          |//
//|===========================================:FUNCTION_INDEX|//
//+ALL_OTHER_TOKENS_INDEX:===================================+//
//+                                                          +//
//+             rie : Required__Instance_Extensions          +//
//+             aie : Available_Instance_Extensions          +//
//+                                                          +//
//+     mcv_m_n_rie : num_rie : Number Of [rie]              +//
//+     mcv_d_a_rie : arr_rie : Array  Of [rie]              +//
//+                                                          +//
//+     mcv_d_n_aie : num_aie : Number Of [aie]              +//
//+     mcv_d_a_aie : arr_aie : Array  Of [aie]              +//
//+                                                          +//
//+===================================|ALL_OTHER_TOKENS_INDEX+//
//:INCLUDES:=================================================://

    #include "stdio.h"           //:fflush( stdout ) , printf://
    #include "stdint.h"          //:int32_t , uint32_t , etc ://
    #include "libloaderapi.h"  //:LoadLibraryA,GetProcAddress://
    #include <stdlib.h>                           //: exit() ://
                             
//:=================================================:INCLUDES://
//:FILE_MACROS:==============================================://

//: MISC_FILE_MACROS ://

    #define PUBLIC_FUNCTION       /** FOR SELF DOCUMENTATION **/
    #define PRIVATE_FUNCTION      [DONT_USE_MOST_THINGS_PRIVATE]

//: MONKEY_WRENCH_MACROS ://

    #define num_qci [BAD_NAME:USE_GENERAL_TO_SPECIFIC:qci_num]
    #define arr_qci [BAD_NAME:USE_GENERAL_TO_SPECIFIC:qci_arr]
  
    #define num_lay [BAD_NAME:USE_GENERAL_TO_SPECIFIC:lay_num]
    #define arr_lay [BAD_NAME:USE_GENERAL_TO_SPECIFIC:lay_arr]
    
    #define num_ext [BAD_NAME:USE_GENERAL_TO_SPECIFIC:ext_num]
    #define arr_ext [BAD_NAME:USE_GENERAL_TO_SPECIFIC:ext_arr]

    #define mcv_f_dll_all [JUST_INLINE_THE_LOGIC]  //: @MWM@ ://

    #define QFC_NUM [YOU_MEAN( QFI_NUM | QCI_NUM )]

//: Basic_File_Macros ://

    #define ECI mcv_m_eci 
    #define NIL ((void*)0)
    #define VOD   void
    #define DLL   void
    #define U08  uint8_t
    #define U16 uint16_t  
    #define I32  int32_t
    #define U32 uint32_t
    #define U64 uint64_t
    #define I64  int64_t  
    #define F32 float
    #define CHR const char                  //:Ascii___String://
    #define UNI const wchar_t               //:Unicode_String://
    #define NCC       char                  //:Mutable_Ascii ://
    #define ERR mcv_f_err
    #define SAY mcv_f_say
    #define CHK mcv_f_chk
    #define ASS mcv_f_ass
    #define RES int32_t                    //:VkResult Type  ://
    #define GI3 MCV_T_GI3                  //:GenericFunc:I32://
    #define G00 MCV_T_G00                  //:GenericFunc:VOD://
    #define P_F printf
    #define F_F fflush
    #define S_A _Static_assert 
    #define S_O sizeof
    #define SIZ size_t

//: Vulkan_Macros_To_Keep_Stuff_Terse ://

    //: VEP == "Vulkan_Extension_Properties" ://
    //: PDL == "Physical_Device_Limits"      ://
    //: DSP == "Device_Sparse_Properties"    ://

    #define VEP struct mcv_t_vkextensionproperties
    #define PDL struct mcv_t_vkphysicaldevicelimits
    #define DSP struct mcv_t_vkphysicaldevicesparseproperties

    S_A( sizeof( U32 ) == 4 );
    S_A( sizeof( I32 ) == 4 );
    S_A( sizeof( U08 ) == 1 );

//:==============================================:FILE_MACROS://
//:MACROS:===================================================://

    //: rie : RequiredInstanceExtensions :- - - - - - - - - -://
    //: aie : AvailableInstanceExtensions( ins_ext ) :- - - -://
    //: men : VK_MAX_EXTENSION_NAME_SIZE :- - - - - - - - - -://
    //: mpd : VK_MAX_PHYSICAL_DEVICE_NAME_SIZE :- - - - - - -://
    //: uid : VK_UUID_SIZE :- - - - - - - - - -:- - - - - - -://

        //: Arrays Of Strings ://

            #define       mcv_m_n_rie ( 2 )   //: Number:rie ://
            extern  CHR*  mcv_d_a_rie[  2 ] ; //: Array :rie ://
            #define       mcv_d_n_rie [USE:mcv_m_n_rie]

            #define       mcv_m_n_rde ( 1 )   //: Number:rde ://
            extern  CHR*  mcv_d_a_rde[  1 ] ; //: Array :rde ://
            #define       mcv_d_n_rde [USE:mcv_m_n_rde]

        //: Max Values And Indexes ://

            #define mcv_m_men     ( 256U )         //: [men] ://
            #define mcv_m_mpd     ( 256U )         //: [mpd] ://
            #define mcv_m_uid     (  16U )         //: [uid] ://

        //: Capacities Of Arrays ://

            #define mcv_m_c_rie [NO_CAPACITY_SIZE_KNOWN]
            #define mcv_m_c_rde [NO_CAPACITY_SIZE_KNOWN]
            #define mcv_m_c_aie     ( 32 )      //: Capacity ://
            #define mcv_m_c_ade     ( 256)      //: Capacity ://
            #define mcv_m_c_phy_dev (  8 )      //: Capacity ://
            #define mcv_m_c_qfp     ( 16 )      //: Capacity ://
            #define mcv_m_c_qfi     (  3 )      //: Capacity ://

//:===================================================:MACROS://
//:TYPES:====================================================://

    typedef VOD* ( MCV_T_G00 )(  );  //:Generic_Function_Type://
    typedef I32  ( MCV_T_GI3 )(  );  //:Generic_Function_Type://

    //:Function_Pointer_Structs:-----------------------------://

        //:WIN32:Function_Pointer_Structs:- - - - - - - - - -://

            struct mcv_t_lib_g32{
                GI3* ChoosePixelFormat ;
                GI3* GetStockObject    ;
                GI3* SetPixelFormat    ;
                GI3* SwapBuffers       ;
            };

            struct mcv_t_lib_u32{
                G00* CreateWindowExW   ;
                GI3* DefWindowProcW    ;
                GI3* DestroyWindow     ;
                GI3* DispatchMessageW  ;
                GI3* GetClientRect     ;
                G00* GetDesktopWindow  ;
                GI3* GetWindowDC       ;
                GI3* LoadCursorA       ;
                GI3* LoadIconA         ;
                GI3* MessageBoxW       ;
                GI3* PeekMessageW      ;
                GI3* PostQuitMessage   ;
                GI3* RegisterClassExW  ;
                GI3* SetFocus          ;
                GI3* ShowWindow        ;
                GI3* TranslateMessage  ;
                GI3* UpdateWindow      ;
            };

            struct mcv_t_lib_k32{
                /** We might not need kernel32 since doing **/
                /** window on a single thread.             **/

                G00* GetModuleHandleW ;
            };

        //:- - - - - - - - - -:WIN32:Function_Pointer_Structs://

    //:-----------------------------:Function_Pointer_Structs://

//:====================================================:TYPES://
//:WIN32_WINDOW_TYPES:=======================================://

    #define CON const
    #define TYP struct mcv_t_wndclassexw

        struct mcv_t_wndclassexw {
                U32   cbSize       ;
                U32   style        ;
                GI3*  lpfnWndProc  ;
                I32   cbClsExtra   ;
                I32   cbWndExtra   ;
                VOD*  hInstance    ;
                VOD*  hIcon        ;
                VOD*  hCursor      ;
                VOD*  hbrBackground;
            CON U16*  lpszMenuName ;
            CON U16*  lpszClassName;
                VOD*  hIconSm      ;
        };
        S_A( S_O( TYP ) == 80 , "[mcv_t_wndclassexw]" );

    #undef  CON
    #undef  TYP
    #define P_T struct mcv_t_point

        //:[ wtypes.h ]://

            struct mcv_t_point {
                I32 x ;
                I32 y ;
            };

        //:[ winuser.h ]&[ wtypes.h ]://

            struct mcv_t_msg {
                VOD*    hwnd;
                U32  message;
                U64   wParam;   
                I64   lParam;   
                U32     time;  
                P_T       pt;
            };

    #undef  P_T

//:=======================================:WIN32_WINDOW_TYPES://
//:VULKAN_CORE_TYPES:========================================://
//:                                                          ://
//: #VULKAN_TYPES# #TYPES_VULKAN# #VULKAN_HEADER_TYPES#      ://
//:                                                          ://
//:- - - - - - - - - - - - - - -- - - - - - - - - - - - - - -://

//:VkStructureType://

    //: typedef I32 MCV_T_VKSTRUCTURETYPE ;

//:VkInstanceCreateFlags://

    //: typedef U32 MCV_T_VKINSTANCECREATEFLAGS

//:VkApplicationInfo://

    struct mcv_t_vkapplicationinfo {
              I32       typ;           //:             sType ://
        const VOD*      nex;           //:             pNext ://
                                       
              CHR*  app_nam;           //:  pApplicationName ://
              U32   app_ver;           //:applicationVersion ://
                                       
              CHR*  eng_nam;           //:       pEngineName ://
              U32   eng_ver;           //:     engineVersion ://
                                       
              U32   api_ver;           //:        apiVersion ://
    };
    S_A( sizeof( struct mcv_t_vkapplicationinfo ) == 48 );

//:VkInstanceCreateInfo://

    #define CON const
    #define C_I struct mcv_t_vkinstancecreateinfo
    #define A_I struct mcv_t_vkapplicationinfo
    #define CCC const char* const*

        struct mcv_t_vkinstancecreateinfo {

            I32      typ ;   //: sType                       ://
        CON VOD*     nex ;   //: pNext                       ://
            U32      c_f ;   //: VkInstanceCreateFlags flags ://
                             
        CON A_I*     a_i ;   //: pApplicationInfo            ://
                                                             
            U32  lay_num ;   //: enabledLayerCount           ://
            CCC  lay_arr ;   //: ppEnabledLayerNames         ://
                             
            U32  ext_num ;   //: enabledExtensionCount       ://
            CCC  ext_arr ;   //: ppEnabledExtensionNames     ://
        };
        S_A( S_O( C_I ) == 64 );

    #undef  CON
    #undef  C_I
    #undef  A_I
    #undef  CCC

//:VkAllocationCallbacks://
                
    /** typedef void mcv_t_vkallocationcallbacks **/      

//:VkInstance://
            
    /** typedef void mcv_t_vkinstance **/ 

//:VkExtensionProperties://

    struct mcv_t_vkextensionproperties {
        NCC  ext_nam[ mcv_m_men ];           //:extensionName://
        U32  spe_ver             ;           //:specVersion  ://
    };
    S_A( sizeof( struct mcv_t_vkextensionproperties ) == 260 );
    S_A( sizeof( VEP )                                == 260 );

//:VkPhysicalDevice://

    /** **************************************************** **/
    /** DONT CREATE: typedef void MCV_T_VKPHYSICALDEVICE     **/
    /** Just use void* when you want VkPhysicalDevice        **/
    /** Documentation: VK_DEFINE_HANDLE(VkPhysicalDevice)    **/
    /** **************************************************** **/

//:VkPhysicalDeviceType://

    //:------------------------------------------------------://
    //: I find enums kind of useless, so just use a I32      ://
    //: whenever a member variable or parameter says         ://
    //: that it is an enum.                                  ://
    //:------------------------------------------------------://

    //:------------------------------------------------------://
    //:  // Provided by VK_VERSION_1_0                       ://
    //:  enum mcv_t_vkphysicaldevicetype {                   ://
    //:      VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,              ://
    //:      VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,     ://
    //:      VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,       ://
    //:      VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,        ://
    //:      VK_PHYSICAL_DEVICE_TYPE_CPU = 4,                ://
    //:  };                                                  ://
    //:------------------------------------------------------://

//:VkPhysicalDeviceLimits ( PDL ) ://

    //: This struct has about 106 (+-1) members.
    //: That is a lot of bloat. So in our code rather than
    //: paste all of that bloat, we will just make a struct
    //: that has the correct size in bytes of the vulkan
    //: header type[ VkPhysicalDeviceLimits ].
    struct mcv_t_vkphysicaldevicelimits{
        U08 data[ 504 ];
    };
    S_A( sizeof( struct mcv_t_vkphysicaldevicelimits ) == 504 );
    S_A( sizeof( PDL )                                 == 504 );

//:VkPhysicalDeviceSparseProperties://

    struct mcv_t_vkphysicaldevicesparseproperties {
    
        //: rs == "residencyStandard"
        //: re == "residencyExtra" (NOT residencyStandard)

        //: residencyStandard2DBlockShape
        U32 rs_2DBlockShape              ;

        //: residencyStandard2DMultisampleBlockShape 
        U32 rs_2DMultisampleBlockShape   ;

        //: residencyStandard3DBlockShape:
        U32 rs_3DBlockShape              ;

        //: residencyAlignedMipSize
        U32 re_AlignedMipSize            ;

        //: residencyNonResidentStrict
        U32 re_NonResidentStrict         ;
    };
    S_A( S_O( struct mcv_t_vkphysicaldevicesparseproperties ) 
                                                        == 20 );
    S_A( S_O( DSP ) == 20 );

//:VkPhysicalDeviceProperties://

    S_A( sizeof( I32 ) == 4 );
    struct mcv_t_vkphysicaldeviceproperties {
        U32            apiVersion             ;     //:   4  ://
        U32         driverVersion             ;     //:   4  ://
                                                    //:      ://
        U32              vendorID             ;     //:   4  ://
        U32              deviceID             ;     //:   4  ://
                                                    //:      ://
        I32           deviceType              ;     //:   4  ://
                                                    //:      ://
        NCC            deviceName[ mcv_m_mpd ];     //: 256  ://
        U08     pipelineCacheUUID[ mcv_m_uid ];     //:  16  ://
                                                    //:      ://                                      
        U08 pad_001[ 4 ]                      ;              
        PDL                limits             ;     //: 504  ://
        DSP      sparseProperties             ;     //:  20  ://
        U08 pad_002[ 4 ]                      ;
    };
    S_A( (4+4 + 4+4 + 4 + 256+16 + 504+20)             == 816 );
    S_A( S_O( struct mcv_t_vkphysicaldeviceproperties )!= 816 );

    S_A( (816 + 4 + 4 )                                == 824 );
    S_A( S_O( struct mcv_t_vkphysicaldeviceproperties )== 824 ); 

//:VkPhysicalDeviceFeatures

    //:------------------------------------------------------://
    //: Used TWICE:                                          ://
    //:                                                      ://
    //: 1st: To QUERY   physical device      FEATURES.       ://
    //: 2nd: To REQUEST physical device with FEATURES.       ://
    //:                                                      ://
    //: 1st: VT/../Setup/Physical_devices_and_queue_families ://
    //: 2nd: VT/../Setup/Logical_device_and_queues           ://
    //:------------------------------------------------------://

    S_A( 8 * 220 == 32 * 55 );
    struct mcv_t_vkphysicaldevicefeatures {
        //: U08 data[ 220 ];
        U32 data[ 55 ]; //:<--SizeOf[ VkBool32 ]://
    };
    S_A( S_O( struct mcv_t_vkphysicaldevicefeatures ) == 220 );

//:VkQueueFlags

    /** VkQueueFlags is a typedef for uint32_t **/
    /** Just use U32 to reduce abstraction.    **/

//:VkExtent3D

    #define E3D struct mcv_t_vkextent3d

        struct mcv_t_vkextent3d{
            U32 wid ; //: width  ://
            U32 hig ; //: height ://
            U32 dep ; //: depth  ://
        };
        S_A( S_O( E3D ) == 12 , "[E3D]" );

    #undef  E3D

//:VkQueueFamilyProperties

    #define E3D struct mcv_t_vkextent3d
    #define QFP struct mcv_t_vkqueuefamilyproperties

        struct mcv_t_vkqueuefamilyproperties{
            U32 q_f ;        //: queueFlags                  ://
            U32 num ;        //: queueCount                  ://
            U32 tim ;        //: timestampValidBits          ://
            E3D min ;        //: minImageTransferGranularity ://
        };
        S_A( S_O( QFP ) == 24 , "[QFP]" );

    #undef  EXT
    #undef  QFP

//:VkDeviceQueueCreateFlags

    /** Typedef resolves to U32 , so use U32. **/

//:VkDeviceQueueCreateInfo 

    #define C_I struct mcv_t_vkdevicequeuecreateinfo

        // Provided by VK_VERSION_1_0
        struct mcv_t_vkdevicequeuecreateinfo {
                  I32    typ ;    //: sType                  ://
            const VOD*   nex ;    //: pNext                  ://
                  U32    c_f ;    //: flags ( create flags ) ://
                  U32    fam ;    //: queueFamilyIndex       ://
                  U32    num ;    //: queueCount             ://
            const F32*   q_p ;    //: pQueuePriorities       ://
        };
        S_A( S_O( C_I ) == 40 , "[D_Q_C_I]" );

    #undef  C_I

//:VkDevice ( logical device ):

    /** Do not create this. It is just a void pointer. **/
    /** SEE: mcv_d_log_dev *************************** **/

//:VkDeviceCreateFlags:

    /** Resolves to a U32 for bit packing flags. **/
    /** So just use   U32.                       **/

//:VkDeviceCreateInfo: (LogicalDevice):

    #define DCI struct mcv_t_vkdevicecreateinfo
    #define C_I struct mcv_t_vkdevicequeuecreateinfo
    #define LIS const char* const* //:Immutable List://
    #define FET struct mcv_t_vkphysicaldevicefeatures

        struct mcv_t_vkdevicecreateinfo {
                  I32       typ; //: sType                   ://
            const VOD*      nex; //: pNext                   ://
                  U32       c_f; //: flags                   ://
                        
                  U32   qci_num; //: queueCreateInfoCount    ://
            const C_I*  qci_arr; //: pQueueCreateInfos       ://
                                                    
                  U32   lay_num; //: enabledLayerCount       ://
                  LIS   lay_arr; //: ppEnabledLayerNames     ://
                                     
                  U32   ext_num; //: enabledExtensionCount   ://
                  LIS   ext_arr; //: ppEnabledExtensionNames ://

            const FET*      fet; //: pEnabledFeatures        ://
        };
        S_A( S_O( DCI ) == 72 , "[CHECKSUM_DCI]" );

    #undef  DCI
    #undef  C_I
    #undef  LIS
    #undef  FET

//:VkAllocationCallbacks:

    #define C_B struct mcv_t_vkallocationcallbacks

        struct mcv_t_vkallocationcallbacks {
            U64 data[ 6 ];   //:Six Pointer Members In Struct://
        };
        S_A( S_O( C_B ) == 48 , "[CHECKSUM:C_B]" );

    #undef  C_B

//:VkSurfaceKHR://

    /** Just use void pointer because is defined as opaque.  **/

//:VkWin32SurfaceCreateFlagsKHR://
    
    /** Just Use U32 because that's what it resolves to. **/

//:VkWin32SurfaceCreateInfoKHR://

    #define W_S struct mcv_t_vkwin32surfacecreateinfokhr

        // Provided by VK_KHR_win32_surface
        struct mcv_t_vkwin32surfacecreateinfokhr{
                  I32   typ;                //: sType        ://
            const VOD*  nex;                //: pNext        ://
                  I32   c_f;                //: Create_Flags ://
                  VOD*  exe;                //: hInstance    ://
                  VOD*  win;                //: hwnd         ://
        };
        S_A( S_O( W_S ) == 40 , "[win32_surf_size]" );
    
    #undef  W_S

//: VkQueue ://

    /** Use void* because: VK_DEFINE_HANDLE(VkQueue) **/

//: VkDeviceQueueCreateInfo ://
//
//  WE ALREADY MADE THIS TYPE. THOUGH I LIKE THE FORMATTING
//  HERE MORE. MAYBE REFACTORE AND USE THIS LATER?
//
//  #define CON const
//  #define TMP struct mcv_t_vkdevicequeuecreateinfo
//   
//      struct mcv_t_vkdevicequeuecreateinfo {
//                  I32     typ ;       //: sType            ://
//          CON     VOD*    nex ;       //: pNext            ://
//                  U32     c_f ;       //: flags            ://
//                  U32     dex ;       //: queueFamilyIndex ://
//                  U32     num ;       //: queueCount       ://
//          CON     F32*    q_p ;       //: pQueuePriorities ://
//      };
//      S_A( S_O( TMP ) == 40 , "[VK_DQCI]" );
//
//  #undef  CON
//  #undef  TMP
    
//:========================================:VULKAN_CORE_TYPES://
//:DATA:=====================================================://

    //:MISC_DATA:--------------------------------------------://

        I32 mcv_d_kot =( 1 );          //:KOT:Keep_On_ticking://

    //:--------------------------------------------:MISC_DATA://
    //:DLL:--------------------------------------------------://
    
        //:Vulkan DLL(s):

            DLL* mcv_d_dll_vul = ((DLL*)0);

        //: Microsoft Windows Window DLL(s):                 ://

            DLL* mcv_d_dll_g32 = ((DLL*)0); //:"gdi32.dll"   ://
            DLL* mcv_d_dll_u32 = ((DLL*)0); //:"kernel32.dll"://
            DLL* mcv_d_dll_k32 = ((DLL*)0); //:"user32.dll"  ://

    //:--------------------------------------------------:DLL://
    //:FPS:FUNCTION_POINTER_STRUCTS:=========================://

        //: #_DO_NOT_POPULATE_FPS_USING_HELPER_FUNCTIONS_#   ://

        struct mcv_t_lib_g32 mcv_d_lib_g32 ={ 0 };
        struct mcv_t_lib_u32 mcv_d_lib_u32 ={ 0 };
        struct mcv_t_lib_k32 mcv_d_lib_k32 ={ 0 };

    //:=========================:FPS:FUNCTION_POINTER_STRUCTS://
    //:WIN32_DATA:-------------------------------------------://

        VOD* mcv_d_exe = ((VOD*)0); //:hInstance ://
        VOD* mcv_d_win = ((VOD*)0); //:hwnd      ://

    //:-------------------------------------------:WIN32_DATA://
    //:VULKAN_MISC:(Not Vulkan Object Instances):------------://

        //:EXTENSIONS:- - - - - - - - - - - - - - - - - - - -://
    
            //: [aie] : Available_Instance_Extensions
            //: [rie] : Required__Instance_Extensions
            //: [ade] : Available___Device_Extensions
            //: [rde] : Required____Device_Extensions

            //::instance_extensions: : : : : : : : : : : : : ://

                //:FOR:VkEnumerateInstanceExtensionProperties://
                
                    //:ins_ext ==           Instance_Extensions
                    //:    aie == Available_Instance_Extensions

                    #define  mcv_m_c_aie                ( 32 )    
                    VEP      mcv_d_a_aie[ mcv_m_c_aie ]={  0 };
                    U32      mcv_d_n_aie               =(  0 ); 
                    #define  mcv_d_c_aie [USE:mcv_m_c_aie]
                    #define  mcv_m_n_aie [USE:mcv_d_n_aie]
                    
                //:FOR: ppEnabledExtensionNames://

                    CHR* mcv_d_a_rie[ mcv_m_n_rie ]={
                        "VK_KHR_surface"
                    ,   "VK_KHR_win32_surface"
                    };  //:#_HOW_DID_I_DECIDE_ON_RIE_#://

            //:: : : : : : : : : : : : : :instance_extensions://
            //:device_extensions:: : : : : : : : : : : : : : ://

                //:FOR:vkEnumerateDeviceExtensionProperties  ://
        
                    #define  mcv_m_c_ade                ( 256)    
                    VEP      mcv_d_a_ade[ mcv_m_c_ade ]={  0 };
                    U32      mcv_d_n_ade               =(  0 ); 
                    #define  mcv_d_c_ade [USE:mcv_m_c_ade]
                    #define  mcv_m_n_ade [USE:mcv_d_n_ade]
                
                //:FOR:cross checking to see if we have what
                //:    we require.

                    CHR* mcv_d_a_rde[ mcv_m_n_rde ]={
                        "VK_KHR_swapchain"  
                    };

            //:: : : : : : : : : : : : : : :device_extensions://

        //:- - - - - - - - - - - - - - - - - - - -:EXTENSIONS://

        //: FOR: VkDeviceQueueCreateInfo

            const F32 mcv_d_q_p =( 1.0 );  //: queuePriority ://

        //: FOR: uniqueQueueFamilies :

            #define mcv_d_c_qfi [USE_MACRO:mcv_m_c_qfi]
            #define mcv_m_c_qfi                  ( 3 )
            U32     mcv_d_a_qfi[ mcv_m_c_qfi ]  ={ 0 };
            U32     mcv_d_n_qfi                 =( 0 );

    //:------------------------------------------:VULKAN_MISC://
    //:VULKAN_OBJECTS:---------------------------------------://
    #define ICI struct mcv_t_vkinstancecreateinfo 
    #define A_I struct mcv_t_vkapplicationinfo
    #define QFP struct mcv_t_vkqueuefamilyproperties

        //:Application_Info:

            A_I   mcv_d_applicationinfo ={ 0 };   
 
        //:Vulkan_Instance :

            ICI   mcv_d_c_instance  ={   0   };
            VOD*  mcv_d_o_instance  =((VOD*)0);

        //: Physical_Device:( phy_dev ):- - - - - - - - - - -://
        //:     m_c : Macro_Capacity                         ://
        //:     d_a : Data__Array                            ://
        //:     d_n : Data__NumberOf( in array )             ://
        //:     d_o : Data__Object( Choosen Physical Device )://

            #define  mcv_m_c_phy_dev (  8 ) 
            VOD*     mcv_d_a_phy_dev[ mcv_m_c_phy_dev ];
            U32      mcv_d_n_phy_dev =( 0 );
            VOD*     mcv_d_o_phy_dev =( NIL ); 
            #define    mcv_d_phy_dev [USE:mcv_d_o_phy_dev]

        //: queueFamilies for the given Physical_Device:- - -://

            #define  mcv_d_c_qfp [USE:mcv_m_c_qfp]
            #define  mcv_m_c_qfp (  16 )  
            QFP      mcv_d_a_qfp[ mcv_m_c_qfp ];
            U32      mcv_d_n_qfp =( 0 );

            I32      mcv_d_i_qfp_com =( 0 - 1 );  //:COMPUTE ://
            I32      mcv_d_i_qfp_gra =( 0 - 1 );  //:GRAPHICS://
            I32      mcv_d_i_qfp_pre =( 0 - 1 );  //:PRESENT ://
            
        //: Logical_Device: ( log_dev ):- - - - - - - - - - -://

            VOD*       mcv_d_log_dev =( NIL );
            #define  mcv_d_o_log_dev [USE:mcv_d_log_dev]

        //: Surface:- - - - - - - - - - - - - - - - - - - - -://
        
            #define C_I struct mcv_t_vkwin32surfacecreateinfokhr
            #define OBJ VOD
        
                //: mcv_d_c_sur =VkWin32SurfaceCreateInfoKHR ://
                //: mcv_d_o_sur =VkSurfaceKHR                ://

                C_I  mcv_d_c_sur ={ 0 }    ;   
                OBJ* mcv_d_o_sur =((VOD*)0);  

            #undef  C_I
            #undef  OBJ

        //: Queue:- - - - - - - - - - - - - - - - - - - - - -://
        #define QCI struct mcv_t_vkdevicequeuecreateinfo

            //: VkQueue(s): Compute,Graphics,Present:        ://
            
                //:      d_q_*** == data_queue_[com|gra|pre] ://
                VOD* mcv_d_q_com =(NIL);    //: computeQueue ://
                VOD* mcv_d_q_gra =(NIL);    //: graphicsQueue://
                VOD* mcv_d_q_pre =(NIL);    //: presentQueue ://

            //:ARRAY: VkDeviceQueueCreateInfo( qci )

                #define mcv_m_c_qci ( 3 )
                #define mcv_d_c_qci [USE_MACRO:mcv_m_c_qci]
                QCI     mcv_d_a_qci[ mcv_m_c_qci ] ={ 0 };
                I32     mcv_d_n_qci                =( 0 );

                S_A( mcv_m_c_qci == mcv_m_c_qfi , "[QCI:QFI]" );

        #undef  QCI

    #undef  ICI
    #undef  A_I
    #undef  QFP
    //:---------------------------------------:VULKAN_OBJECTS://

//:=====================================================:DATA://
//:FUNCTIONS_BASIC:==========================================://

    VOD  mcv_f_err( CHR* msg ){
        P_F( "\n\n\n\n[mcv_f_err]:%s \n\n\n\n\n" , msg );
        F_F( stdout );
        exit( 0xFF );
    }

    VOD  mcv_f_say( CHR* msg ){
        P_F( "[mcv_f_say]:%s" , msg );
        F_F( stdout );
    }

    VOD  mcv_f_chk( I32  res , CHR* msg ){
    #define P P_F
    #define B break

        if( 0 != res ){ 
            P_F( "[chk_fail:res]:%d\n" , res );
            P_F( "[chk_fail:msg]:%s\n" , msg );

            switch( res ){
            case (0-7) : P("[EXTENSION_NOT_PRESENT]\n"); B;
            default:
            };;

            ERR("[FAILED_CHECK]");
        }else
        if( 0 == res ){ 
            P_F( "[chk_pass:res]:%d\n" , res );
            P_F( "[chk_pass:msg]:%s\n" , msg );
        };;

    #undef  P
    #undef  B
    }

    VOD  mcv_f_ass( U32 t_f  , CHR* msg ){
        if( 0 == t_f ){
            P_F( "[MCV_ASSERT_FAIL:MSG]:%s" , msg );
            ERR( "[MCV_ASSERT_FAIL:SEE_ABOVE]"    );
        };;
    }

    VOD  mcv_f_n_c( VOD* obj , CHR* msg ){
        if( NIL == obj ){ 

            P_F( "[FAIL:N_C]:%s\n"  ,  msg                  ); 
            ERR( "[FAIL:N_C]:[SEE_ABOVE_TRACEBACK_MESSAGE]" );
        };;
    }

    //:GPA_Basic:--------------------------------------------://

        GI3* mcv_f_gpa( DLL* dll , CHR* nam ){

            if( ((DLL*)0) == dll ){ ERR("[NIL:DLL]"); };
            if( ((CHR*)0) == nam ){ ERR("[NIL:NAM]"); };

            GI3* fun = (GI3*)GetProcAddress( dll , nam );
            if( ((GI3*)0) == fun ){
                P_F("[NAME_OF_FUNCTION]:%s\n" , nam );
                ERR("[FAILED:mcv_f_gpa]\n");
            };;
            return( fun );
        }

    //:--------------------------------------------:GPA_Basic://
    //:GPA_Specific:-----------------------------------------://

        //:GPA: VULKAN DLL://

            GI3* mcv_f_gpa_vul( CHR* nam ){

                DLL* dll =( mcv_d_dll_vul );
                if( ((DLL*)0) == dll ){ ERR("[VUL_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[VUL_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: GDI32 DLL://

            GI3* mcv_f_gpa_g32( CHR* nam ){

                DLL* dll =( mcv_d_dll_g32 );
                if( ((DLL*)0) == dll ){ ERR("[G32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[G32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: USER32 DLL://

            GI3* mcv_f_gpa_u32( CHR* nam ){

                DLL* dll =( mcv_d_dll_u32 );
                if( ((DLL*)0) == dll ){ ERR("[U32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[U32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: KERNEL32 DLL://

            GI3* mcv_f_gpa_k32( CHR* nam ){

                DLL* dll =( mcv_d_dll_k32 );
                if( ((DLL*)0) == dll ){ ERR("[K32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[K32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

    //:-----------------------------------------:GPA_Specific://

//:==========================================:FUNCTIONS_BASIC://
//:FUNCTIONS_DEBUGGING:======================================://

    I32 mcv_f_cra(          //: CRA: Compute_Relative_Address://
        VOD*  a_s           //: Address Of Struct.           ://
    ,   VOD*  a_m           //: Address Of Member.          ://
    ){
        I32  act =  (I32)( a_m - a_s );
        return( act );
    }

    VOD mcv_f_ara(          //: ARA: Assert_Relative_Address ://
        VOD* a_s            //: Address Of Struct.           ://
    ,   VOD* a_m            //: Address Of Member.           ://
    ,   I32  rel            //: Relative Address Of Member   ://
    ,   CHR* msg            //: On Error Message             ://
    ){
        I32  act =  mcv_f_cra( a_s , a_m );
        if(  act != rel ){
            P_F( "[ARA_FAIL:MSG]:%s\n" , msg );
            ERR( "[FAIL:ASSERT_RELATIVE_ADDRESS(ARA)]" );
        };;
    }

//:======================================:FUNCTIONS_DEBUGGING://
//:FUNCTIONS_VULKAN:=========================================://
//:VULKAN_FUNCTIONS:=========================================://

//: vkCreateInstance ://

    RES mcv_f_vkcreateinstance(
        const struct mcv_t_vkinstancecreateinfo*                 
                                            pCreateInfo 
    ,   const VOD*                           pAllocator 
    ,   VOD*                                 pInstance
    ){
        GI3* fun = mcv_f_gpa_vul( "vkCreateInstance" );
        return( (RES)fun( pCreateInfo,pAllocator,pInstance ) );
    }

//: VK_MAKE_VERSION ( vmv ) ://

    U32 mcv_f_vmv( U32 maj , U32 min , U32 pat ){
        U32 out =( ((U32)0)
        |   ( maj << 22 )
        |   ( min << 12 )
        |   ( pat <<  0 )
        );;
        return( out );
    }

//: VK_MAKE_API_VERSION ( mav ) ://

    U32 mcv_f_mav( U32 var , U32 maj , U32 min , U32 pat ){
        U32 out =( ((U32)0)
        |   ( var << 29 )
        |   ( maj << 22 )
        |   ( min << 12 )
        |   ( pat <<  0 )
        );;
        return( out );
    }
    
//: vkEnumerateInstanceExtensionProperties ( EIEP ) ://

    RES mcv_f_eiep(
        CHR*    N                  //: Name : pLayerName     ://
    ,   U32*    C                  //: Count: pPropertyCount ://
    ,   VEP*    A                  //: Array: pProperties    ://
    ){
        GI3* fun =mcv_f_gpa_vul( 
        "vkEnumerateInstanceExtensionProperties" );;
        return( fun( N,C,A ) );
    }

//: vkEnumeratePhysicalDevices ( EPD ) ://

    RES mcv_f_epd(
        VOD*  I //: VkInstance                               ://
    ,   U32*  N //: NumberOf:Devices ( pPhysicalDeviceCount )://
    ,   VOD** A //: Array_Of:Devices ( pPhysicalDevices     )://
    ){
        GI3* fun =mcv_f_gpa_vul( "vkEnumeratePhysicalDevices" );
        return( (RES)fun( I,N,A ) );
    }

//: vkGetPhysicalDeviceProperties ://

    #define TMP struct mcv_t_vkphysicaldeviceproperties
    #define GET mcv_f_gpa_vul

        VOD mcv_f_vkgetphysicaldeviceproperties(
            VOD* phy_dev
        ,   TMP*     pdp
        ){
            GI3* fun =GET( "vkGetPhysicalDeviceProperties" );
            fun( phy_dev , pdp );
        }
    #undef  TMP
    #undef  GET

//: vkGetPhysicalDeviceFeatures ://

    #define TMP struct mcv_t_vkphysicaldevicefeatures
    #define GET mcv_f_gpa_vul

        VOD mcv_f_vkgetphysicaldevicefeatures(
            VOD* phy_dev
        ,   TMP*     pdf
        ){
            GI3* fun =GET( "vkGetPhysicalDeviceFeatures" );
            fun( phy_dev , pdf );
        }
    #undef  TMP
    #undef  GET

//: PRINT: PhysicalDeviceProperties:

    VOD mcv_f_p_vkphysicaldeviceproperties(
        struct mcv_t_vkphysicaldeviceproperties * pdp
    ){
        /** mcv_f_p : MCVnamespace_Function_Print **/

        P_F( "[apiVersion]:%d\n"        , (*pdp).apiVersion   );
        P_F( "[driverVersion]:%d\n"     , (*pdp).driverVersion);
        P_F( "[vendorID]:%d\n"          , (*pdp).vendorID     );
        P_F( "[deviceID]:%d\n"          , (*pdp).deviceID     );
        P_F( "[deviceType]:%d\n"        , (*pdp).deviceType   );
                                                        
        P_F( "[deviceName]:%s\n"        , (*pdp).deviceName   );

        P_F( "[pipelineCacheUUID]:%s\n" , "[SKIP_PRINTING]"   );
        P_F( "[limits]:%s\n"            , "[SKIP_PRINTING]"   );
        P_F( "[sparseProperties]:%s\n"  , "[SKIP_PRINTING]"   );
    }

//: vkGetPhysicalDeviceQueueFamilyProperties ://

    #define DEV VOD*   //: MCV_T_VKPHYSICALDEVICE ://
    #define QFP struct     mcv_t_vkqueuefamilyproperties

        VOD mcv_f_g_qfp(
            DEV  phy_dev //: VkPhysicalDevice physicalDevice ://
        ,   U32* qfp_num //: pQueueFamilyPropertyCount       ://
        ,   QFP* qfp_arr //: VkQueueFamilyProperties*        ://
                         //: pQueueFamilyProperties          ://
        ){
            GI3* fun =mcv_f_gpa_vul( 
                "vkGetPhysicalDeviceQueueFamilyProperties" );;
            fun( phy_dev , qfp_num , qfp_arr );
        }
    #undef  DEV
    #undef  QFP

//: vkCreateDevice (LogicalDevice) ://

    #define DCI struct mcv_t_vkdevicecreateinfo
    #define C_B struct mcv_t_vkallocationcallbacks
    #define CON const

        RES mcv_f_vkcreatedevice(
                VOD*      phy             //: physicalDevice ://
        ,   CON DCI*      dci             //: pCreateInfo    ://
        ,   CON C_B*  nil_001             //: pAllocator     ://
        ,       VOD*      log             //: pDevice        ://
        ){
            if( ECI >= 1 ){
                //:Hackish Validation:
                if( NIL == phy       ){ ERR("[NIL_PHY]"); };
                if(  3  != dci -> typ){ ERR("[DCI_TYP]"); };
                if( NIL != nil_001   ){ ERR("[NIL!001]"); };
                if( NIL == log       ){ ERR("[NIL_LOG]"); };
            };;

            GI3* fun =mcv_f_gpa_vul( "vkCreateDevice" );
            return( (RES)fun( phy , dci , nil_001 , log  ) );
        };

    #undef  DCI
    #undef  C_B
    #undef  CON

//: vkCreateWin32SurfaceKHR ://

    #define CON const
    #define C_I struct mcv_t_vkwin32surfacecreateinfokhr
    #define C_B struct mcv_t_vkallocationcallbacks

        RES mcv_f_vkcreatewin32surfacekhr(
                VOD*    v_i      //: (vulkan)instance        ://
        ,   CON C_I*    c_i      //: pCreateInfo             ://
        ,   CON C_B*    c_b      //: pAllocator              ://
        ,       VOD*    out      //: VkSurfaceKHR : pSurface ://
        ){
            GI3* fun = mcv_f_gpa_vul( 
                "vkCreateWin32SurfaceKHR" 
            );;

            if( ECI >= 1 ){  //:- - - - - - - - - - - - - - -://

                if( ((VOD*)0) == v_i ){ ERR("[cw32s:v_i]"); };
                if( ((VOD*)0) == c_i ){ ERR("[cw32s:c_i]"); };
                if( ((VOD*)0) != c_b ){ ERR("[cw32s:c_b]"); };
                if( ((VOD*)0) == out ){ ERR("[cw32s:out]"); };

                //:VK_STRUCTURE_TYPE_...
                //:            WIN32_SURFACE_CREATE_INFO_KHR ://
                if( (*c_i).typ != 1000009000 ){ 
                    ERR("[cw32s:(*c_i).typ]" ); };;

            };; //:- - - - - - - - - - - - - - - - - -( ECI )://

            SAY( "[BEFORE_CALL:vkCreateWin32SurfaceKHR]" );

            RES res = (RES)fun( v_i , c_i , c_b , out  );

            SAY( "[AFTER__CALL:vkCreateWin32SurfaceKHR]" );

            return( (res) );
        }

    #undef  CON
    #undef  C_I
    #undef  C_B

//: vkGetPhysicalDeviceSurfaceSupportKHR ://

    RES mcv_f_g_phy_ssk(
        VOD*    phy                 //: PhysicalDevice       ://
    ,   U32     qfi                 //: queueFamilyIndex     ://
    ,   VOD*    sur                 //: surface              ://
    ,   U32*    out                 //: VkBool32*:pSupported ://
    ){
        GI3* fun = mcv_f_gpa_vul( 
            "vkGetPhysicalDeviceSurfaceSupportKHR" );;
        return( (RES)fun( phy , qfi , sur , out  ) );
    }

//: vkGetDeviceQueue ://

    VOD mcv_f_vkgetdevicequeue(
        VOD*     log            //:LogicalDevice             ://
    ,   U32      qfi            //:queueFamilyIndex          ://
    ,   U32      _0_            //:#_queueIndex_ZERO_ALWAYS_#://
    ,   VOD*     out            //:VkQueue : pQueue          ://
    ){
        if( ECI >= 1 ){
            if( NIL ==          log  ){ ERR("[LOG]"        ); };
            if( qfi  >           64  ){ ERR("[#_064_QFI_#]"); };
            if( _0_ !=            0  ){ ERR("[NOT_ZERO]"   ); };
            if( NIL ==          out  ){ ERR("[GDQ:@NDP@]"  ); };
            if( NIL != *((VOD**)out) ){ ERR("[004]"        ); };
        };;

        GI3* fun = mcv_f_gpa_vul( "vkGetDeviceQueue" );;
        fun( log , qfi , _0_ , out  );
    }

//: vkEnumerateDeviceExtensionProperties ://

    #define E_P struct mcv_t_vkextensionproperties

        RES mcv_f_vkenumeratedeviceextensionproperties(
            VOD*   phy                  //:  physicalDevice  ://
        ,   CHR*   nil                  //:  NIL:pLayerName  ://              
        ,   U32*   num                  //:  pPropertyCount  ://
        ,   E_P*   arr                  //:  pProperties     ://
        ){
            if( ECI >= 1 ){
                if( NIL == phy ){ ERR("[007]"); };
                if( NIL != nil ){ ERR("[008]"); };
                
                if( NIL == arr ){  /** OKAY **/ };
                if( NIL == num ){ 

                    ERR("[009:@NNP@]"); //:NullNumberPointer://

                };;
                if( NIL == arr ){
                    if( ((U32)0) != (*num) ){ 

                        P_F( "[010:NUM]:%d\n" , num );
                        ERR("[010]" ); //:@AMS@://
                    };
                };;
            };;

            GI3* fun = mcv_f_gpa_vul( 
                "vkEnumerateDeviceExtensionProperties" );
            fun( phy , nil , num , arr  );

            if( ECI >= 1 ){
                if( NIL == num ){
                    ERR("[num_made_nil]");
                };;
            };;
        }
    #undef  E_P

//:=========================================:FUNCTIONS_VULKAN://
//:=========================================:VULKAN_FUNCTIONS://
//:FUNCTIONS:================================================://

    DLL* mcv_f_dll_get( CHR* nam ){

        DLL* dll = LoadLibraryA( nam );
        if( ((DLL*)0) == dll ){
            ERR( "[FAILED_TO_LOAD_DLL]" );
        };;
        return( dll );
    }

    //:Default_Win32_WindowProc:-----------------------------://

        I64 __stdcall mcv_f_windowproc(
            VOD*    hwnd
        ,   U32     uMsg
        ,   U64   wParam  
        ,   I64   lParam  
        ){

            I64 res =( 64 );        //: init result to error ://

            switch (uMsg){

            case 0x0002 /** WM_DESTROY **/ :{

                mcv_d_lib_u32.PostQuitMessage(0);
                mcv_d_kot =( 0-1 );
                res=( 0 );

            };break;
            case 0x000F /** WM_PAINT **/ :{

                //:DONT DO ANY PAINTING HERE, VULKAN IS GOING
                //:TO TAKE CARE OF THAT FOR US.
                res=( 0 );

            };break;
            default:{

                res =( mcv_d_lib_u32.DefWindowProcW(
                    hwnd, uMsg, wParam, lParam));

            };break;}

            return( res ); 
        }


    //:-----------------------------:Default_Win32_WindowProc://

    PUBLIC_FUNCTION

    VOD  MCV_F_INI( VOD ){              //:Initialize Library://

        //:Debug:--------------------------------------------://
        {
        #define A mcv_f_ara

            //:Make sure padding hack has not altered the
            //:relative address of these memebers.
            struct mcv_t_vkphysicaldeviceproperties t={ 0 };
            A( &( t ) , &( t.pipelineCacheUUID ) , 276 ,"[1]");
            A( &( t ) , &( t.limits            ) , 296 ,"[2]");
            A( &( t ) , &( t.sparseProperties  ) , 800 ,"[3]");
            
        #undef  A
        }
        //:--------------------------------------------:Debug://
        //:Declare_Variables:--------------------------------://

            RES res =( 0 );
            SIZ siz =( 0 );

        //:--------------------------------:Declare_Variables://
        //:Load_All_Libraries:-------------------------------://
        //:VIDEO_017:----------------------------------------://
        
            //: Conceptually : mcv_f_dll_all( ) ://        
            #define GET mcv_f_dll_get

                mcv_d_dll_vul = GET( "vulkan-1.dll" );

                mcv_d_dll_g32 = GET(    "gdi32.dll" );
                mcv_d_dll_u32 = GET(   "user32.dll" );
                mcv_d_dll_k32 = GET( "kernel32.dll" );

            #undef  GET

        //:----------------------------------------:VIDEO_017://
        //:-------------------------------:Load_All_Libraries://
        //:VIDEO_017:----------------------------------------://
        //:Function_Pointer_Frontloading:--------------------://

            //:REFERENCE[ <AAC>/AAC2020/LIB/GINAWIN.D._ ]://

            #define g32 mcv_d_lib_g32
            #define u32 mcv_d_lib_u32
            #define k32 mcv_d_lib_k32

            #define   G mcv_f_gpa_g32
            #define   U mcv_f_gpa_u32
            #define   K mcv_f_gpa_k32
            
            //:G32:GDI32:

            g32.ChoosePixelFormat =G( "ChoosePixelFormat" );
            g32.GetStockObject    =G( "GetStockObject"    );
            g32.SetPixelFormat    =G( "SetPixelFormat"    );
            g32.SwapBuffers       =G( "SwapBuffers"       );

            //:U32:USER32:

            u32.CreateWindowExW   =(G00*)U( "CreateWindowExW"    );
            u32.DefWindowProcW    =U( "DefWindowProcW"     );
            u32.DestroyWindow     =U( "DestroyWindow"      );
            u32.DispatchMessageW  =U( "DispatchMessageW"   );
            u32.GetClientRect     =U( "GetClientRect"      );
            u32.GetDesktopWindow  =(G00*)U( "GetDesktopWindow"   );
            u32.GetWindowDC       =U( "GetWindowDC"        );
            u32.LoadCursorA       =U( "LoadCursorA"        );
            u32.LoadIconA         =U( "LoadIconA"          );
            u32.MessageBoxW       =U( "MessageBoxW"        );
            u32.PeekMessageW      =U( "PeekMessageW"       );
            u32.PostQuitMessage   =U( "PostQuitMessage"    );
            u32.RegisterClassExW  =U( "RegisterClassExW"   );
            u32.SetFocus          =U( "SetFocus"           );
            u32.ShowWindow        =U( "ShowWindow"         );
            u32.TranslateMessage  =U( "TranslateMessage"   );
            u32.UpdateWindow      =U( "UpdateWindow"       );

            //:K32:KERNEL32:

            k32.GetModuleHandleW  =(G00*)K( "GetModuleHandleW");

            #undef   g32
            #undef   u32
            #undef   k32

            #undef     G 
            #undef     U 
            #undef     K 
            
        //:--------------------:Function_Pointer_Frontloading://
        //:VIDEO_18:Win32_Window_002:------------------------://
        //:                                                  ://
        //:     #_CREATE_WINDOW_BEFORE_ALL_VULKAN_CODE_#     ://
        //:                                                  ://
        //:VIDEO_18:Win32_Window_002:- - - - - ---- - - - - -://
        #define k32 mcv_d_lib_k32
        #define u32 mcv_d_lib_u32
        #define W_C struct mcv_t_wndclassexw
        #define DEF ((I32)0x80000000)        /**CW_USEDEFAULT**/

            //:REFERENCE[ <AAC>/AAC2020/LIB/GINAWIN.F._ ]://

            //:Misc Variables:

                VOD*  exe = k32.GetModuleHandleW( NIL );
                UNI*  nam = L"SAMPLE_WINDOW_CLASS";
                UNI*  txt = L"LEARN_TO_PROGRAM_WINDOWS"      ;
                U32   w_s = (U32)0x00CF0000 /**OVERLAPPED**/ ;

                if( NIL == exe ){ ERR("[FAIL:GMHW]"); };
                wprintf( L"[nam]:%ls\n" , nam );
                wprintf( L"[txt]:%ls\n" , txt );
        
            //:Window Class:

                W_C w_c = { 0 };
                w_c.cbSize = sizeof( W_C );
                w_c.lpfnWndProc   = (VOD*)&( mcv_f_windowproc );   
                w_c.hInstance     = exe              ;
                w_c.lpszClassName = nam              ;

            //:Register Window Class:

                u32.RegisterClassExW( &( w_c ) );

            //:Create Window:

                VOD* mcv_d_win = u32.CreateWindowExW(
                    //:ExtendedStyle,Class,Text,WindowStyle
                    0 , nam , txt , w_s
                    //: _X_ , _Y_ , WID , HIG - - - - - - - -://
                ,       DEF , DEF , DEF , DEF 

                    //:ParentWin,Menu,exe,ExtraAppData- - - -://
                ,       u32.GetDesktopWindow()   //:ParentWin://
                ,       NIL                      //:hMenu    ://
                ,       exe                      //:hInstance://
                ,       NIL                      //:lParam(?)://
                );;
                if( NIL == mcv_d_win ){ ERR("[WINFAIL]"); };

            //:Make Window Visible:

                u32.ShowWindow( 
                    mcv_d_win
                ,  (I32)1 /**nCmdShow==SW_NORMAL**/ 
                );;

            //:Store Handle To Instance As Global For Later

                mcv_d_exe =( exe );

        #undef  k32
        #undef  u32
        #undef  W_C
        #undef  DEF
        //:------------------------:VIDEO_18:Win32_Window_002://
        //:----------------------------------------:VIDEO_017://
        //:Get_Available_Instance_Extensions( aie ):---------://

            #define NUM mcv_d_n_aie
            #define ARR mcv_d_a_aie
            #define CAP mcv_m_c_aie
            
                res = mcv_f_eiep( NIL , &NUM , NIL );
                CHK( res , "[mcv_f_eiep:GET_NUM]"  );
                if( NUM > CAP ){ ERR("[NUM>CAP]"); };
                if( NUM <= 0  ){ ERR("[NUM<=00]"); };
          
                res = mcv_f_eiep( NIL, &(NUM) , &( ARR[ 0 ] ) );
                CHK( res , "[mcv_f_eiep:GET_ARR]"  );

                P_F("[mcv_d_n_aie]:%d\n", NUM );
                for( I32 i = 0 ; i <= (NUM-1) ; i++ ){
                    P_F( 
                        "ARR[%2d]( %42s )\n"
                    ,        i
                    ,   &( ARR[ i ].ext_nam[ 0 ] )
                    );;
                };;

            #undef  NUM  
            #undef  ARR  
            #undef  CAP  

        //:---------:Get_Available_Instance_Extensions( aie )://
        //:VIDEO_012:----------------------------------------://
        //:VIDEO_012 : Has_Instance_Extensions ? :- - - - - -://
        //:Required_Instance_Extensions_All_Available? :- - -://
        {
        //:Available_Instance_Extensions :
        #define NUM_AIE mcv_d_n_aie
        #define ARR_AIE mcv_d_a_aie
        {
        //:Required__Instance_Extensions :
        #define NUM_RIE mcv_m_n_rie
        #define ARR_RIE mcv_d_a_rie
        {

            //:Compare_Available_And_Required:- - - - - - - -://
            I32            sm ; //:sm: Strings_Match         ://
            CHR* a_n ; I32 ai ; //:Available[ Name | Index ] ://
            CHR* r_n ; I32 ri ; //:Required[  Name | Index ] ://
            
            for( I32 r = 0 ; r <= (NUM_RIE-1) ; r++ ){
            for( I32 a = 0 ; a <= (NUM_AIE-1) ; a++ ){
            
                a_n = &( ARR_AIE[ a ].ext_nam[ 0 ] );
                r_n = &( ARR_RIE[ r ]        [ 0 ] );
            
                //:compare strings without strcmp://
                sm =(   1   );       //: Matches_By_Default  ://
                ai =(   0   );       //: CharIndex:AVAILABLE ://
                ri =(   0   );       //: CharIndex:REQUIRED  ://
                while(  1  ){
                    if( a_n[ ai ] != r_n[ ri ] ){ sm-- ; };
                    if( 0 == a_n[ ai ] ){ break; };
                    if( 0 == r_n[ ri ] ){ break; };
                    ai++;
                    ri++;
                };;
            
                if( sm >= 1 ){ break; }; 
            };;
                if( sm <= 0 ){
                    P_F( "[sm]:%d\n"           , sm );
                    P_F( "[Missing_RIE]:%s\n" , r_n );
                    P_F( "[a_n]:%s\n"         , a_n );
                    ERR( "[RIE_Not_Found]"          );
                };;
            };;

        }
        #undef  NUM_AIE 
        #undef  ARR_AIE 
        }
        #undef  NUM_RIE 
        #undef  ARR_RIE 
        }
        //:----------------------------------------:VIDEO_012://
        //+==================================================+//
        //|INSTANCE_CREATION:THEN:WINDOW_SURFACE:============|//
        //|-- - - - - - - - - - - -- - - - - - - - - - - - --|//
        //:SECTION_VIDEO_URL[ xxxxxxxxxxxxxxxxxxxxxxxxxxxxx ]://
        //:SECTION_VIDEO_NUM[ VIDEO_019                     ]://

                //:INSTANCE_CREATION:------------------------://
                #define A_I  mcv_d_applicationinfo
                #define C_I  mcv_d_c_instance
                
                    //:VkApplicationInfo://
                
                        A_I.typ     =(I32 )( 0 )           ;
                        A_I.nex     =(VOD*)( 0 )           ;
                        A_I.app_nam = "[Hello Triangle]"   ;
                        A_I.app_ver = mcv_f_vmv(   1, 0, 0);
                        A_I.eng_nam = "[No Engine]"        ;
                        A_I.eng_ver = mcv_f_vmv(   1, 0, 0);
                        A_I.api_ver = mcv_f_mav(0, 1, 2, 0);
                
                    //:VkInstanceCreateInfo:://
                    
                        C_I.typ     = ((I32 )(  1  )) ;
                        C_I.nex     = ((VOD*)(  0  )) ;
                        C_I.a_i     =&( A_I )         ;  
                        C_I.ext_num = mcv_m_n_rie     ;  
                        C_I.ext_arr = mcv_d_a_rie     ;  
                        C_I.lay_num       = 0         ;  
                        C_I.lay_arr =((VOD*)0)        ;  
                    
                    //:VkCreateInstance:://
                
                        res = mcv_f_vkcreateinstance(
                            &( mcv_d_c_instance )
                        ,    (       0          )    //:@A_C@://          
                        ,   &( mcv_d_o_instance )
                        );;
                        CHK( res , "[Instance_Create]" );
                
                #undef  A_I
                #undef  C_I
                //:------------------------:INSTANCE_CREATION://
                //:WINDOW_SURFACE:---------------------------://
                #define FUN mcv_f_vkcreatewin32surfacekhr
                #define V_I mcv_d_o_instance   //:Vulkan_Inst://
                #define C_I mcv_d_c_sur        //:Create_Info://
                #define C_B ((VOD*)0)          //:A_Call_Back://
                #define OBJ mcv_d_o_sur        //:Output_Obj ://
                
                    //: C_I : vkwin32surfacecreateinfokhr    ://
                    //: TYP : WIN32_SURFACE_CREATE_INFO_KHR  ://

                        C_I  .  typ = ((I32 )( 1000009000  )) ; 
                        C_I  .  nex = ((VOD*)(      0      )) ;  
                        C_I  .  c_f = ((U32 )(      0      )) ;  
                        C_I  .  exe = ((VOD*)(  mcv_d_exe  )) ;
                        C_I  .  win = ((VOD*)(  mcv_d_win  )) ;

                    //: OBJ : VkSurfaceKHR ( void* )         ://

                        res = FUN( V_I , &(C_I) , C_B , &(OBJ));
                        CHK( res , "[WINDOW_SURFACE]" );
                        
                #undef  FUN
                #undef  V_I
                #undef  C_I
                #undef  C_B
                #undef  OBJ
                //:---------------------------:WINDOW_SURFACE://

        
        //|-- - - - - - - - - - - -- - - - - - - - - - - - --|//
        //|============:INSTANCE_CREATION:THEN:WINDOW_SURFACE|//
        //+==================================================+//
        //:VIDEO_013:----------------------------------------://
        //:vkEnumeratePhysicalDevices:-----------------------://

            #define INS mcv_d_o_instance      //:[ vul_ins  ]://
            #define NUM mcv_d_n_phy_dev       //:[ number of]://
            #define ARR mcv_d_a_phy_dev       //:[ array  of]://
            #define CAP mcv_m_c_phy_dev       //:[ capacity ]://
        
                //:Get number of physical devices :

                    res = mcv_f_epd( INS , &NUM , NIL );
                    CHK( res , "[Enum_Phy_Dev:001]" );
                    if( NUM > CAP ){ ERR("[2MANY_PHY_DEV]"); };

                //:Load physical devices into array :

                    res = mcv_f_epd( INS , &NUM , ARR );
                    CHK( res , "[Enum_Phy_Dev:002]" );

                //:Smoke Test : Print Number Of[ phy_dev ]:

                    P_F( "[num_phy_dev]:%d\n" , NUM );

            #undef  INS  //:---------------------------------://
            #undef  NUM  //:---------------------------------://
            #undef  ARR  //:---------------------------------://
            #undef  CAP  //:---------------------------------://

        //:-----------------------:vkEnumeratePhysicalDevices://
        //:----------------------------------------:VIDEO_013://
       
//:MCV_F_INI:GET_PHYSICAL_DEVICE:############################://
//:                                                          ://
//:     VIDEO_020:GET_PHYSICAL_DEVICE:                       ://
//:     This stuff got a bit more complex than I expected.   ://
//:     we need more column space, so just un-indent here.   ://
//:                                                          ://
//:     TAG[isdevicesuitable]TAG[isDeviceSuitable]           ://
//:                                                          ://
//:MCV_F_INI:GET_PHYSICAL_DEVICE:::::::::::::::::::::::::::::://
#define     N_C mcv_f_n_c           //:------------:NillCheck://
                                    //:----------------:-----://
#define GET_QFP mcv_f_g_qfp                          //:-----://
#define GET_D_P mcv_f_vkgetphysicaldeviceproperties  //:-----://
#define GET_D_F mcv_f_vkgetphysicaldevicefeatures    //:-----://
#define GET_SSK mcv_f_g_phy_ssk     //:---------:GET_SSK     ://
                                    //:                      ://
#define     P_A mcv_d_a_phy_dev     //:---------:PHY_ARR     ://
#define     P_N mcv_d_n_phy_dev     //:---------:PHY_NUM     ://
#define     P_D mcv_d_o_phy_dev     //:---------:PHY_DEV     ://
                                    //:                      :// 
#define     Q_A mcv_d_a_qfp         //:---------:QFP_ARR     ://
#define     Q_N mcv_d_n_qfp         //:---------:QFP_NUM     ://
#define     Q_C mcv_m_c_qfp         //:---------:QFP_CAP     ://
                                    //:                      ://
#define     I_C mcv_d_i_qfp_com     //:---------:QFI:COMPUTE ://
#define     I_G mcv_d_i_qfp_gra     //:---------:QFI:GRAPHICS://
#define     I_P mcv_d_i_qfp_pre     //:---------:QFI:PRESENT ://
                                    //:                      ://                
#define     SUR mcv_d_o_sur         //:---------:VkSurfaceKHR://
{

    I32     o_k =(    0    ); //: Undefined State.           ://
    I32 dev_pik =(    1    ); //: picking_a_physical_device ?://
    I32 dev_dex =(   0-1   ); //: current device index       :// 
    I32 dev_m_i =( P_N - 1 ); //: max device dex             ://

    if( P_N <= 0 ){ ERR("[NO_PHYSICAL_DEVICES]"); };

    while( dev_pik /**picking_a_physical_device**/ >= 1 ){

        //:What Device Are We Looking At Now?

            dev_dex++; if( dev_dex > dev_m_i ){

                ERR("[CANT_FIND_SUITABLE_PHYSICAL_DEVICE]");
            };;

        //:Reset Our Okay Status To Innocent/NoProblem/Positive:
    
            o_k =( 0+1 );

        //:Reset Criteria We Want:
        
            I_C = I_G = I_P = ( 0 - dev_dex - 1000 );//:#CGP#://

            ASS( I_C < 0 , "[I_C<0]" );   P_F("[I_C]:%d\n",I_C);
            ASS( I_G < 0 , "[I_G<0]" );   P_F("[I_G]:%d\n",I_G);
            ASS( I_P < 0 , "[I_P<0]" );   P_F("[I_P]:%d\n",I_P);
            
        //:VIDEO_014:----------------------------------------://
        //:1: vkGetPhysicalDeviceProperties
        //:2: vkGetPhysicalDeviceFeatures
        {
            struct mcv_t_vkphysicaldeviceproperties d_p ={ 0 };
            struct mcv_t_vkphysicaldevicefeatures   d_f ={ 0 };
        
            I32 y =( 0 ); //:Y:YES:Has feature.
            I32 n =( 0 ); //:N:NO :Missing Feature.
        
            P_D = P_A[    dev_dex   ];  N_C( P_D , "[P_D:014]");
            GET_D_P( P_D , &( d_p ) );     
            GET_D_F( P_D , &( d_f ) );     
    
            //:Todo: Make choice based on[ d_p ]&[ d_f ]

                //: ...0101010101010101010... ://
    
            //:Something Something Device PROPERTIES:
    
                //:No Logic Here Yet.://
    
            //:Gather Number Of Active Device FEATURES:
    
                for( I32 f = 0 ; f <=(55-1) ; f++ ){
    
                    if( 1 == d_f.data[ f ] ){ y++ ; }else
                    if( 0 == d_f.data[ f ] ){ n++ ; }else
                    {
                        ERR("[EXP:1_OR_ZERO]");
                    };; 
                };;
    
            //: Is device suitable? (isDeviceSuitable):      ://
            //: We no longer know, as we have further        ://
            //: criteria to evaluate.                        ://

                if( ( y > n ) ){ P_F("[NICE_DEVICE!]\n"); };;

                P_F( "\n"                                   );
                P_F( "[yes_features]:%d\n", y               );
                P_F( "[not_features]:%d\n", n               );
                P_F( "\n"                                   );
                mcv_f_p_vkphysicaldeviceproperties( &(d_p)  );
                P_F( "\n"                                   );
        }
        if( NIL == P_D ){ ERR("[NIL_PHYSICAL_DEVICE]"); };
        //:----------------------------------------:VIDEO_014://
        //:VIDEO_015:( KanjiCoder_IID_0338 ):----------------://
        
            GET_QFP( P_D , &Q_N ,  ( NIL  ) );
            if(  Q_N >  Q_C                 ){ ERR( "[001]" );};
            GET_QFP( P_D , &Q_N , &(Q_A[0]) );
        
            P_F( "[Number_Of_QFP:Q_N]:%d\n\n" , Q_N );
            
            for( I32 qfi = 0 ; qfi <=( Q_N-1 ) ; qfi++ ){

                U32 QFI = ((U32)qfi);
                U32 yes=( 0 ); /** supported? **/

                res = GET_SSK( P_D , QFI , SUR , &yes );
                CHK( res , "[G_S:GET_SSK]" );
        
                //: #NODEBUG0YES#( 0  ==  yes ) - - - - - - -://
                if( Q_A[qfi].q_f & 0x00000002 ){ I_C =(qfi); };
                if( Q_A[qfi].q_f & 0x00000001 ){ I_G =(qfi); };
                if(                1  ==  yes ){ I_P =(qfi); };

                P_F( "\n" );
            };;

            if( I_C >= 0 && I_G >= 0 && I_P >= 0 ){ 
                //:Device Is Still Suitable.
                //:Do nothing.
            }else{
                o_k=( 0-1 ); //:UnsuitableDevice
            };;
        
        //:----------------------------------------:VIDEO_015://
        //:VIDEO_###:DeviceExtensionSupport:-----------------://
        #define FUN mcv_f_vkenumeratedeviceextensionproperties
        #define   P mcv_d_o_phy_dev
        #define   _ NIL
        #define   N mcv_d_n_ade
        #define   A mcv_d_a_ade
        #define   C mcv_m_c_ade

            if( o_k >= 1 ){

                SAY( "\n[DeviceExtensionSupport:CHK:...]\n\n" );

                          N=( 0 ); //:Reset_From_Prev_Loop://
                ASS(     &N != NIL , "[AND_N_NIL]" );
                FUN( P,_,&N, _ ); 
                if(  N>=C ){ 
                    P_F( "\n"               );
                    P_F( "[N:ade]:%d\n" , N );
                    P_F( "[C:ade]:%d\n" , C );
                    P_F( "\n"               );
                };;
                ASS( N<=C,"[011]");
                FUN( P,_,&N,(A));

                //:Paired Array Checklist:
                I32      chk_A[ mcv_m_n_rde ]={ 0 };
                I32      chk_N =mcv_m_n_rde ;
                #define  chk_C [NO_CAPACITY_SIZE_KNOWN]
                #undef   chk_C
                CHR*     rde =(NIL); //:Current:@RDE@://
                VEP  ent_ade ={ 0 }; //:Current:@ADE@://
                CHR*     ade =(NIL); //:Current:@ADE@://

                //:[r]:Loop over all required extensions:
                //:[a]:Check Against All Available Extensions:
                for( I32 r = 0 ; r <=(chk_N-1) ; r++ ){
                for( I32 a = 0 ; a <=(    N-1) ; a++ ){

                        rde = mcv_d_a_rde[ r ];//:mcv_d_a_rde://
                    ent_ade =           A[ a ];//:-----------://
                        ade = ent_ade.ext_nam ;//:mcv_d_a_ade://

                    if( 0==strcmp(ade,rde) ){ chk_A[ r ]=(1); };
                    if( 1==chk_A[ r ] ){ break; };
                };;};;
                for( I32 r = 0 ; r <=(chk_N-1) ; r++ ){

                    if( 1 != chk_A[ r ] ){ o_k =( 0-1); };
                    if( 1 != chk_A[ r ] ){ break;       };
                };;
            };;
            if( o_k >= 1 ){

                dev_pik=( 0 ); //:No_Longer_Searching://

                P_F( "[mcv_d_i_qfp_com]:%d\n" , I_C );
                P_F( "[mcv_d_i_qfp_gra]:%d\n" , I_G );
                P_F( "[mcv_d_i_qfp_pre]:%d\n" , I_P );
            };;

        #undef FUN  //:--------------------------------------://
        #undef   P  //:--------------------------------------://
        #undef   _  //:--------------------------------------://
        #undef   N  //:--------------------------------------://
        #undef   A  //:--------------------------------------://
        #undef   C  //:--------------------------------------://
        //:VIDEO_###:DeviceExtensionSupport:-----------------://

    };; //:<<<<<<<<<<<<<<< dev_pik:picking_a_physical_device ://

    if( dev_pik >= 1 ){
        /** Catches problems with above loop. **/
        ERR("[SHOULD_HAVE_CAUGHT_FAIL_EARLIER!]\n");
    }else{
        P_F("[DEVICE_WAS_PICKED]\n");
    };;

}
#undef      N_C  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef  GET_QFP  //:-----------------------------------------://
#undef  GET_D_P  //:-----------------------------------------://
#undef  GET_D_F  //:-----------------------------------------://
#undef  GET_SSK  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef      P_A  //:-----------------------------------------://
#undef      P_N  //:-----------------------------------------://
#undef      P_D  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef      Q_A  //:-----------------------------------------://
#undef      Q_N  //:-----------------------------------------://
#undef      Q_C  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef      I_G  //:-----------------------------------------://
#undef      I_C  //:-----------------------------------------://
#undef      I_P  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef      SUR  //:-----------------------------------------://
//::::::::::::::::::::::::::::::MCV_F_INI:GET_PHYSICAL_DEVICE://
//:                                                          ://
//:     Physical device should have the ability of:          ://
//:     1. Graphics : USE: ( q_f & 0x00000001 )              ://
//:     2. Compute  : USE: ( q_f & 0x00000002 )              ://
//:     3. Present                                           ://
//:             USE: vkGetPhysicalDeviceSurfaceSupportKHR(   ://
//:                   device, i, surface, &presentSupport);  ://
//:                                                          ://
//:############################:MCV_F_INI:GET_PHYSICAL_DEVICE://
//:MCF_F_INI:CREATE_LOGICAL_DEVICE:##########################://
//:MCV_F_INI:createLogicalDevice:############################://
//:                                                          ://
//:  VIDEO_021 :                                             ://
//:         1. Create Logical Device                         ://
//:         2. Get The Different Queues                      ://
//:                                                          ://
//:MCF_F_INI:CREATE_LOGICAL_DEVICE:::::::::::::::::::::::::::://
//:MCV_F_INI:createLogicalDevice:::::::::::::::::::::::::::::://

    //:VIDEO_021:STEP_001:-----------------------------------://
    //:Create_Set_Of_Unique_Queue_Families:------------------://
    #define ARR mcv_d_a_qfi      /** Unique Set   As Array   **/
    #define CAP mcv_m_c_qfi      /** Capacity     Of Array   **/
    #define NUM mcv_d_n_qfi      /** Final Length Of Array   **/
    {
        //:Hackish Array "Zero Out" :

            ASS( 0 == NUM , "[ZER_NUM]" );
            ASS( 3 == CAP , "[CAP_NUM]" );

            for( I32 hak = 0 ; hak <=( CAP-1 ) ; hak++ ){
                //:Zero is value value, so set to highest
                //:possible value and pray never used.
                ARR[ hak ]=( 0x7FFFFFFF );
            };;
            ASS( ARR[ 0 ] == 0x7FFFFFFF , "[ARR_000]" );;
            ASS( ARR[ 1 ] == 0x7FFFFFFF , "[ARR_001]" );;
            ASS( ARR[ 2 ] == 0x7FFFFFFF , "[ARR_002]" );;

        //:Variables To Work With:

            I32     out ;
            I32     m_i ;
            I32     qfi =( 0-666 ); //:Cur[ QFI ]To_Add_To_Set
            I32     has =( 0-444 ); //:Already_Has[ QFI ]In_SET
            U32 chk_bit =(   0   ); //:Double_Check:Set
            U32 chk_num =(   0   ); //:Double_Check:Number/Count
            U32 chk_dex =(   0   ); //:Double_check:INDEX
        
        //:Creating The Set:
        for( I32 cur = 0 ; cur <= (CAP-1) ; cur++ ){

            //: Filter down these[ qfi ]to[ set/unique ]

                if( 0 == cur ){ qfi = mcv_d_i_qfp_com ; }else
                if( 1 == cur ){ qfi = mcv_d_i_qfp_gra ; }else
                if( 2 == cur ){ qfi = mcv_d_i_qfp_pre ; }else{
                    ERR("[CUR_OOB]");
                };;

            //: Bit flag debugging logic wont work if we have
            //: queue indexes (qfi) above 31 because U32 bits.

                ASS( qfi >= 0 || qfi <= 31 , "[QFI_BOUNDS]" );

            //:Was[ qfi ]found within our set[ ARR/mcv_d_a_qfi ]

                has=( 0 );
                out=( 0 );
                m_i=(   ((I32)NUM) - 1 );
                for( out = 0 ; out <= m_i ; out++ ){
                
                    if( out > (CAP-1) ){ 
                        P_F("[OUT+0]:%d \n" , out   );
                        P_F("[CAP-1]:%d \n" , CAP-1 );
                        P_F("[NUM-1]:%d \n" , NUM-1 );
                        P_F("[m_i+0]:%d \n" , m_i   );
                        ERR("[OOB:OUT]");
                    };;

                    if( ((U32)(qfi)) == ARR[ out ] ){
                        has =( 1 ); 
                        break;
                    };;
                };;

            //:Add to set if not already in the set:

                if( 0 == has ){
                    NUM++ ; if( NUM > CAP ){ ERR("[002]"); };
                    ARR[ NUM-1 ]=( qfi );
                    chk_bit =( chk_bit | ( 1 << qfi ) );

                    P_F("[SET_ADD:QFI] \n");
                }else{
                    P_F("[set_has:qfi] \n");
                };;
        };;

        //:Checking Our Logic:
        for( chk_dex = 0 ; chk_dex <=(32-1) ; chk_dex ++ ){

            if( 0 != ((1<<chk_dex)&(chk_bit)) ){ chk_num++; };
        };;
        if( chk_num != NUM ){
            P_F( "[chk_bit]:%0x \n" , chk_bit );
            P_F( "[chk_num]%d   \n" , chk_num );
            P_F( "[::::NUM]%d   \n" ,     NUM );
            ERR("[SET_DOUBLE_CHECK_FAIL]");
        };;

        //: Smoke Test To Make Sure We Didn't Confuse These:
        //:           qfp  !=            qfi
        //: &(mcv_d_a_qfp) !=  &(mcv_d_a_qfi)
        //: &(mcv_m_c_qfp) !=  &(mcv_m_c_qfi)
        //: &(mcv_d_n_qfp) !=  &(mcv_d_n_qfi)
        #define E ERR

            VOD* a_1 = &(mcv_d_a_qfi[0]) ;
            VOD* a_2 = &(mcv_d_a_qfp[0]) ;
            
            if(          a_1     ==         a_2    ){E("[5]");};
            if(  mcv_m_c_qfi     >  mcv_m_c_qfp    ){E("[6]");};
            if(  mcv_d_n_qfi     >  mcv_d_n_qfp    ){E("[7]");};
            if(  mcv_d_n_qfi     <=           0    ){E("[8]");};
            if(  mcv_d_n_qfp     <=           0    ){E("[9]");};
            
        #undef  E
    }
    #undef  ARR  //:-----------------------------------------://
    #undef  CAP  //:-----------------------------------------://
    #undef  NUM  //:-----------------------------------------://
    //:------------------:Create_Set_Of_Unique_Queue_Families://
    //:-----------------------------------:VIDEO_021:STEP_001://
    //:VIDEO_021:STEP_002:-----------------------------------://
    #define QFI_ARR mcv_d_a_qfi /** Unique Set   As Array   **/
    #define QFI_NUM mcv_d_n_qfi /** Final Length Of Array   **/
    #define QFI_CAP mcv_m_c_qfi /** Capacity     Of Array   **/

                                //: QCI : Queue_Create_Info  ://
    #define QCI_ARR mcv_d_a_qci /** QCI : ARRAY   **/
    #define QCI_NUM mcv_d_n_qci /** QCI : NUMBER  **/
    #define QCI_CAP mcv_m_c_qci /** QCI : Capacity**/

    #define QCI     struct mcv_t_vkdevicequeuecreateinfo 
    {

        //: We make one[ QCI ]per[ QFI ]in our set:

            QCI_NUM = QFI_NUM ;
    
        //:QCI_NUM & QFI_NUM printout because errors:

            P_F("\n\n");

            if( QCI_NUM <=  0 ){
                P_F( "[QCI_NUM]:%d <<[BAD_QCI]\n" , QCI_NUM );
            };;
            if( QFI_NUM <=  0 ){
                P_F( "[QFI_NUM]:%d <<[BAD_QFI]\n" , QFI_NUM );
            };;

            if( QCI_NUM >   0 ){
                P_F( "[QCI_NUM]:%d <<[OK]     \n" , QCI_NUM );
            };;
            if( QFI_NUM >   0 ){
                P_F( "[QFI_NUM]:%d <<[OK]     \n" , QFI_NUM );
            };;

            P_F("\n\n");

        //:"Allocate" number of elements:

            S_A( QCI_CAP == QFI_CAP , "[QFI_CAP:QFI_CAP]" );

            ASS( QCI_NUM > 0 , "[QCI_NUM>0]" );
            ASS( QFI_NUM > 0 , "[QFI_NUM>0]" );

            I32  dex;     //: qfi index. Not the qfi itself. ://
            U32  qfi;     //: qfi = ARR[ not_qfi ]           ://
            QCI* qci;     //: selected QueueCreateInfo struct://

        //:Populate:

            //: I hate assymetry and arbitrary choice.
            //: calculate max valid index ( m_i ) this way.
            I32  m_i =(( QFI_NUM | QCI_NUM )-1   );
            ASS( m_i ==( QFI_NUM - 1 ) , "[008]" );
            ASS( m_i ==( QCI_NUM - 1 ) , "[009]" );

            //: Populate Our Structs:
            #define  q_f [USE:c_f:(Create_Flags!Queue_Flags)]

            for( dex = 0 ; dex <= m_i ; dex++ ){
           
                qfi =   QFI_ARR[ dex ]  ; //:QueueFamilyIndex://
                qci =&( QCI_ARR[ dex ] ); //:QueueCreateInfo ://

                qci  ->  typ = (        2  ); //:    sType   ://
                qci  ->  nex = (       NIL ); //:    NO_PNEXT://
                qci  ->  c_f = ( (U32)( 0 )); //:  #_QCI_F0_#://
                qci  ->  fam = (       qfi ); //:Q_Family_Dex://
                qci  ->  num = (        1  ); //:Only 1 Queue://
                qci  ->  q_p =&( mcv_d_q_p ); //:  Q_Priority://
            };;

            #undef  q_f
    }
    #undef  QFI_ARR  //:-------------------------------------://
    #undef  QFI_NUM  //:-------------------------------------://
    #undef  QFI_CAP  //:-------------------------------------://
                     //:-------------------------------------://
    #undef  QCI_ARR  //:-------------------------------------://
    #undef  QCI_NUM  //:-------------------------------------://
    #undef  QCI_CAP  //:-------------------------------------://
                     //:-------------------------------------://
    #undef  QCI      //:-------------------------------------://
    //:-----------------------------------:VIDEO_021:STEP_002://
    //:VIDEO_021:STEP_003:MODIFY_QCI_ARR:--------------------://

        //:VIDEO_016:----------------------------------------://
        #define QCI struct mcv_t_vkdevicequeuecreateinfo
        #define D_V struct mcv_t_vkphysicaldevicefeatures
        #define DCI struct mcv_t_vkdevicecreateinfo
        #define C_D mcv_f_vkcreatedevice
        #define PHY mcv_d_o_phy_dev
        #define LOG mcv_d_log_dev

            //:QCI: Queue Create Info ( queueCreateInfo ) ://

                U32  qci_num = ((U32)( mcv_d_n_qci     ));
                QCI* qci_arr =&(     ( mcv_d_a_qci[ 0 ]));
                
            //:D_V: Specifiy[ deviceFeatures ]we will be using:

                D_V d_v = { 0 }; //:REQUESTING_NO_FEATURES://
                //: d_v <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< d_v = &( d_f ) maybe from previous device selection that got what device features we had?

            //:DCI: Device Create Info:

                DCI dci     ={ 0 };

                dci.typ     =( 3 /**Device_Create_Info==3**/);
                dci.nex     =(  NIL  );
                dci.c_f     =((U32)0 );

                dci.qci_num =(qci_num);  //:Q_CreateInfoCount://
                dci.qci_arr =(qci_arr);  //:p_Q_CreateInfos  ://

                dci.lay_num =(   0   );
                dci.lay_arr =(   0   );

                //:#_ENABLING_DEVICE_EXTENSIONS_#://
                dci.ext_num =( mcv_m_n_rde );
                dci.ext_arr =( mcv_d_a_rde );

                dci.fet     = &( d_v );  //:pEnabledFeatures ://

            //: vkCreateDevice

                res = C_D(  PHY, &dci, NIL, &LOG  );
                CHK( res , "[C_D:vkCreateDevice]" );

        #undef  QCI
        #undef  D_V
        #undef  DCI
        #undef  C_D
        #undef  PHY
        #undef  LOG
        //:----------------------------------------:VIDEO_016://

    //:--------------------:VIDEO_021:STEP_003:MODIFY_QCI_ARR://
    //:VIDEO_021:STEP_004:GET_DEVICE_QUEUES:-----------------://
    #define GET_D_Q mcv_f_vkgetdevicequeue
    #define     LOG mcv_d_log_dev

        ASS( NIL == mcv_d_q_com , "[HAS:mcv_d_q_com]" );
        ASS( NIL == mcv_d_q_gra , "[HAS:mcv_d_q_gra]" );
        ASS( NIL == mcv_d_q_pre , "[HAS:mcv_d_q_pre]" );

        //#  #_QCI_F0_# : VkDeviceQueueCreateInfo.q_f === 0  #//
        
        GET_D_Q( LOG , mcv_d_i_qfp_com , 0 , &( mcv_d_q_com ) );
        GET_D_Q( LOG , mcv_d_i_qfp_gra , 0 , &( mcv_d_q_gra ) );
        GET_D_Q( LOG , mcv_d_i_qfp_pre , 0 , &( mcv_d_q_pre ) );

        ASS( NIL != mcv_d_q_com , "[NIL:mcv_d_q_com]" );
        ASS( NIL != mcv_d_q_gra , "[NIL:mcv_d_q_gra]" );
        ASS( NIL != mcv_d_q_pre , "[NIL:mcv_d_q_pre]" );

        printf( "\n\n" );
        printf( "[ADDR:mcv_d_q_com]:%0x \n", mcv_d_q_com );
        printf( "[ADDR:mcv_d_q_gra]:%0x \n", mcv_d_q_gra );
        printf( "[ADDR:mcv_d_q_pre]:%0x \n", mcv_d_q_pre );
        printf( "\n\n" );

    #undef  GET_D_Q
    #undef      LOG
    //:-----------------:VIDEO_021:STEP_004:GET_DEVICE_QUEUES://

//:############################:MCV_F_INI:createLogicalDevice://
//:##########################:MCF_F_INI:CREATE_LOGICAL_DEVICE://

        SAY( "[EXITING:MCV_F_INI]" );

    } //:<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<[ MCV_F_INI ]://

    PUBLIC_FUNCTION 

        VOD MCV_F_TIK( VOD ){

            /** Tick Function. Once Per Frame. **/

            #define u32    mcv_d_lib_u32
            #define P_M u32.PeekMessageW
            #define MSG struct mcv_t_msg  
            #define WIN        mcv_d_win 
            #define REM        (U32)0x0001 /** PM_REMOVE **/

                //: Exit Once Drained. DON'T use      ://
                //: "GetMessage" because "GetMessage" ://
                //: will block.                       ://

                MSG msg = { 0 };
                while( P_M( &msg , WIN , 0 , 0 , REM ) > 0){

                    u32.TranslateMessage( &msg );
                    u32.DispatchMessageW( &msg );
                };;
     
            #undef  u32
            #undef  P_M
            #undef  MSG
            #undef  WIN
            #undef  REM
        }

    PUBLIC_FUNCTION  

        I32 MCV_F_DEM( VOD ){ 

            /** MCV_F_DEM == Library_Demonstration **/

            MCV_F_INI( ); 
            F_F( stdout );

            while( mcv_d_kot >= 1 ){

                MCV_F_TIK();
        
            };;
            P_F( "\n\n[Outside_Of_Window_Loop]\n\n\n" );

            return( 0 );
        }

//:================================================:FUNCTIONS://
//:FILE_MACROS:==============================================://

//: MISC_FILE_MACROS ://

    #undef PUBLIC_FUNCTION
    #undef PRIVATE_FUNCTION

//: MONKEY_WRENCH_MACROS ://

    #undef num_qci  
    #undef arr_qci  
                    
    #undef num_lay  
    #undef arr_lay  
                    
    #undef num_ext  
    #undef arr_ext  

    #undef mcv_f_dll_all
    #undef QFC_NUM

//: Basic_File_Macros ://
                    
    #undef  ECI
    #undef  NIL  
    #undef  VOD  
    #undef  DLL  
    #undef  U08
    #undef  U16
    #undef  I32  
    #undef  U32 
    #undef  U64
    #undef  I64
    #undef  F32
    #undef  CHR 
    #undef  UNI
    #undef  NCC
    #undef  ERR  
    #undef  SAY  
    #undef  CHK  
    #undef  ASS
    #undef  RES   
    #undef  GI3 
    #undef  G00
    #undef  P_F
    #undef  F_F
    #undef  S_A
    #undef  S_O
    #undef  SIZ 

//: Vulkan_Macros_To_Keep_Stuff_Terse ://

    #undef  VEP  //: <-- TODO: REMOVE THESE... TOO SPECIFIC FOR ENTIRE FILE SCOPE
    #undef  PDL  //: <-- TODO: REMOVE THESE... TOO SPECIFIC FOR ENTIRE FILE SCOPE
    #undef  DSP  //: <-- TODO: REMOVE THESE... TOO SPECIFIC FOR ENTIRE FILE SCOPE

//:==============================================:FILE_MACROS://
//::SHORTHAND_COMMENTS:======================================://
/** SHORTHAND_COMMENTS ************************************* ***

    @ MWM @ : Monkey Wrench Macro
    @ KOT @ : Keep_On_Ticking
    @ A_C @ : Allocation_Callbacks
    @ VIL @ : Vestigial "i" Loop (Loop Can Be Removed From Code)
    @ NDP @ : NIL_DOUBLE_POINTER
    @ AMS @ : Avoid_Memory_Stomping
    @ RDE @ : Required__Device_Extension (Name/String)
    @ ADE @ : Available_Device_Extension (Name/String)
    @ NNP @ : Nill_Number_Pointer

    @ men @ : Max_Extension_Name
    @ mpd @ : Max_PhyDev_Name   
    @ uid @ : VK_UUID_SIZE      


*** ************************************* SHORTHAND_COMMENTS **/
//:======================================:SHORTHAND_COMMENTS:://
//::LONGHAND_COMMENTS:=======================================://
/** LONGHAND_COMMENTS ************************************** ***

    #_DO_NOT_POPULATE_FPS_USING_HELPER_FUNCTIONS_#

        Do not use helper function to populate function
        pointer structs for different DLL files.
        Reasoning: Creates spaghetti code. Do not create
        helper functions that are only called once.
        Makes it harder to understand the linear narrative
        when reading code from top to bottom.

    #_CREATE_WINDOW_BEFORE_ALL_VULKAN_CODE_#

        :::VIDEO_18:Win32_Window_002:------------------------:::
        :::                                                  :::
        :::     Window Creation Added Before All Vulkan      :::
        :::     Init because SOME (not all) vulkan code      :::
        :::     depends on Win32 window existing.            :::
        :::                                                  :::
        :::     SPECIFICALLY:                                :::
        :::                                                  :::
        :::     VkSurfaceKHR                                 :::
        :::                                                  :::
        :::     ALSO:                                        :::
        :::                                                  :::
        :::     The window surface needs to be created       :::
        :::     right after the instance creation, because   :::
        :::     it can  actually influence the physical      :::
        :::     device selection. The reason we postponed    :::
        :::     this is because window surfaces are part     :::
        :::     of the larger topic of render targets        :::
        :::     and presentation for which the explanation   :::
        :::     would have cluttered the basic setup.        :::
        :::                                                  :::
        :::VIDEO_18:Win32_Window_002:- - - - - ---- - - - - -:::

    #NODEBUG0YES#

        I was trying to figure out why setting ( 0 == yes )
        was _NOT_ causing a failure to pick physical device.
        The reason was because that just inverted the
        queue family for PRESENT capability. It didn't cause
        a present queue to not be found. DATE[2021_11_14]

    #CGP#

        Compute
        Graphics
        Present

        Keep these queue types in alphabetical order to
        avoid arbitraryness in our code.

    #_queueIndex_ZERO_ALWAYS_#

        When using vkGetDeviceQueue , the queueIndex property
        is always zero because in this library we only make
        one queue of any given [type/ability].

        1 compute  queue
        1 graphics queue
        1 present  queue
        
        Thus sub index for queue is always zero.

    #_064_QFI_#
    
        A QFI over 64 is probably wrong. But it might not
        be if graphics card actually has more than 64
        queues. I just find it highly unlikely.

        Remove this error if graphics cards start to support
        higher numbers.

    #_QCI_F0_#

        //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//
        //# vkGetDeviceQueue must only be used to get  #//
        //# queues that were created with the flags    #//
        //# parameter of VkDeviceQueueCreateInfo set   #//
        //# to zero. To get queues  that were created  #//
        //# with a non-zero flags parameter use        #//
        //# vkGetDeviceQueue2.                         #//
        //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//

    #_HOW_DID_I_DECIDE_ON_RIE_#

        /// ******************************************** ///                                 
        /// www.khronos.org/registry/vulkan/specs/       ///
        /// 1.2-khr-extensions/html/chap47.html          ///
        ///                                              ///
        /// Also: Cross Checked: GLFW Library            ///
        /// glfwGetRequiredInstanceExtensions            ///
        /// _glfwPlatformGetRequiredInstanceExtensions   ///
        /// ******************************************** ///
        //: "VK_KHR_external_memory_win32"  
        //: "VK_KHR_win32_keyed_mutex"  
        //: "VK_KHR_external_semaphore_win32"  
        //: "VK_KHR_external_fence_win32" 

    #_ENABLING_DEVICE_EXTENSIONS_#

        Enabling device extensions
        Using a swapchain requires enabling the 
        VK_KHR_swapchain extension first. Enabling the 
        extension just requires a small change to the  
        logical device creation structure:

        createInfo.enabledExtensionCount = 
            static_cast<uint32_t>(deviceExtensions.size());
        createInfo.ppEnabledExtensionNames = 
            deviceExtensions.data();

        Make sure to replace the existing line
        createInfo.enabledExtensionCount = 0; 
        when you do so.

        https://vulkan-tutorial.com/.../Swap_chain



*** ************************************** LONGHAND_COMMENTS **/
//:=======================================:LONGHAND_COMMENTS:://
//::HELP_FINDING_THINGS:=====================================://
/** ******************************************************** ***

    computeFamily  | computeFamilyIndex
    mcv_d_i_qfp_com
    PASTE_LINE

    graphicsFamily | grapicsFamilyIndex
    mcv_d_i_qfp_gra
    PASTE_LINE

    presentFamily | presentFamilyIndex    
    mcv_d_i_qfp_pre
    PASTE_LINE
    
    ------------------------------------------------------------

    mcv_d_i_qfi_com | mcv_d_i_com | mcv_qfi_com | qfi_com
    mcv_d_i_qfp_com
    PASTE_LINE

    mcv_d_i_qfi_gra | mcv_d_i_gra | mcv_qfi_gra | qfi_gra
    mcv_d_i_qfp_gra
    PASTE_LINE

    mcv_d_i_qfi_pre | mcv_d_i_pre | mcv_qfi_pre | qfi_pre
    mcv_d_i_qfp_pre
    PASTE_LINE

    ------------------------------------------------------------

    VkQueueCreateInfo | QueueCreateInfo
    YOU_MEAN[ VkDeviceQueueCreateInfo ]
    PASTE_LINE

    mcv_t_vkqueuecreateinfo
    YOU_MEAN[ mcv_t_vkdevicequeuecreateinfo ]
    PASTE_LINE
    
    mcv_d_ade_arr | mcv_data_available_device_extension_array
    USE[ mcv_d_a_ade ]
    PASTE_LINE

    mcv_d_ade_num | mcv_data_available_device_extension_count
    USE[ mcv_d_n_ade ]
    PASTE_LINE

    mcv_d_ade_cap | mcv_data_available_device_extension_capacity
    USE[ mcv_m_c_ade ]
    PASTE_LINE

*** ******************************************************** **/
//:=====================================:HELP_FINDING_THINGS:://
//:YOU_CANT_TYPE_WORTH_SHIT:=================================://
/** ******************************************************** ***

    mcv_f_enumeratedeviceextensionproperties
    YOU_MEAN[ mcv_f_vkenumeratedeviceextensionproperties ]
    PASTE_LINE

*** ******************************************************** **/
//:YOU_CANT_TYPE_WORTH_SHIT:=================================://
