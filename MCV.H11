//[MACROS_CONFIGURATION:=====================================]//
//[CONFIGURATION_MACROS:=====================================]//

    #define MCV_M_ECI ( 1 )         //:ECI:Error_Check_Inputs://

    //:**************************************************:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:TODO: [If/When] code starts to mysteriously crash,:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      create your own validation for all of the   :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      vulkan function calls and then prey that    :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      you discover a problem.                     :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:**************************************************:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//[=====================================:MACROS_CONFIGURATION]//
//[=====================================:CONFIGURATION_MACROS]//
//[CODING_STYLE|=============================================]//
//[                                                          ]//
//[ Namespaces:                                              ]//
//[                                                          ]//
//[     1. All global tokens begin with "MCV_".              ]//
//[     2. All global tokens have a category namespace.      ]//
//[         MCV_F : Function                                 ]//
//[         MCV_D : Data (AKA: Variable)                     ]//
//[         MCV_U : Unit Test                                ]//
//[         MCV_T : Type                                     ]//
//[         MCV_M : Macro                                    ]//
//[     3. Public  tokens all   capital. EX: MCV_F_WHATEVER  ]//
//[     4. Private tokens all lowercase. EX: mcv_f_whatever  ]//
//[     5. DONT MIX CAPITAL & LOWERCASE: This_Is_Not_Allowed ]//
//[                                                          ]//
//[ Sub_Namespaces:                                          ]//
//[                                                          ]//
//[     mcv_d_n : Number Of (Usually For Array)              ]//
//[     mcv_d_c : Capacity Of Array                          ]//
//[     mcv_d_a : Array Itself                               ]//
//[                                                          ]//
//[     mcv_d_c : c for "create info"                        ]//
//[     mcv_d_o : o for "object" belonging to "create info"  ]//
//[                                                          ]//
//[=============================================|CODING_STYLE]//
//|FUNCTION_INDEX:===========================================|//
//|                                                          |//
//|     mcv_f_err     : ERRor (Halts Program Execution)      |//
//|     mcv_f_say     : SAY   (Informational Message  )      |//
//|     mcv_f_chk     : CHecK (Check Validity Of Something)  |//
//|     mcv_f_gpa     : Get_Proc_Address (Generic  )         |//
//|     mcv_f_gpa_vul : Get_Proc_Address (Vulkan   )         |//
//|     mcv_f_gpa_g32 : Get_Proc_Address (GDI32    )         |//
//|     mcv_f_gpa_u32 : Get_Proc_Address (USER32   )         |//
//|     mcv_f_gpa_k32 : Get_Proc_Address (KERNEL32 )         |//
//|                                                          |//
//|===========================================:FUNCTION_INDEX|//
//+ALL_OTHER_TOKENS_INDEX:===================================+//
//+                                                          +//
//+             rie : Required__Instance_Extensions          +//
//+             aie : Available_Instance_Extensions          +//
//+                                                          +//
//+     mcv_m_n_rie : num_rie : Number Of [rie]              +//
//+     mcv_d_a_rie : arr_rie : Array  Of [rie]              +//
//+                                                          +//
//+     mcv_d_n_aie : num_aie : Number Of [aie]              +//
//+     mcv_d_a_aie : arr_aie : Array  Of [aie]              +//
//+                                                          +//
//+===================================|ALL_OTHER_TOKENS_INDEX+//
//:INCLUDES:=================================================://

    #include "stdio.h"           //:fflush( stdout ) , printf://
    #include "stdint.h"          //:int32_t , uint32_t , etc ://
    #include "libloaderapi.h"  //:LoadLibraryA,GetProcAddress://
    #include <stdlib.h>                           //: exit() ://
                             
//:=================================================:INCLUDES://
//:FILE_MACROS:==============================================://

//: Basic File Macros ://

    #define ECI MCV_M_ECI 
    #define NIL ((void*)0)
    #define VOD   void
    #define DLL   void
    #define U08  uint8_t
    #define U16 uint16_t  
    #define I32  int32_t
    #define U32 uint32_t
    #define U64 uint64_t
    #define I64  int64_t  
    #define F32 float
    #define CHR const char                  //:Ascii___String://
    #define UNI const wchar_t               //:Unicode_String://
    #define NCC       char                  //:Mutable_Ascii ://
    #define ERR mcv_f_err
    #define SAY mcv_f_say
    #define CHK mcv_f_chk
    #define RES int32_t                    //:VkResult Type  ://
    #define GI3 MCV_T_GI3                  //:GenericFunc:I32://
    #define G00 MCV_T_G00                  //:GenericFunc:VOD://
    #define P_F printf
    #define F_F fflush
    #define S_A _Static_assert 
    #define S_O sizeof
    #define SIZ size_t

//: Vulkan Macros To Keep Stuff Terse ://

    //: VEP == "Vulkan_Extension_Properties" ://
    //: PDL == "Physical_Device_Limits"      ://
    //: DSP == "Device_Sparse_Properties"    ://

    #define VEP struct MCV_T_VKEXTENSIONPROPERTIES
    #define PDL struct MCV_T_VKPHYSICALDEVICELIMITS
    #define DSP struct MCV_T_VKPHYSICALDEVICESPARSEPROPERTIES

    S_A( sizeof( U32 ) == 4 );
    S_A( sizeof( I32 ) == 4 );
    S_A( sizeof( U08 ) == 1 );

//:==============================================:FILE_MACROS://
//:MACROS:===================================================://

    //: rie : RequiredInstanceExtensions :- - - - - - - - - -://
    //: aie : AvailableInstanceExtensions( ins_ext ) :- - - -://
    //: men : VK_MAX_EXTENSION_NAME_SIZE :- - - - - - - - - -://
    //: mpd : VK_MAX_PHYSICAL_DEVICE_NAME_SIZE :- - - - - - -://
    //: uid : VK_UUID_SIZE :- - - - - - - - - -:- - - - - - -://

        #define       mcv_m_n_rie ( 2 )   //: Number : rie ://
        extern  CHR*  mcv_d_a_rie[  2 ] ; //: Array  : rie ://
        #define       mcv_d_n_rie [USE:mcv_m_n_rie]

        #define mcv_m_men     ( 256U )//: Max_Extension_Name ://
        #define mcv_m_mpd     ( 256U )//: Max_PhyDev_Name    ://
        #define mcv_m_uid     (  16U )//: VK_UUID_SIZE       ://


        #define mcv_m_c_aie     ( 32 )          //: Capacity ://
        #define mcv_m_c_phy_dev (  8 )          //: Capacity ://
        #define mcv_m_c_qfp    (  16 )          //: Capacity ://

//:===================================================:MACROS://
//:TYPES:====================================================://

    
    typedef VOD* ( MCV_T_G00 )(  );  //:Generic_Function_Type://
    typedef I32  ( MCV_T_GI3 )(  );  //:Generic_Function_Type://

    //:Function_Pointer_Structs:-----------------------------://

        //:WIN32:Function_Pointer_Structs:- - - - - - - - - -://

            struct mcv_t_lib_g32{
                GI3* ChoosePixelFormat ;
                GI3* GetStockObject    ;
                GI3* SetPixelFormat    ;
                GI3* SwapBuffers       ;
            };

            struct mcv_t_lib_u32{
                G00* CreateWindowExW   ;
                GI3* DefWindowProcW    ;
                GI3* DestroyWindow     ;
                GI3* DispatchMessageW  ;
                GI3* GetClientRect     ;
                G00* GetDesktopWindow  ;
                GI3* GetWindowDC       ;
                GI3* LoadCursorA       ;
                GI3* LoadIconA         ;
                GI3* MessageBoxW       ;
                GI3* PeekMessageW      ;
                GI3* PostQuitMessage   ;
                GI3* RegisterClassExW  ;
                GI3* SetFocus          ;
                GI3* ShowWindow        ;
                GI3* TranslateMessage  ;
                GI3* UpdateWindow      ;
            };

            struct mcv_t_lib_k32{
                /** We might not need kernel32 since doing **/
                /** window on a single thread.             **/

                G00* GetModuleHandleW ;
            };

        //:- - - - - - - - - -:WIN32:Function_Pointer_Structs://

    //:-----------------------------:Function_Pointer_Structs://

//:====================================================:TYPES://
//:WIN32_WINDOW_TYPES:=======================================://

    #define CON const
    #define TYP struct mcv_t_wndclassexw

        struct mcv_t_wndclassexw {
                U32   cbSize       ;
                U32   style        ;
                GI3*  lpfnWndProc  ;
                I32   cbClsExtra   ;
                I32   cbWndExtra   ;
                VOD*  hInstance    ;
                VOD*  hIcon        ;
                VOD*  hCursor      ;
                VOD*  hbrBackground;
            CON U16*  lpszMenuName ;
            CON U16*  lpszClassName;
                VOD*  hIconSm      ;
        };
        S_A( S_O( TYP ) == 80 , "[mcv_t_wndclassexw]" );

    #undef  CON
    #undef  TYP
    #define P_T struct mcv_t_point

        //:[ wtypes.h ]://

            struct mcv_t_point {
                I32 x ;
                I32 y ;
            };

        //:[ winuser.h ]&[ wtypes.h ]://

            struct mcv_t_msg {
                VOD*    hwnd;
                U32  message;
                U64   wParam;   
                I64   lParam;   
                U32     time;  
                P_T       pt;
            };

    #undef  P_T

//:=======================================:WIN32_WINDOW_TYPES://
//:VULKAN_CORE_TYPES:========================================://
//:                                                          ://
//: #VULKAN_TYPES# #TYPES_VULKAN# #VULKAN_HEADER_TYPES#      ://
//:                                                          ://
//:- - - - - - - - - - - - - - -- - - - - - - - - - - - - - -://

//:VkStructureType://

    //: typedef I32 MCV_T_VKSTRUCTURETYPE ;

//:VkInstanceCreateFlags://

    //: typedef U32 MCV_T_VKINSTANCECREATEFLAGS

//:VkApplicationInfo://

    struct MCV_T_VKAPPLICATIONINFO {
              I32                    sType;
        const VOD*                   pNext;
              CHR*        pApplicationName;
              U32       applicationVersion;
              CHR*             pEngineName;
              U32            engineVersion;
              U32               apiVersion;
    };
    S_A( sizeof( struct MCV_T_VKAPPLICATIONINFO ) == 48 );

//:VkInstanceCreateInfo://

    struct MCV_T_VKINSTANCECREATEINFO {

        I32                                           sType;

        const void*                                   pNext;

        U32                                           flags;

        const struct MCV_T_VKAPPLICATIONINFO*     
                                           pApplicationInfo;

        uint32_t                          enabledLayerCount;

        const char* const*              ppEnabledLayerNames;

        uint32_t                      enabledExtensionCount;

        const char* const*          ppEnabledExtensionNames;
    };
    S_A( sizeof( struct MCV_T_VKINSTANCECREATEINFO ) == 64 );

//:VkAllocationCallbacks://
                
    /** typedef void MCV_T_VKALLOCATIONCALLBACKS **/      

//:VkInstance://
            
    /** typedef void MCV_T_VKINSTANCE **/ 

//:VkExtensionProperties://

    struct MCV_T_VKEXTENSIONPROPERTIES {
        NCC  ext_nam[ mcv_m_men ];           //:extensionName://
        U32  spe_ver             ;           //:specVersion  ://
    };
    S_A( sizeof( struct MCV_T_VKEXTENSIONPROPERTIES ) == 260 );
    S_A( sizeof( VEP )                                == 260 );

//:VkPhysicalDevice://

    /** **************************************************** **/
    /** DONT CREATE: typedef void MCV_T_VKPHYSICALDEVICE     **/
    /** Just use void* when you want VkPhysicalDevice        **/
    /** Documentation: VK_DEFINE_HANDLE(VkPhysicalDevice)    **/
    /** **************************************************** **/

//:VkPhysicalDeviceType://

    //:------------------------------------------------------://
    //: I find enums kind of useless, so just use a I32      ://
    //: whenever a member variable or parameter says         ://
    //: that it is an enum.                                  ://
    //:------------------------------------------------------://

    //:------------------------------------------------------://
    //:  // Provided by VK_VERSION_1_0                       ://
    //:  enum MCV_T_VKPHYSICALDEVICETYPE {                   ://
    //:      VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,              ://
    //:      VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,     ://
    //:      VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,       ://
    //:      VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,        ://
    //:      VK_PHYSICAL_DEVICE_TYPE_CPU = 4,                ://
    //:  };                                                  ://
    //:------------------------------------------------------://

//:VkPhysicalDeviceLimits ( PDL ) ://

    //: This struct has about 106 (+-1) members.
    //: That is a lot of bloat. So in our code rather than
    //: paste all of that bloat, we will just make a struct
    //: that has the correct size in bytes of the vulkan
    //: header type[ VkPhysicalDeviceLimits ].
    struct MCV_T_VKPHYSICALDEVICELIMITS{
        U08 data[ 504 ];
    };
    S_A( sizeof( struct MCV_T_VKPHYSICALDEVICELIMITS ) == 504 );
    S_A( sizeof( PDL )                                 == 504 );

//:VkPhysicalDeviceSparseProperties://

    struct MCV_T_VKPHYSICALDEVICESPARSEPROPERTIES {
    
        //: rs == "residencyStandard"
        //: re == "residencyExtra" (NOT residencyStandard)

        //: residencyStandard2DBlockShape
        U32 rs_2DBlockShape              ;

        //: residencyStandard2DMultisampleBlockShape 
        U32 rs_2DMultisampleBlockShape   ;

        //: residencyStandard3DBlockShape:
        U32 rs_3DBlockShape              ;

        //: residencyAlignedMipSize
        U32 re_AlignedMipSize            ;

        //: residencyNonResidentStrict
        U32 re_NonResidentStrict         ;
    };
    S_A( S_O( struct MCV_T_VKPHYSICALDEVICESPARSEPROPERTIES ) 
                                                        == 20 );
    S_A( S_O( DSP ) == 20 );

//:VkPhysicalDeviceProperties://

    S_A( sizeof( I32 ) == 4 );
    struct MCV_T_VKPHYSICALDEVICEPROPERTIES {
        U32            apiVersion             ;     //:   4  ://
        U32         driverVersion             ;     //:   4  ://
                                                    //:      ://
        U32              vendorID             ;     //:   4  ://
        U32              deviceID             ;     //:   4  ://
                                                    //:      ://
        I32           deviceType              ;     //:   4  ://
                                                    //:      ://
        NCC            deviceName[ mcv_m_mpd ];     //: 256  ://
        U08     pipelineCacheUUID[ mcv_m_uid ];     //:  16  ://
                                                    //:      ://                                      
        U08 pad_001[ 4 ]                      ;              
        PDL                limits             ;     //: 504  ://
        DSP      sparseProperties             ;     //:  20  ://
        U08 pad_002[ 4 ]                      ;
    };
    S_A( (4+4 + 4+4 + 4 + 256+16 + 504+20)             == 816 );
    S_A( S_O( struct MCV_T_VKPHYSICALDEVICEPROPERTIES )!= 816 );

    S_A( (816 + 4 + 4 )                                == 824 );
    S_A( S_O( struct MCV_T_VKPHYSICALDEVICEPROPERTIES )== 824 ); 

//:VkPhysicalDeviceFeatures

    //:------------------------------------------------------://
    //: Used TWICE:                                          ://
    //:                                                      ://
    //: 1st: To QUERY   physical device      FEATURES.       ://
    //: 2nd: To REQUEST physical device with FEATURES.       ://
    //:                                                      ://
    //: 1st: VT/../Setup/Physical_devices_and_queue_families ://
    //: 2nd: VT/../Setup/Logical_device_and_queues           ://
    //:------------------------------------------------------://

    S_A( 8 * 220 == 32 * 55 );
    struct MCV_T_VKPHYSICALDEVICEFEATURES {
        //: U08 data[ 220 ];
        U32 data[ 55 ]; //:<--SizeOf[ VkBool32 ]://
    };
    S_A( S_O( struct MCV_T_VKPHYSICALDEVICEFEATURES ) == 220 );

//:VkQueueFlags

    /** VkQueueFlags is a typedef for uint32_t **/
    /** Just use U32 to reduce abstraction.    **/

//:VkExtent3D

    #define E3D struct MCV_T_VKEXTENT3D

        // Provided by VK_VERSION_1_0
        struct MCV_T_VKEXTENT3D{
            U32 wid ; //: width  ://
            U32 hig ; //: height ://
            U32 dep ; //: depth  ://
        };
        S_A( S_O( E3D ) == 12 , "[E3D]" );

    #undef  E3D

//:VkQueueFamilyProperties

    #define E3D struct MCV_T_VKEXTENT3D
    #define QFP struct MCV_T_VKQUEUEFAMILYPROPERTIES

        // Provided by VK_VERSION_1_0
        struct MCV_T_VKQUEUEFAMILYPROPERTIES{
            U32 q_f ;        //: queueFlags                  ://
            U32 num ;        //: queueCount                  ://
            U32 tim ;        //: timestampValidBits          ://
            E3D min ;        //: minImageTransferGranularity ://
        };
        S_A( S_O( QFP ) == 24 , "[QFP]" );

    #undef  EXT
    #undef  QFP

//:VkDeviceQueueCreateFlags

    /** Typedef resolves to U32 , so use U32. **/

//:VkDeviceQueueCreateInfo 

    #define C_I struct MCV_T_VKDEVICEQUEUECREATEINFO

        // Provided by VK_VERSION_1_0
        struct MCV_T_VKDEVICEQUEUECREATEINFO {
                  I32    typ ;    //: sType                  ://
            const VOD*   nex ;    //: pNext                  ://
                  U32    c_f ;    //: flags ( create flags ) ://
                  U32    fam ;    //: queueFamilyIndex       ://
                  U32    num ;    //: queueCount             ://
            const F32*   q_p ;    //: pQueuePriorities       ://
        };
        S_A( S_O( C_I ) == 40 , "[D_Q_C_I]" );

    #undef  C_I

//:VkDevice ( logical device ):

    /** Do not create this. It is just a void pointer. **/
    /** SEE: mcv_d_log_dev *************************** **/

//:VkDeviceCreateFlags:

    /** Resolves to a U32 for bit packing flags. **/
    /** So just use   U32.                       **/

//:VkDeviceCreateInfo:

    #define DCI struct MCV_T_VKDEVICECREATEINFO
    #define C_I struct MCV_T_VKDEVICEQUEUECREATEINFO
    #define LIS const char* const* //:Immutable List://
    #define FET struct MCV_T_VKPHYSICALDEVICEFEATURES

        struct MCV_T_VKDEVICECREATEINFO {
                  I32       typ; //: sType                   ://
            const VOD*      nex; //: pNext                   ://
                  U32       c_f; //: flags                   ://
                        
                  U32   num_qci; //: queueCreateInfoCount    ://
            const C_I*  arr_qci; //: pQueueCreateInfos       ://
                                                    
                  U32   num_lay; //: enabledLayerCount       ://
                  LIS   arr_lay; //: ppEnabledLayerNames     ://
                                     
                  U32   num_ext; //: enabledExtensionCount   ://
                  LIS   arr_ext; //: ppEnabledExtensionNames ://

            const FET*      fet; //: pEnabledFeatures        ://
        };
        S_A( S_O( DCI ) == 72 , "[CHECKSUM_DCI]" );

    #undef  DCI
    #undef  C_I
    #undef  LIS
    #undef  FET

//:VkAllocationCallbacks:

    #define C_B struct MCV_T_VKALLOCATIONCALLBACKS

        struct MCV_T_VKALLOCATIONCALLBACKS {
            U64 data[ 6 ];   //:Six Pointer Members In Struct://
        };
        S_A( S_O( C_B ) == 48 , "[CHECKSUM:C_B]" );

    #undef  C_B

//:VkSurfaceKHR://

    /** Just use void pointer because is defined as opaque.  **/

//:VkWin32SurfaceCreateFlagsKHR://
    
    /** Just Use U32 because that's what it resolves to. **/

//:VkWin32SurfaceCreateInfoKHR://

    #define W_S struct mct_t_vkwin32surfacecreateinfokhr

        // Provided by VK_KHR_win32_surface
        struct mct_t_vkwin32surfacecreateinfokhr{
                  I32   typ;                //: sType        ://
            const VOD*  nex;                //: pNext        ://
                  I32   c_f;                //: Create_Flags ://
                  VOD*  hin;                //: hInstance    ://
                  VOD*  win;                //: hwnd         ://
        };
        S_A( S_O( W_S ) == 40 , "[win32_surf_size]" );
    
    #undef  W_S
    
//:========================================:VULKAN_CORE_TYPES://
//:DATA:=====================================================://

    //:MISC_DATA:--------------------------------------------://

        I32 mcv_d_kot =( 1 );          //:KOT:Keep_On_ticking://

    //:--------------------------------------------:MISC_DATA://
    //:DLL:--------------------------------------------------://
    
        //:Vulkan DLL(s):

            DLL* mcv_d_dll_vul = ((DLL*)0);

        //: Microsoft Windows Window DLL(s):                 ://

            DLL* mcv_d_dll_g32 = ((DLL*)0); //:"gdi32.dll"   ://
            DLL* mcv_d_dll_u32 = ((DLL*)0); //:"kernel32.dll"://
            DLL* mcv_d_dll_k32 = ((DLL*)0); //:"user32.dll"  ://

    //:--------------------------------------------------:DLL://
    //:FPS:FUNCTION_POINTER_STRUCTS:=========================://

        //: #_DO_NOT_POPULATE_FPS_USING_HELPER_FUNCTIONS_#   ://

        struct mcv_t_lib_g32 mcv_d_lib_g32 ={ 0 };
        struct mcv_t_lib_u32 mcv_d_lib_u32 ={ 0 };
        struct mcv_t_lib_k32 mcv_d_lib_k32 ={ 0 };

    //:=========================:FPS:FUNCTION_POINTER_STRUCTS://
    //:WIN32_DATA:-------------------------------------------://

        VOD* mcv_d_win = ((VOD*)0); //:hwnd://

    //:-------------------------------------------:WIN32_DATA://
    //:VULKAN_MISC:(Not Vulkan Object Instances):------------://

        //:FOR: VkEnumerateInstanceExtensionProperties://
        
            //:ins_ext ==           Instance_Extensions
            //:    aie == Available_Instance_Extensions

            #define  mcv_m_c_aie                ( 32 )    
            VEP      mcv_d_a_aie[ mcv_m_c_aie ]={  0 };
            U32      mcv_d_n_aie               =(  0 ); 
            #define  mcv_d_c_aie [USE:mcv_m_c_aie]
            #define  mcv_m_n_aie [USE:mcv_d_n_aie]
            
        //:FOR: ppEnabledExtensionNames://

            CHR* mcv_d_a_rie[ mcv_m_n_rie ]={
            /** ******************************************** ***                                 
            *** www.khronos.org/registry/vulkan/specs/       ***
            *** 1.2-khr-extensions/html/chap47.html          ***
            ***                                              ***
            *** Also: Cross Checked: GLFW Library            ***
            *** glfwGetRequiredInstanceExtensions            ***
            *** _glfwPlatformGetRequiredInstanceExtensions   ***
            *** ******************************************** **/

                "VK_KHR_surface"
            //: "VK_KHR_swapchain"                <-- DEVICE_EXT 
            ,   "VK_KHR_win32_surface"

            //: "VK_KHR_external_memory_win32"  
            //: "VK_KHR_win32_keyed_mutex"  
            //: "VK_KHR_external_semaphore_win32"  
            //: "VK_KHR_external_fence_win32" 
            };

        //: FOR: VkDeviceQueueCreateInfo

            F32 mcv_d_q_p =( 1.0 );  //: queuePriority  ://

    //:------------------------------------------:VULKAN_MISC://
    //:VULKAN_OBJECTS:---------------------------------------://
    #define ICI struct MCV_T_VKINSTANCECREATEINFO 
    #define A_I struct MCV_T_VKAPPLICATIONINFO
    #define QFP struct MCV_T_VKQUEUEFAMILYPROPERTIES

        //:Application_Info:

            A_I   mcv_d_applicationinfo ={ 0 };   
 
        //:Vulkan_Instance :

            ICI   mcv_d_c_instance  ={   0   };
            VOD*  mcv_d_o_instance  =((VOD*)0);

        //: Physical_Device:( phy_dev ):- - - - - - - - - - -://
        //:     m_c : Macro_Capacity                         ://
        //:     d_a : Data__Array                            ://
        //:     d_n : Data__NumberOf( in array )             ://
        //:     d_o : Data__Object( Choosen Physical Device )://

            #define  mcv_m_c_phy_dev (  8 ) 
            VOD*     mcv_d_a_phy_dev[ mcv_m_c_phy_dev ];
            U32      mcv_d_n_phy_dev =( 0 );
            VOD*     mcv_d_o_phy_dev =( NIL ); 
            #define    mcv_d_phy_dev [USE:mcv_d_o_phy_dev]

        //: queueFamilies for the given Physical_Device:- - -://

            #define  mcv_m_c_qfp (  16 )  
            QFP      mcv_d_a_qfp[ mcv_m_c_qfp ];
            U32      mcv_d_n_qfp =( 0 );
            I32      mcv_d_i_qfp_gra =( 0 - 1 );  //:GRAPHICS://
            I32      mcv_d_i_qfp_com =( 0 - 1 );  //:COMPUTE ://

        //: Logical_Device: ( log_dev ):- - - - - - - - - - -://

            VOD*       mcv_d_log_dev =( NIL );
            #define  mcv_d_o_log_dev [USE:mcv_d_log_dev]

        //: Surface:- - - - - - - - - - - - - - - - - - - - -://

            VOD* mcv_d_sur =((VOD*)0);        //:VkSurfaceKHR://

    #undef  ICI
    #undef  A_I
    #undef  QFP
    //:---------------------------------------:VULKAN_OBJECTS://

//:=====================================================:DATA://
//:FUNCTIONS_BASIC:==========================================://

    VOD  mcv_f_err( CHR* msg ){
        P_F( "[mcv_f_err]:%s" , msg );
        F_F( stdout );
        exit( 0xFF );
    }

    VOD  mcv_f_say( CHR* msg ){
        P_F( "[mcv_f_say]:%s" , msg );
        F_F( stdout );
    }

    VOD  mcv_f_chk( I32  res , CHR* msg ){
    #define P P_F
    #define B break

        if( 0 != res ){ 
            P_F( "[chk_fail:res]:%d\n" , res );
            P_F( "[chk_fail:msg]:%s\n" , msg );

            switch( res ){
            case (0-7) : P("[EXTENSION_NOT_PRESENT]\n"); B;
            default:
            };;

            ERR("[FAILED_CHECK]");
        }else
        if( 0 == res ){ 
            P_F( "[chk_pass:res]:%d\n" , res );
            P_F( "[chk_pass:msg]:%s\n" , msg );
        };;

    #undef  P
    #undef  B
    }

    //:GPA_Basic:--------------------------------------------://

        GI3* mcv_f_gpa( DLL* dll , CHR* nam ){

            if( ((DLL*)0) == dll ){ ERR("[NIL:DLL]"); };
            if( ((CHR*)0) == nam ){ ERR("[NIL:NAM]"); };

            GI3* fun = (GI3*)GetProcAddress( dll , nam );
            if( ((GI3*)0) == fun ){
                P_F("[NAME_OF_FUNCTION]:%s\n" , nam );
                ERR("[FAILED:mcv_f_gpa]\n");
            };;
            return( fun );
        }

    //:--------------------------------------------:GPA_Basic://
    //:GPA_Specific:-----------------------------------------://

        //:GPA: VULKAN DLL://

            GI3* mcv_f_gpa_vul( CHR* nam ){

                DLL* dll =( mcv_d_dll_vul );
                if( ((DLL*)0) == dll ){ ERR("[VUL_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[VUL_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: GDI32 DLL://

            GI3* mcv_f_gpa_g32( CHR* nam ){

                DLL* dll =( mcv_d_dll_g32 );
                if( ((DLL*)0) == dll ){ ERR("[G32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[G32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: USER32 DLL://

            GI3* mcv_f_gpa_u32( CHR* nam ){

                DLL* dll =( mcv_d_dll_u32 );
                if( ((DLL*)0) == dll ){ ERR("[U32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[U32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: KERNEL32 DLL://

            GI3* mcv_f_gpa_k32( CHR* nam ){

                DLL* dll =( mcv_d_dll_k32 );
                if( ((DLL*)0) == dll ){ ERR("[K32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[K32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

    //:-----------------------------------------:GPA_Specific://

//:==========================================:FUNCTIONS_BASIC://
//:FUNCTIONS_DEBUGGING:======================================://

    I32 MCV_F_CRA(          //: CRA: Compute_Relative_Address://
        VOD*  a_s           //: Address Of Struct.           ://
    ,   VOD*  a_m           //: Address Of Member.          ://
    ){
        I32  act =  (I32)( a_m - a_s );
        return( act );
    }

    VOD MCV_F_ARA(          //: ARA: Assert_Relative_Address ://
        VOD* a_s            //: Address Of Struct.           ://
    ,   VOD* a_m            //: Address Of Member.           ://
    ,   I32  rel            //: Relative Address Of Member   ://
    ,   CHR* msg            //: On Error Message             ://
    ){
        I32  act =  MCV_F_CRA( a_s , a_m );
        if(  act != rel ){
            P_F( "[ARA_FAIL:MSG]:%s\n" , msg );
            ERR( "[FAIL:ASSERT_RELATIVE_ADDRESS(ARA)]" );
        };;
    }

//:======================================:FUNCTIONS_DEBUGGING://
//:FUNCTIONS_VULKAN:=========================================://
//:VULKAN_FUNCTIONS:=========================================://

//: vkCreateInstance ://

    RES MCV_F_VKCREATEINSTANCE(
        const struct MCV_T_VKINSTANCECREATEINFO*                 
                                            pCreateInfo 
    ,   const VOD*                           pAllocator 
    ,   VOD*                                 pInstance
    ){
        GI3* fun = mcv_f_gpa_vul( "vkCreateInstance" );
        return( (RES)fun( pCreateInfo,pAllocator,pInstance ) );
    }

//: VK_MAKE_VERSION ( vmv ) ://

    U32 mcv_f_vmv( U32 maj , U32 min , U32 pat ){
        U32 out =( ((U32)0)
        |   ( maj << 22 )
        |   ( min << 12 )
        |   ( pat <<  0 )
        );;
        return( out );
    }

//: VK_MAKE_API_VERSION ( mav ) ://

    U32 mcv_f_mav( U32 var , U32 maj , U32 min , U32 pat ){
        U32 out =( ((U32)0)
        |   ( var << 29 )
        |   ( maj << 22 )
        |   ( min << 12 )
        |   ( pat <<  0 )
        );;
        return( out );
    }
    
//: vkEnumerateInstanceExtensionProperties ( EIEP ) ://

    RES MCV_F_EIEP(
        CHR*    N                  //: Name : pLayerName     ://
    ,   U32*    C                  //: Count: pPropertyCount ://
    ,   VEP*    A                  //: Array: pProperties    ://
    ){
        GI3* fun =mcv_f_gpa_vul( 
        "vkEnumerateInstanceExtensionProperties" );;
        return( fun( N,C,A ) );
    }

//: vkEnumeratePhysicalDevices ( EPD ) ://

    RES MCV_F_EPD(
        VOD*  I //: VkInstance                               ://
    ,   U32*  N //: NumberOf:Devices ( pPhysicalDeviceCount )://
    ,   VOD** A //: Array_Of:Devices ( pPhysicalDevices     )://
    ){
        GI3* fun =mcv_f_gpa_vul( "vkEnumeratePhysicalDevices" );
        return( (RES)fun( I,N,A ) );
    }

//: vkGetPhysicalDeviceProperties ://

    #define TMP struct MCV_T_VKPHYSICALDEVICEPROPERTIES
    #define GET mcv_f_gpa_vul

        VOD MCV_F_VKGETPHYSICALDEVICEPROPERTIES(
            VOD* phy_dev
        ,   TMP*     pdp
        ){
            GI3* fun =GET( "vkGetPhysicalDeviceProperties" );
            fun( phy_dev , pdp );
        }
    #undef  TMP
    #undef  GET

//: vkGetPhysicalDeviceFeatures ://

    #define TMP struct MCV_T_VKPHYSICALDEVICEFEATURES
    #define GET mcv_f_gpa_vul

        VOD MCV_F_VKGETPHYSICALDEVICEFEATURES(
            VOD* phy_dev
        ,   TMP*     pdf
        ){
            GI3* fun =GET( "vkGetPhysicalDeviceFeatures" );
            fun( phy_dev , pdf );
        }
    #undef  TMP
    #undef  GET

//: PRINT: PhysicalDeviceProperties:

    VOD MCV_F_P_VKPHYSICALDEVICEPROPERTIES(
        struct MCV_T_VKPHYSICALDEVICEPROPERTIES * pdp
    ){
        P_F( "[apiVersion]:%d\n"        , (*pdp).apiVersion   );
        P_F( "[driverVersion]:%d\n"     , (*pdp).driverVersion);
        P_F( "[vendorID]:%d\n"          , (*pdp).vendorID     );
        P_F( "[deviceID]:%d\n"          , (*pdp).deviceID     );
        P_F( "[deviceType]:%d\n"        , (*pdp).deviceType   );
                                                        
        P_F( "[deviceName]:%s\n"        , (*pdp).deviceName   );

        P_F( "[pipelineCacheUUID]:%s\n" , "[SKIP_PRINTING]"   );
        P_F( "[limits]:%s\n"            , "[SKIP_PRINTING]"   );
        P_F( "[sparseProperties]:%s\n"  , "[SKIP_PRINTING]"   );
    }

//: vkGetPhysicalDeviceQueueFamilyProperties ://

    #define DEV VOD*   //: MCV_T_VKPHYSICALDEVICE ://
    #define QFP struct     MCV_T_VKQUEUEFAMILYPROPERTIES

        VOD MCV_F_G_QFP(
            DEV  phy_dev //: VkPhysicalDevice physicalDevice ://
        ,   U32* qfp_num //: pQueueFamilyPropertyCount       ://
        ,   QFP* qfp_arr //: VkQueueFamilyProperties*        ://
                         //: pQueueFamilyProperties          ://
        ){
            GI3* fun =mcv_f_gpa_vul( 
                "vkGetPhysicalDeviceQueueFamilyProperties" );;
            fun( phy_dev , qfp_num , qfp_arr );
        }
    #undef  DEV
    #undef  QFP

//: vkCreateDevice ://

    #define DCI struct MCV_T_VKDEVICECREATEINFO
    #define C_B struct MCV_T_VKALLOCATIONCALLBACKS
    #define CON const

        RES MCV_F_VKCREATEDEVICE(
                VOD*      phy             //: physicalDevice ://
        ,   CON DCI*      dci             //: pCreateInfo    ://
        ,   CON C_B*  nil_001             //: pAllocator     ://
        ,       VOD*      log             //: pDevice        ://
        ){
            if( ECI >= 1 ){
                //:Hackish Validation:
                if( NIL == phy       ){ ERR("[NIL_PHY]"); };
                if(  3  != dci -> typ){ ERR("[DCI_TYP]"); };
                if( NIL != nil_001   ){ ERR("[NIL!001]"); };
                if( NIL == log       ){ ERR("[NIL_LOG]"); };
            };;

            GI3* fun =mcv_f_gpa_vul( "vkCreateDevice" );
            return( (RES)fun( phy , dci , nil_001 , log  ) );
        };

    #undef  DCI
    #undef  C_B
    #undef  CON

//:=========================================:FUNCTIONS_VULKAN://
//:=========================================:VULKAN_FUNCTIONS://
//:FUNCTIONS:================================================://

    DLL* mcv_f_dll_get( CHR* nam ){

        DLL* dll = LoadLibraryA( nam );
        if( ((DLL*)0) == dll ){
            ERR( "[FAILED_TO_LOAD_DLL]" );
        };;
        return( dll );
    }

    //:Default_Win32_WindowProc:-----------------------------://

        I64 __stdcall mcv_f_windowproc(
            VOD*    hwnd
        ,   U32     uMsg
        ,   U64   wParam  
        ,   I64   lParam  
        ){

            I64 res =( 64 );        //: init result to error ://

            switch (uMsg){

            case 0x0002 /** WM_DESTROY **/ :{

                mcv_d_lib_u32.PostQuitMessage(0);
                mcv_d_kot =( 0-1 );
                res=( 0 );

            };break;
            case 0x000F /** WM_PAINT **/ :{

                //:DONT DO ANY PAINTING HERE, VULKAN IS GOING
                //:TO TAKE CARE OF THAT FOR US.
                res=( 0 );

            };break;
            default:{

                res =( mcv_d_lib_u32.DefWindowProcW(
                    hwnd, uMsg, wParam, lParam));

            };break;}

            return( res ); 
        }


    //:Default_Win32_WindowProc:-----------------------------://

    #define mcv_f_dll_all [JUST_INLINE_THE_LOGIC]  //: @MWM@ ://                                             

    VOD  MCV_F_INI( VOD ){              //:Initialize Library://
    #define A_I mcv_d_applicationinfo
    #define ICI mcv_d_c_instance

        //:Debug:--------------------------------------------://
        {
        #define A MCV_F_ARA

            //:Make sure padding hack has not altered the
            //:relative address of these memebers.
            struct MCV_T_VKPHYSICALDEVICEPROPERTIES t={ 0 };
            A( &( t ) , &( t.pipelineCacheUUID ) , 276 ,"[1]");
            A( &( t ) , &( t.limits            ) , 296 ,"[2]");
            A( &( t ) , &( t.sparseProperties  ) , 800 ,"[3]");
             
        }
        //:--------------------------------------------:Debug://
        //:Declare_Variables:--------------------------------://

            RES res =( 0 );
            SIZ siz =( 0 );

        //:--------------------------------:Declare_Variables://
        //:Load_All_Libraries:-------------------------------://
        //:VIDEO_017:----------------------------------------://
        
            //: Conceptually : mcv_f_dll_all( ) ://        
            #define GET mcv_f_dll_get

                mcv_d_dll_vul = GET( "vulkan-1.dll" );

                mcv_d_dll_g32 = GET(    "gdi32.dll" );
                mcv_d_dll_u32 = GET(   "user32.dll" );
                mcv_d_dll_k32 = GET( "kernel32.dll" );

            #undef  GET

        //:----------------------------------------:VIDEO_017://
        //:-------------------------------:Load_All_Libraries://
        //:VIDEO_017:----------------------------------------://
        //:Function_Pointer_Frontloading:--------------------://

            //:REFERENCE[ <AAC>/AAC2020/LIB/GINAWIN.D._ ]://

            #define g32 mcv_d_lib_g32
            #define u32 mcv_d_lib_u32
            #define k32 mcv_d_lib_k32

            #define   G mcv_f_gpa_g32
            #define   U mcv_f_gpa_u32
            #define   K mcv_f_gpa_k32
            
            //:G32:GDI32:

            g32.ChoosePixelFormat =G( "ChoosePixelFormat" );
            g32.GetStockObject    =G( "GetStockObject"    );
            g32.SetPixelFormat    =G( "SetPixelFormat"    );
            g32.SwapBuffers       =G( "SwapBuffers"       );

            //:U32:USER32:

            u32.CreateWindowExW   =(G00*)U( "CreateWindowExW"    );
            u32.DefWindowProcW    =U( "DefWindowProcW"     );
            u32.DestroyWindow     =U( "DestroyWindow"      );
            u32.DispatchMessageW  =U( "DispatchMessageW"   );
            u32.GetClientRect     =U( "GetClientRect"      );
            u32.GetDesktopWindow  =(G00*)U( "GetDesktopWindow"   );
            u32.GetWindowDC       =U( "GetWindowDC"        );
            u32.LoadCursorA       =U( "LoadCursorA"        );
            u32.LoadIconA         =U( "LoadIconA"          );
            u32.MessageBoxW       =U( "MessageBoxW"        );
            u32.PeekMessageW      =U( "PeekMessageW"       );
            u32.PostQuitMessage   =U( "PostQuitMessage"    );
            u32.RegisterClassExW  =U( "RegisterClassExW"   );
            u32.SetFocus          =U( "SetFocus"           );
            u32.ShowWindow        =U( "ShowWindow"         );
            u32.TranslateMessage  =U( "TranslateMessage"   );
            u32.UpdateWindow      =U( "UpdateWindow"       );

            //:K32:KERNEL32:

            k32.GetModuleHandleW  =(G00*)K( "GetModuleHandleW");

            #undef   g32
            #undef   u32
            #undef   k32

            #undef     G 
            #undef     U 
            #undef     K 
            
        //:--------------------:Function_Pointer_Frontloading://
        //:----------------------------------------:VIDEO_017://
        //:Get_Available_Instance_Extensions( aie ):---------://

            #define NUM mcv_d_n_aie
            #define ARR mcv_d_a_aie
            #define CAP mcv_m_c_aie
            
                res = MCV_F_EIEP( NIL , &NUM , NIL );
                CHK( res , "[MCV_F_EIEP:GET_NUM]"  );
                if( NUM > CAP ){ ERR("[NUM>CAP]"); };
                if( NUM <= 0  ){ ERR("[NUM<=00]"); };
          
                res = MCV_F_EIEP( NIL, &(NUM) , &( ARR[ 0 ] ) );
                CHK( res , "[MCV_F_EIEP:GET_ARR]"  );

                P_F("[mcv_d_n_aie]:%d\n", NUM );
                for( I32 i = 0 ; i <= (NUM-1) ; i++ ){
                    P_F( 
                        "ARR[%2d]( %42s )\n"
                    ,        i
                    ,   &( ARR[ i ].ext_nam[ 0 ] )
                    );;
                };;

            #undef  NUM  
            #undef  ARR  
            #undef  CAP  

        //:---------:Get_Available_Instance_Extensions( aie )://
        //:VIDEO_012:----------------------------------------://
        //:VIDEO_012 : Has_Instance_Extensions ? :- - - - - -://
        //:Required_Instance_Extensions_All_Available? :- - -://
        {
        //:Available_Instance_Extensions :
        #define NUM_AIE mcv_d_n_aie
        #define ARR_AIE mcv_d_a_aie
        {
        //:Required__Instance_Extensions :
        #define NUM_RIE mcv_m_n_rie
        #define ARR_RIE mcv_d_a_rie
        {

            //:Compare_Available_And_Required:- - - - - - - -://
            I32            sm ; //:sm: Strings_Match         ://
            CHR* a_n ; I32 ai ; //:Available[ Name | Index ] ://
            CHR* r_n ; I32 ri ; //:Required[  Name | Index ] ://
            
            for( I32 r = 0 ; r <= (NUM_RIE-1) ; r++ ){
            for( I32 a = 0 ; a <= (NUM_AIE-1) ; a++ ){
            
                a_n = &( ARR_AIE[ a ].ext_nam[ 0 ] );
                r_n = &( ARR_RIE[ r ]        [ 0 ] );
            
                //:compare strings without strcmp://
                sm =(   1   );       //: Matches_By_Default  ://
                ai =(   0   );       //: CharIndex:AVAILABLE ://
                ri =(   0   );       //: CharIndex:REQUIRED  ://
                while(  1  ){
                    if( a_n[ ai ] != r_n[ ri ] ){ sm-- ; };
                    if( 0 == a_n[ ai ] ){ break; };
                    if( 0 == r_n[ ri ] ){ break; };
                    ai++;
                    ri++;
                };;
            
                if( sm >= 1 ){ break; }; 
            };;
                if( sm <= 0 ){
                    P_F( "[sm]:%d\n"           , sm );
                    P_F( "[Missing_RIE]:%s\n" , r_n );
                    P_F( "[a_n]:%s\n"         , a_n );
                    ERR( "[RIE_Not_Found]"          );
                };;
            };;

        }
        #undef  NUM_AIE 
        #undef  ARR_AIE 
        }
        #undef  NUM_RIE 
        #undef  ARR_RIE 
        }
        //:----------------------------------------:VIDEO_012://
        //:WHEN_WAS_THIS:------------------------------------://

            //:VkApplicationInfo:

                A_I.sType =( 0 );
                A_I.pApplicationName   ="[Hello Triangle]"    ;
                A_I.applicationVersion = mcv_f_vmv(   1, 0, 0);
                A_I.pEngineName        ="[No Engine]"         ;
                A_I.engineVersion      = mcv_f_vmv(   1, 0, 0);
                A_I.apiVersion         = mcv_f_mav(0, 1, 2, 0);

            //:VkInstanceCreateInfo:
            
                ICI.sType                   = (  1  )      ;
                ICI.pApplicationInfo        =&( A_I )      ;
                ICI.enabledExtensionCount   = mcv_m_n_rie  ;
                ICI.ppEnabledExtensionNames = mcv_d_a_rie  ;
                ICI.enabledLayerCount       = 0            ;
            
            //:VkCreateInstance:

                res = MCV_F_VKCREATEINSTANCE(
                    &( mcv_d_c_instance )
                ,    (       0          )   //:Allo_Callbacks://          
                ,   &( mcv_d_o_instance )
                );;
                CHK( res , "[Instance_Create]" );

        //:------------------------------------:WHEN_WAS_THIS://
        //:VIDEO_013:----------------------------------------://
        //:vkEnumeratePhysicalDevices:-----------------------://

            #define INS mcv_d_o_instance      //:[ vul_ins  ]://
            #define NUM mcv_d_n_phy_dev       //:[ number of]://
            #define ARR mcv_d_a_phy_dev       //:[ array  of]://
            #define CAP mcv_m_c_phy_dev       //:[ capacity ]://
        
                //:Get number of physical devices :

                    res = MCV_F_EPD( INS , &NUM , NIL );
                    CHK( res , "[Enum_Phy_Dev:001]" );
                    if( NUM > CAP ){ ERR("[2MANY_PHY_DEV]"); };

                //:Load physical devices into array :

                    res = MCV_F_EPD( INS , &NUM , ARR );
                    CHK( res , "[Enum_Phy_Dev:002]" );

                //:Smoke Test : Print Number Of[ phy_dev ]:

                    P_F( "[num_phy_dev]:%d\n" , NUM );

            #undef  INS  //:---------------------------------://
            #undef  NUM  //:---------------------------------://
            #undef  ARR  //:---------------------------------://
            #undef  CAP  //:---------------------------------://

        //:-----------------------:vkEnumeratePhysicalDevices://
        //:----------------------------------------:VIDEO_013://
        //:VIDEO_014:----------------------------------------://
        //:Pick a physical device by making calls to:
        //:1: vkGetPhysicalDeviceProperties
        //:2: vkGetPhysicalDeviceFeatures
        //:And acting accordingly.
        #define G_P MCV_F_VKGETPHYSICALDEVICEPROPERTIES
        #define G_F MCV_F_VKGETPHYSICALDEVICEFEATURES
        #define ARR mcv_d_a_phy_dev
        #define NUM mcv_d_n_phy_dev
        #define DEV mcv_d_o_phy_dev
        {
            if( NUM <= 0 ){ ERR("[NO_PHYSICAL_DEVICES]"); };

            struct MCV_T_VKPHYSICALDEVICEPROPERTIES d_p ={ 0 };
            struct MCV_T_VKPHYSICALDEVICEFEATURES   d_f ={ 0 };

            I32 y =( 0 ); //:Y:YES:Has feature.
            I32 n =( 0 ); //:N:NO :Missing Feature.

            for( I32 i = 0 ; i <= (NUM-1) ; i++ ){

                //: DEV is a void* opaque type:
                DEV = ARR[ i ];
                if( ((void*)0) == DEV ){ ERR("[NILDEV]"); }; 
                G_P( DEV , &( d_p ) );
                G_F( DEV , &( d_f ) );

                //:Todo: Make choice based on[ d_p ]&[ d_f ]

                //:Something Something Device PROPERTIES:

                    //:No Logic Here Yet.://

                //:Gather Number Of Active Device FEATURES:

                    for( I32 f = 0 ; f <=(55-1) ; f++ ){

                        if( 1 == d_f.data[ f ] ){ y++ ; }else
                        if( 0 == d_f.data[ f ] ){ n++ ; }else
                        {
                            ERR("[EXP:1_OR_ZERO]");
                        };; 
                    };;

                //:Is device suitable? (isDeviceSuitable):
                if( 1 == NUM || ( y > n ) ){
                    break; //:choosen device == DEV
                };;
            };;

            P_F( "\n"                                   );
            P_F( "[yes_features]:%d\n", y               );
            P_F( "[not_features]:%d\n", n               );
            P_F( "\n"                                   );
            MCV_F_P_VKPHYSICALDEVICEPROPERTIES( &(d_p)  );
            P_F( "\n"                                   );
        }
        if( NIL == DEV ){ ERR("[NIL_PHYSICAL_DEVICE]"); };
        #undef  G_P
        #undef  G_F
        #undef  ARR
        #undef  NUM
        #undef  DEV
        //:----------------------------------------:VIDEO_014://
        //:VIDEO_015:( KanjiCoder_IID_0338 ):----------------://
        #define GET_QFP MCV_F_G_QFP
        #define     ARR mcv_d_a_qfp
        #define     NUM mcv_d_n_qfp
        #define     CAP mcv_m_c_qfp
        #define     DEV mcv_d_o_phy_dev
        
            GET_QFP( DEV , &NUM ,   NIL     );
            if( NUM > CAP ){ ERR("[QFP_ARRAY_TOO_SMALL]"); };
            GET_QFP( DEV , &NUM , &(ARR[0]) );

            P_F( "[NUM_QFP]:%d\n" , NUM );
            P_F( "\n" );
            for( I32 i = 0 ; i <=( NUM-1 ) ; i++ ){

                if( ARR[ i ].q_f & 0x00000001 ){
                    P_F("\t[GOT_GRAPHICS]\n");
                    mcv_d_i_qfp_gra =( i );
                }else{
                    P_F("\t[not_graphics]\n");
                };;

                if( ARR[ i ].q_f & 0x00000002 ){
                    P_F("\t[GOT_COMPUTE]\n");
                    mcv_d_i_qfp_com =( i );
                }else{
                    P_F("\t[not_compute]\n");
                };;

                P_F( "\n" );
            };;

            P_F( "[mcv_d_i_qfp_gra]:%d\n" , mcv_d_i_qfp_gra );
            P_F( "[mcv_d_i_qfp_com]:%d\n" , mcv_d_i_qfp_com );
            P_F( "\n\n" );

        #undef  GET_QFP
        #undef      ARR 
        #undef      NUM 
        #undef      CAP
        #undef      DEV
        //:----------------------------------------:VIDEO_015://
        //:VIDEO_016:----------------------------------------://
        #define QCI struct MCV_T_VKDEVICEQUEUECREATEINFO
        #define D_V struct MCV_T_VKPHYSICALDEVICEFEATURES
        #define DCI struct MCV_T_VKDEVICECREATEINFO
        #define C_D MCV_F_VKCREATEDEVICE
        #define PHY mcv_d_o_phy_dev
        #define LOG mcv_d_log_dev

            //:QCI: Queue Create Info ( queueCreateInfo ) ://

            QCI qci =  { 0 };
            qci.typ =  ( 2 );  //:2==DEVICE_QUEUE_CREATE_INFO://
            qci.fam =  ( mcv_d_i_qfp_gra ); //:q_family_index://
            qci.q_p = &( mcv_d_q_p );     //:pQueuePriorities://
            qci.num =  (     1     );           //:queueCount://

            //:D_V: Specifiy[ deviceFeatures ]we will be using:

            D_V d_v = { 0 }; //:REQUESTING_NO_FEATURES://

            //:DCI: Device Create Info:

            DCI dci     ={ 0 };
            dci.typ     =( 3 /**sType:Device_Create_Info==3**/);
            dci.num_qci = 1;          //:queueCreateInfoCount://
            dci.arr_qci = &( qci );   //:pQueueCreateInfos   ://
            dci.fet     = &( d_v );   //:pEnabledFeatures    ://

            //: vkCreateDevice
            res = C_D(  PHY, &dci, NIL, &LOG  );
            CHK( res , "[C_D:vkCreateDevice]" );

        #undef  QCI
        #undef  D_V
        #undef  DCI
        #undef  C_D
        #undef  PHY
        #undef  LOG
        //:----------------------------------------:VIDEO_016://
        //:VIDEO_18:Win32_Window_002:------------------------://
        #define k32 mcv_d_lib_k32
        #define u32 mcv_d_lib_u32
        #define W_C struct mcv_t_wndclassexw
        #define DEF ((I32)0x80000000)        /**CW_USEDEFAULT**/

            //:REFERENCE[ <AAC>/AAC2020/LIB/GINAWIN.F._ ]://

            //:Misc Variables:

                VOD*  hin = k32.GetModuleHandleW( NIL );
                UNI*  nam = L"SAMPLE_WINDOW_CLASS";
                UNI*  txt = L"LEARN_TO_PROGRAM_WINDOWS"      ;
                U32   w_s = (U32)0x00CF0000 /**OVERLAPPED**/ ;

                if( NIL == hin ){ ERR("[FAIL:GMHW]"); };
                wprintf( L"[nam]:%ls\n" , nam );
                wprintf( L"[txt]:%ls\n" , txt );
        
            //:Window Class:

                W_C w_c = { 0 };
                w_c.cbSize = sizeof( W_C );
                w_c.lpfnWndProc   = (VOD*)&( mcv_f_windowproc );   
                w_c.hInstance     = hin              ;
                w_c.lpszClassName = nam              ;

            //:Register Window Class:

                u32.RegisterClassExW( &( w_c ) );

            //:Create Window:

                VOD* mcv_d_win = u32.CreateWindowExW(
                    //:ExtendedStyle,Class,Text,WindowStyle
                    0 , nam , txt , w_s
                    //: _X_ , _Y_ , WID , HIG - - - - - - - -://
                ,       DEF , DEF , DEF , DEF 

                    //:ParentWin,Menu,hin,ExtraAppData- - - -://
                ,       u32.GetDesktopWindow()   //:ParentWin://
                ,       NIL                      //:hMenu    ://
                ,       hin                      //:hInstance://
                ,       NIL                      //:lParam(?)://
                );;
                if( NIL == mcv_d_win ){ ERR("[WINFAIL]"); };

            //:Make Window Visible:

                u32.ShowWindow( 
                    mcv_d_win
                ,  (I32)1 /**nCmdShow==SW_NORMAL**/ 
                );;

        #undef  k32
        #undef  u32
        #undef  W_C
        #undef  DEF
        //:------------------------:VIDEO_18:Win32_Window_002://

    #undef  A_I
    #undef  ICI
    }

    VOD  MCF_F_TIK( VOD ){

        /** Tick Function. Once Per Frame. **/

        #define u32    mcv_d_lib_u32
        #define P_M u32.PeekMessageW
        #define MSG struct mcv_t_msg  
        #define WIN        mcv_d_win 
        #define REM        (U32)0x0001 /** PM_REMOVE **/

            //: Exit Once Drained. DON'T use "GetMessage"    ://
            //: Because "GetMessage" will block.             ://

            MSG msg = { 0 };
            while( P_M( &msg , WIN , 0 , 0 , REM ) > 0){

                u32.TranslateMessage( &msg );
                u32.DispatchMessageW( &msg );
            };;
 
        #undef  u32
        #undef  P_M
        #undef  MSG
        #undef  WIN
        #undef  REM
    }

    I32  MCV_F_DEM( VOD ){           //:Library_Demonstration://

        MCV_F_INI( ); 
        F_F( stdout );

        while( mcv_d_kot >= 1 ){

            MCF_F_TIK();
    
        };;
        P_F( "\n\n[Outside_Of_Window_Loop]\n\n\n" );

        return( 0 );
    }

//:================================================:FUNCTIONS://
//:FILE_MACROS:==============================================://

    #undef  ECI
    #undef  NIL  
    #undef  VOD  
    #undef  DLL  
    #undef  U08
    #undef  U16
    #undef  I32  
    #undef  U32 
    #undef  U64
    #undef  I64
    #undef  F32
    #undef  CHR 
    #undef  UNI
    #undef  NCC
    #undef  ERR  
    #undef  SAY  
    #undef  CHK  
    #undef  RES   
    #undef  GI3 
    #undef  G00
    #undef  P_F
    #undef  F_F
    #undef  S_A
    #undef  S_O
    #undef  SIZ 

    #undef  VEP
    #undef  PDL
    #undef  DSP

//:==============================================:FILE_MACROS://
//:SHORTHAND_COMMENTS:=======================================://

//:     MWM : Monkey Wrench Macro
//:     KOT : Keep_On_Ticking

//:=======================================:SHORTHAND_COMMENTS://
/** LONGHAND_COMMENTS ************************************** ***

    #_DO_NOT_POPULATE_FPS_USING_HELPER_FUNCTIONS_#

        Do not use helper function to populate function
        pointer structs for different DLL files.
        Reasoning: Creates spaghetti code. Do not create
        helper functions that are only called once.
        Makes it harder to understand the linear narrative
        when reading code from top to bottom.


*** ************************************** LONGHAND_COMMENTS **/

