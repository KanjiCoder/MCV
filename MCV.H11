//[CODING_STYLE|=============================================]//
//[                                                          ]//
//[ Namespaces:                                              ]//
//[                                                          ]//
//[     1. All global tokens begin with "MCV_".              ]//
//[     2. All global tokens have a category namespace.      ]//
//[         MCV_F : Function                                 ]//
//[         MCV_D : Data (AKA: Variable)                     ]//
//[         MCV_U : Unit Test                                ]//
//[         MCV_T : Type                                     ]//
//[         MCV_M : Macro                                    ]//
//[     3. Public  tokens all   capital. EX: MCV_F_WHATEVER  ]//
//[     4. Private tokens all lowercase. EX: mcv_f_whatever  ]//
//[     5. DONT MIX CAPITAL & LOWERCASE: This_Is_Not_Allowed ]//
//[                                                          ]//
//[ Sub_Namespaces:                                          ]//
//[                                                          ]//
//[     mcv_d_n : Number Of (Usually For Array)              ]//
//[     mcv_d_c : Capacity Of Array                          ]//
//[     mcv_d_a : Array Itself                               ]//
//[                                                          ]//
//[     mcv_d_c : c for "create info"                        ]//
//[     mcv_d_o : o for "object" belonging to "create info"  ]//
//[                                                          ]//
//[=============================================|CODING_STYLE]//
//|FUNCTION_INDEX:===========================================|//
//|                                                          |//
//| mcv_f_err  : ERRor (Halts Program Execution)             |//
//| mcv_f_log  : LOG   (Informational Message  )             |//
//| mcv_f_chk  : CHecK (Check Validity Of Something)         |//
//| mcv_f_gpa  : Get_Proc_Address (Generic)                  |//
//| mcv_f_gpav : Get_Proc_Address (Vulkan )                  |//
//|                                                          |//
//|===========================================:FUNCTION_INDEX|//
//:INCLUDES:=================================================://

    #include "stdio.h"           //:fflush( stdout ) , printf://
    #include "stdint.h"          //:int32_t , uint32_t , etc ://
    #include "libloaderapi.h"  //:LoadLibraryA,GetProcAddress://
    #include <stdlib.h>                           //: exit() ://
                             
//:=================================================:INCLUDES://
//:FILE_MACROS:==============================================://

//: Basic File Macros ://

    #define NIL ((void*)0)
    #define VOD   void
    #define DLL   void
    #define I32  int32_t
    #define U32 uint32_t
    #define CHR const char
    #define NCC       char
    #define ERR mcv_f_err
    #define LOG mcv_f_log
    #define CHK mcv_f_chk
    #define RES int32_t                      //:VkResult Type://
    #define FUN MCV_T_FUN                 //:Generic_Function://
    #define P_F printf
    #define F_F fflush

//: Vulkan Macros To Keep Stuff Terse ://

    #define VEP struct MCV_T_VKEXTENSIONPROPERTIES

//:==============================================:FILE_MACROS://
//:MACROS:===================================================://

    #define mcv_m_num_ext ( 2 )       //:Number_Of_Extensions://

    #define mcv_m_men  ( 256U ) //:VK_MAX_EXTENSION_NAME_SIZE://

    #define mcv_m_c_ins_ext ( 32 ) //: Capacity:InstanceExts ://

//:===================================================:MACROS://
//:TYPES:====================================================://

    typedef I32 ( MCV_T_FUN )(  );   //:Generic_Function_Type://

//:====================================================:TYPES://
//:TYPES_VULKAN:=============================================://

//:VkStructureType://

    //: typedef I32 MCV_T_VKSTRUCTURETYPE ;

//:VkInstanceCreateFlags://

    //: typedef U32 MCV_T_VKINSTANCECREATEFLAGS

//:VkApplicationInfo://

    struct MCV_T_VKAPPLICATIONINFO {
              I32                    sType;
        const VOD*                   pNext;
              CHR*        pApplicationName;
              U32       applicationVersion;
              CHR*             pEngineName;
              U32            engineVersion;
              U32               apiVersion;
    };

//:VkInstanceCreateInfo://

    struct MCV_T_VKINSTANCECREATEINFO {

        I32                                           sType;

        const void*                                   pNext;

        U32                                           flags;

        const struct MCV_T_VKAPPLICATIONINFO*     
                                           pApplicationInfo;

        uint32_t                          enabledLayerCount;

        const char* const*              ppEnabledLayerNames;

        uint32_t                      enabledExtensionCount;

        const char* const*          ppEnabledExtensionNames;
    };

//:VkAllocationCallbacks://
                
    /** typedef void MCV_T_VKALLOCATIONCALLBACKS **/      

//:VkInstance://
            
    /** typedef void MCV_T_VKINSTANCE **/ 

//:VkExtensionProperties://

    struct MCV_T_VKEXTENSIONPROPERTIES {
        NCC  ext_nam[ mcv_m_men ];           //:extensionName://
        U32  spe_ver             ;           //:specVersion  ://
    };
    
//:=============================================:TYPES_VULKAN://
//:DATA:=====================================================://

    //:DLL:--------------------------------------------------://

        DLL* mcv_d_dll_vul = ((DLL*)0);

    //:--------------------------------------------------:DLL://
    //:VULKAN_MISC:------------------------------------------://

        //:FOR: VkEnumerateInstanceExtensionProperties://
        
            //:ins_ext == Instance_Extensions

            #define  mcv_m_c_ins_ext ( 32 )    
            VEP      mcv_d_a_ins_ext[ mcv_m_c_ins_ext ]={0};
            U32      mcv_d_n_ins_ext =( 0 ); 
            #define  mcv_d_c_ins_ext [USE:mcv_m_c_ins_ext]
            
        //:FOR: ppEnabledExtensionNames://

            CHR* mcv_d_arr_ext[ mcv_m_num_ext ]={
            /** ******************************************** ***                                 
            *** www.khronos.org/registry/vulkan/specs/       ***
            *** 1.2-khr-extensions/html/chap47.html          ***
            ***                                              ***
            *** Also: Cross Checked: GLFW Library            ***
            *** glfwGetRequiredInstanceExtensions            ***
            *** _glfwPlatformGetRequiredInstanceExtensions   ***
            *** ******************************************** **/

                "VK_KHR_surface"
            //: "VK_KHR_swapchain"                <-- DEVICE_EXT 
            ,   "VK_KHR_win32_surface"

            //: "VK_KHR_external_memory_win32"  
            //: "VK_KHR_win32_keyed_mutex"  
            //: "VK_KHR_external_semaphore_win32"  
            //: "VK_KHR_external_fence_win32" 
            };

    //:------------------------------------------:VULKAN_MISC://
    //:VULKAN_OBJECTS:---------------------------------------://
    #define ICI struct MCV_T_VKINSTANCECREATEINFO 
    #define A_I struct MCV_T_VKAPPLICATIONINFO

        A_I  mcv_d_applicationinfo ={ 0 };
         
        ICI  mcv_d_c_instance  ={   0   };
        VOD* mcv_d_o_instance  =((VOD*)0);

    #undef  ICI
    #undef  A_I
    //:---------------------------------------:VULKAN_OBJECTS://

//:=====================================================:DATA://
//:FUNCTIONS_BASIC:==========================================://

    VOD  mcv_f_err( CHR* msg ){
        P_F( "[mcv_f_err]:%s" , msg );
        F_F( stdout );
        exit( 0xFF );
    }

    VOD  mcv_f_log( CHR* msg ){
        P_F( "[mcv_f_log]:%s" , msg );
        F_F( stdout );
    }

    VOD  mcv_f_chk( I32  res , CHR* msg ){
    #define P P_F
    #define B break

        if( 0 != res ){ 
            P_F( "[chk_fail:res]:%d\n" , res );
            P_F( "[chk_fail:msg]:%s\n" , msg );

            switch( res ){
            case (0-7) : P("[EXTENSION_NOT_PRESENT]\n"); B;
            default:
            };;

            ERR("[FAILED_CHECK]");
        }else
        if( 0 == res ){ 
            P_F( "[chk_pass:res]:%d\n" , res );
            P_F( "[chk_pass:msg]:%s\n" , msg );
        };;

    #undef  P
    #undef  B
    }

    FUN* mcv_f_gpa( DLL* dll , CHR* nam ){

        if( ((DLL*)0) == dll ){ ERR("[NIL:DLL]"); };
        if( ((CHR*)0) == nam ){ ERR("[NIL:NAM]"); };

        FUN* fun = (FUN*)GetProcAddress( dll , nam );
        if( ((FUN*)0) == fun ){
            P_F("[NAME_OF_FUNCTION]:%s\n" , nam );
            ERR("[GPA_FAIL]:%s\n");
        };;
        return( fun );
    }

    FUN* mcv_f_gpav( CHR* nam ){

        DLL* dll =( mcv_d_dll_vul );
        if( ((DLL*)0) == dll ){ ERR("[GPAV_001:DLL]"); };
        if( ((CHR*)0) == nam ){ ERR("[GPAV_002:NAM]"); };
        FUN* fun =mcv_f_gpa( dll , nam );
        return( fun );
    }

//:==========================================:FUNCTIONS_BASIC://
//:FUNCTIONS_VULKAN:=========================================://
//:VULKAN_FUNCTIONS:=========================================://

//: vkCreateInstance ://

    RES MCV_F_VKCREATEINSTANCE(
        const struct MCV_T_VKINSTANCECREATEINFO*                 
                                            pCreateInfo 
    ,   const VOD*                           pAllocator 
    ,   VOD*                                 pInstance
    ){
        FUN* fun = mcv_f_gpav( "vkCreateInstance" );
        return( fun( pCreateInfo,pAllocator,pInstance ) );
    }

//: VK_MAKE_VERSION ( vmv ) ://

    U32 mcv_f_vmv( U32 maj , U32 min , U32 pat ){
        U32 out =( ((U32)0)
        |   ( maj << 22 )
        |   ( min << 12 )
        |   ( pat <<  0 )
        );;
        return( out );
    }

//: VK_MAKE_API_VERSION ( mav ) ://

    U32 mcv_f_mav( U32 var , U32 maj , U32 min , U32 pat ){
        U32 out =( ((U32)0)
        |   ( var << 29 )
        |   ( maj << 22 )
        |   ( min << 12 )
        |   ( pat <<  0 )
        );;
        return( out );
    }
    
//: vkEnumerateInstanceExtensionProperties ( EIEP ) ://

    RES MCV_F_EIEP(
        CHR*    N                  //: Name : pLayerName     ://
    ,   U32*    C                  //: Count: pPropertyCount ://
    ,   VEP*    A                  //: Array: pProperties    ://
    ){
        FUN* fun =mcv_f_gpav( 
        "vkEnumerateInstanceExtensionProperties" );;
        return( fun( N,C,A ) );
    };;

//:=========================================:FUNCTIONS_VULKAN://
//:=========================================:VULKAN_FUNCTIONS://
//:FUNCTIONS:================================================://

    DLL* mcv_f_dll_get( CHR* nam ){

        DLL* dll = LoadLibraryA( nam );
        if( ((DLL*)0) == dll ){
            ERR( "[FAILED_TO_LOAD_DLL]" );
        };;
        return( dll );
    }

    DLL* mcv_f_dll_all( VOD ){

        mcv_d_dll_vul = mcv_f_dll_get( "vulkan-1.dll" );

    }

    VOD  MCV_F_INI( VOD ){              //:Initialize Library://
    #define A_I mcv_d_applicationinfo
    #define ICI mcv_d_c_instance
    
        //:Declare_Variables:

            RES res =( 0 );

        //:Load_All_Libraries:

            mcv_f_dll_all( );               

        //:Checking_For_Extension_Support:

            #define NUM mcv_d_n_ins_ext
            #define ARR mcv_d_a_ins_ext
            #define CAP mcv_m_c_ins_ext
            
                res = MCV_F_EIEP( NIL , &NUM , NIL );
                CHK( res , "[MCV_F_EIEP:GET_NUM]"  );
                if( NUM > CAP ){ ERR("[NUM>CAP]"); };
                if( NUM <= 0  ){ ERR("[NUM<=00]"); };
          
                res = MCV_F_EIEP( NIL, &(NUM) , &( ARR[ 0 ] ) );
                CHK( res , "[MCV_F_EIEP:GET_ARR]"  );

                P_F("[mcv_d_n_ins_ext]:%d\n", NUM );
                for( I32 i = 0 ; i <= (NUM-1) ; i++ ){
                    P_F( 
                        "ARR[%2d]( %42s )\n"
                    ,        i
                    ,   &( ARR[ i ].ext_nam[ 0 ] )
                    );;
                };;

            #undef  NUM  
            #undef  ARR  
            #undef  CAP  

        //:VkApplicationInfo:

            A_I.sType =( 0 );
            A_I.pApplicationName   ="[Hello Triangle]"    ;
            A_I.applicationVersion = mcv_f_vmv(   1, 0, 0);
            A_I.pEngineName        ="[No Engine]"         ;
            A_I.engineVersion      = mcv_f_vmv(   1, 0, 0);
            A_I.apiVersion         = mcv_f_mav(0, 1, 2, 0);

        //:VkInstanceCreateInfo:
        
            ICI.sType                   = (  1  )      ;
            ICI.pApplicationInfo        =&( A_I )      ;
            ICI.enabledExtensionCount   = mcv_m_num_ext;
            ICI.ppEnabledExtensionNames = mcv_d_arr_ext;
            ICI.enabledLayerCount       = 0            ;
        
        res = MCV_F_VKCREATEINSTANCE(
            &( mcv_d_c_instance )
        ,    (       0          )      //:AllocationCallbacks://          
        ,   &( mcv_d_o_instance )
        );;

        CHK( res , "[Instance_Create]" );


        P_F("[todo:code_here_for_init]\n");

    #undef  A_I
    #undef  ICI
    }

    I32  MCV_F_DEM( VOD ){           //:Library_Demonstration://

        MCV_F_INI( );

        return( 0 );
    }

//:================================================:FUNCTIONS://
//:FILE_MACROS:==============================================://

    #undef  NIL  
    #undef  VOD  
    #undef  DLL  
    #undef  I32  
    #undef  U32  
    #undef  CHR 
    #undef  NCC
    #undef  ERR  
    #undef  LOG  
    #undef  CHK  
    #undef  RES   
    #undef  FUN   
    #undef  P_F
    #undef  F_F

    #undef  VEP

//:==============================================:FILE_MACROS://

