//[MACROS_CONFIGURATION:=====================================]//
//[CONFIGURATION_MACROS:=====================================]//

    #define mcv_m_eci ( 1 )        //:ECI:Error_Check_Inputs ://
    #define mcv_m_eco ( 1 )        //:ECO:Error_Check_Outputs://

    //:**************************************************:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:TODO: [If/When] code starts to mysteriously crash,:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      create your own validation for all of the   :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      vulkan function calls and then prey that    :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:      you discover a problem.                     :// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    //:**************************************************:// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//[=====================================:MACROS_CONFIGURATION]//
//[=====================================:CONFIGURATION_MACROS]//
//[CODING_STYLE|=============================================]//
//[                                                          ]//
//[ Namespaces:                                              ]//
//[                                                          ]//
//[     1. All global tokens begin with "MCV_".              ]//
//[     2. All global tokens have a category namespace.      ]//
//[         MCV_F : Function                                 ]//
//[         MCV_D : Data (AKA: Variable)                     ]//
//[         MCV_U : Unit Test                                ]//
//[         MCV_T : Type                                     ]//
//[         MCV_M : Macro                                    ]//
//[     3. Public  tokens all   capital. EX: MCV_F_WHATEVER  ]//
//[     4. Private tokens all lowercase. EX: mcv_f_whatever  ]//
//[     5. DONT MIX CAPITAL & LOWERCASE: This_Is_Not_Allowed ]//
//[                                                          ]//
//[ Sub_Namespaces:                                          ]//
//[                                                          ]//
//[     mcv_d_n : Number Of (Usually For Array)              ]//
//[     mcv_d_c : Capacity Of Array                          ]//
//[     mcv_d_a : Array Itself                               ]//
//[                                                          ]//
//[     mcv_d_c : c for "create info"                        ]//
//[     mcv_d_o : o for "object" belonging to "create info"  ]//
//[                                                          ]//
//[=============================================|CODING_STYLE]//
//|FUNCTION_INDEX:===========================================|//
//|                                                          |//
//|     mcv_f_err     : ERRor (Halts Program Execution)      |//
//|     mcv_f_say     : SAY   (Informational Message  )      |//
//|     mcv_f_chk     : CHecK (Check Validity Of Something)  |//
//|     mcv_f_gpa     : Get_Proc_Address (Generic  )         |//
//|     mcv_f_gpa_vul : Get_Proc_Address (Vulkan   )         |//
//|     mcv_f_gpa_g32 : Get_Proc_Address (GDI32    )         |//
//|     mcv_f_gpa_u32 : Get_Proc_Address (USER32   )         |//
//|     mcv_f_gpa_k32 : Get_Proc_Address (KERNEL32 )         |//
//|                                                          |//
//|===========================================:FUNCTION_INDEX|//
//+ALL_OTHER_TOKENS_INDEX:===================================+//
//+                                                          +//
//+             rie : Required__Instance_Extensions          +//
//+             aie : Available_Instance_Extensions          +//
//+                                                          +//
//+     mcv_m_n_rie : num_rie : Number Of [rie]              +//
//+     mcv_d_a_rie : arr_rie : Array  Of [rie]              +//
//+                                                          +//
//+     mcv_d_n_aie : num_aie : Number Of [aie]              +//
//+     mcv_d_a_aie : arr_aie : Array  Of [aie]              +//
//+                                                          +//
//+===================================|ALL_OTHER_TOKENS_INDEX+//
//:INCLUDES:=================================================://

    #include "stdio.h"           //:fflush( stdout ) , printf://
    #include "stdint.h"          //:int32_t , uint32_t , etc ://
    #include "libloaderapi.h"  //:LoadLibraryA,GetProcAddress://
    #include <stdlib.h>                           //: exit() ://
                             
//:=================================================:INCLUDES://
//:MACRO_COLLISION_CHECK:====================================://

    #if defined( OUT )
        //: We can't use "OUT" because used by GCC I think?  ://
    #endif

//:====================================:MACRO_COLLISION_CHECK://
//:FILE_MACROS:==============================================://

//: MISC_FILE_MACROS ://

    #define PUBLIC_FUNCTION       /** FOR SELF DOCUMENTATION **/
    #define PRIVATE_FUNCTION      [DONT_USE_MOST_THINGS_PRIVATE]

//: MONKEY_WRENCH_MACROS ://

    #define num_qci [BAD_NAME:USE_GENERAL_TO_SPECIFIC:qci_num]
    #define arr_qci [BAD_NAME:USE_GENERAL_TO_SPECIFIC:qci_arr]
  
    #define num_lay [BAD_NAME:USE_GENERAL_TO_SPECIFIC:lay_num]
    #define arr_lay [BAD_NAME:USE_GENERAL_TO_SPECIFIC:lay_arr]
    
    #define num_ext [BAD_NAME:USE_GENERAL_TO_SPECIFIC:ext_num]
    #define arr_ext [BAD_NAME:USE_GENERAL_TO_SPECIFIC:ext_arr]

    #define mcv_f_dll_all [JUST_INLINE_THE_LOGIC]  //: @MWM@ ://

    #define QFC_NUM [YOU_MEAN( QFI_NUM | QCI_NUM )]

//: Basic_File_Macros ://

    //: #define   H(nam) mcv_d_h_##nam
    //: #define   A mcv_lib_dat.arr
    //: #define   N mcv_lib_dat.num
    //: #define   I mcv_lib_dat.ind
    //: #define   C mcv_lib_dat.cap
    //: #define   O mcv_lib_dat.obj

    #define ECI mcv_m_eci 
    #define ECO mcv_m_eco
    #define NIL ((void*)0)
    #define VOD   void
    #define DLL   void
    #define U08  uint8_t
    #define U16 uint16_t  
    #define I32  int32_t
    #define U32 uint32_t
    #define U64 uint64_t
    #define I64  int64_t  
    #define F32 float
    #define CHR const char                  //:Ascii___String://
    #define UNI const wchar_t               //:Unicode_String://
    #define NCC       char                  //:Mutable_Ascii ://
    #define ERR mcv_f_err
    #define SAY mcv_f_say
    #define CHK mcv_f_chk
    #define ASS mcv_f_ass
    #define RES int32_t                    //:VkResult Type  ://
    #define GI3 MCV_T_GI3                  //:GenericFunc:I32://
    #define G00 MCV_T_G00                  //:GenericFunc:VOD://
    #define P_F printf
    #define F_F fflush
    #define S_A _Static_assert 
    #define S_O sizeof
    #define SIZ size_t

//: Vulkan_Macros_To_Keep_Stuff_Terse ://

    //: VEP == "Vulkan_Extension_Properties" ://
    //: PDL == "Physical_Device_Limits"      ://
    //: DSP == "Device_Sparse_Properties"    ://

    #define VEP struct mcv_t_vkextensionproperties
    #define PDL struct mcv_t_vkphysicaldevicelimits
    #define DSP struct mcv_t_vkphysicaldevicesparseproperties

    S_A( sizeof( U32 ) == 4 );
    S_A( sizeof( I32 ) == 4 );
    S_A( sizeof( U08 ) == 1 );

//:==============================================:FILE_MACROS://
//:MACROS:===================================================://

    //: rie : RequiredInstanceExtensions :- - - - - - - - - -://
    //: aie : AvailableInstanceExtensions( ins_ext ) :- - - -://
    //: men : VK_MAX_EXTENSION_NAME_SIZE :- - - - - - - - - -://
    //: mpd : VK_MAX_PHYSICAL_DEVICE_NAME_SIZE :- - - - - - -://
    //: uid : VK_UUID_SIZE :- - - - - - - - - -:- - - - - - -://

        //: Arrays Of Strings ://

            #define       mcv_m_n_rie ( 2 )   //: Number:rie ://
            extern  CHR*  mcv_d_a_rie[  2 ] ; //: Array :rie ://
            #define       mcv_d_n_rie [USE:mcv_m_n_rie]

            #define       mcv_m_n_rde ( 1 )   //: Number:rde ://
            extern  CHR*  mcv_d_a_rde[  1 ] ; //: Array :rde ://
            #define       mcv_d_n_rde [USE:mcv_m_n_rde]

        //: Max Values And Indexes ://

            #define mcv_m_men     ( 256U )         //: [men] ://
            #define mcv_m_mpd     ( 256U )         //: [mpd] ://
            #define mcv_m_uid     (  16U )         //: [uid] ://

        //: Capacities Of Arrays ://

            #define mcv_m_c_rie [NO_CAPACITY_SIZE_KNOWN]
            #define mcv_m_c_rde [NO_CAPACITY_SIZE_KNOWN]
            #define mcv_m_c_aie     ( 32 )      //: Capacity ://
            #define mcv_m_c_ade     ( 256)      //: Capacity ://
            #define mcv_m_c_phy (  8 )      //: Capacity ://
            #define mcv_m_c_qfp     ( 16 )      //: Capacity ://
            #define mcv_m_c_qfi     (  3 )      //: Capacity ://
            #define mcv_m_c_sur_fmt ( 16 )      //: Capacity ://
            #define mcv_m_c_sur_pre ( 16 )      //: Capacity ://

//:===================================================:MACROS://
//:TYPES:====================================================://

    typedef VOD* ( MCV_T_G00 )(  );  //:Generic_Function_Type://
    typedef I32  ( MCV_T_GI3 )(  );  //:Generic_Function_Type://

    //:Function_Pointer_Structs:-----------------------------://

        //:WIN32:Function_Pointer_Structs:- - - - - - - - - -://

            struct mcv_t_lib_g32{
                GI3* ChoosePixelFormat ;
                GI3* GetStockObject    ;
                GI3* SetPixelFormat    ;
                GI3* SwapBuffers       ;
            };

            struct mcv_t_lib_u32{
                G00* CreateWindowExW   ;
                GI3* DefWindowProcW    ;
                GI3* DestroyWindow     ;
                GI3* DispatchMessageW  ;
                GI3* GetClientRect     ;
                G00* GetDesktopWindow  ;
                GI3* GetWindowDC       ;
                GI3* LoadCursorA       ;
                GI3* LoadIconA         ;
                GI3* MessageBoxW       ;
                GI3* PeekMessageW      ;
                GI3* PostQuitMessage   ;
                GI3* RegisterClassExW  ;
                GI3* SetFocus          ;
                GI3* ShowWindow        ;
                GI3* TranslateMessage  ;
                GI3* UpdateWindow      ;
            };

            struct mcv_t_lib_k32{
                /** We might not need kernel32 since doing **/
                /** window on a single thread.             **/

                G00* GetModuleHandleW ;
            };

        //:- - - - - - - - - -:WIN32:Function_Pointer_Structs://

    //:-----------------------------:Function_Pointer_Structs://

//:====================================================:TYPES://
//:WIN32_WINDOW_TYPES:=======================================://

    #define CON const
    #define TYP struct mcv_t_wndclassexw

        struct mcv_t_wndclassexw {
                U32   cbSize       ;
                U32   style        ;
                GI3*  lpfnWndProc  ;
                I32   cbClsExtra   ;
                I32   cbWndExtra   ;
                VOD*  hInstance    ;
                VOD*  hIcon        ;
                VOD*  hCursor      ;
                VOD*  hbrBackground;
            CON U16*  lpszMenuName ;
            CON U16*  lpszClassName;
                VOD*  hIconSm      ;
        };
        S_A( S_O( TYP ) == 80 , "[mcv_t_wndclassexw]" );

    #undef  CON
    #undef  TYP
    #define P_T struct mcv_t_point

        //:[ wtypes.h ]://

            struct mcv_t_point {
                I32 x ;
                I32 y ;
            };

        //:[ winuser.h ]&[ wtypes.h ]://

            struct mcv_t_msg {
                VOD*    hwnd;
                U32  message;
                U64   wParam;   
                I64   lParam;   
                U32     time;  
                P_T       pt;
            };

    #undef  P_T
    #define OBLIGATORY_DEFINE_FOR_FORMATTING

        struct mcv_t_rect{

            I32 lef  ;                            //: left   ://
            I32 top  ;                            //: top    ://
            I32 rig  ;                            //: right  ://
            I32 bot  ;                            //: bottom ://
        };

    #undef  OBLIGATORY_DEFINE_FOR_FORMATTING



//:=======================================:WIN32_WINDOW_TYPES://
//:VULKAN_CORE_TYPES:========================================://
//:                                                          ://
//: #VULKAN_TYPES# #TYPES_VULKAN# #VULKAN_HEADER_TYPES#      ://
//:                                                          ://
//:- - - - - - - - - - - - - - -- - - - - - - - - - - - - - -://

//:VkStructureType://

    //: typedef I32 MCV_T_VKSTRUCTURETYPE ;

//:VkInstanceCreateFlags://

    //: typedef U32 MCV_T_VKINSTANCECREATEFLAGS

//:VkApplicationInfo://

    struct mcv_t_vkapplicationinfo {
              I32       typ;           //:             sType ://
        const VOD*      nex;           //:             pNext ://
                                       
              CHR*  app_nam;           //:  pApplicationName ://
              U32   app_ver;           //:applicationVersion ://
                                       
              CHR*  eng_nam;           //:       pEngineName ://
              U32   eng_ver;           //:     engineVersion ://
                                       
              U32   api_ver;           //:        apiVersion ://
    };
    S_A( sizeof( struct mcv_t_vkapplicationinfo ) == 48 );

//:VkInstanceCreateInfo://

    #define CON const
    #define C_I struct mcv_t_vkinstancecreateinfo
    #define A_I struct mcv_t_vkapplicationinfo
    #define CCC const char* const*

        struct mcv_t_vkinstancecreateinfo {

            I32      typ ;   //: sType                       ://
        CON VOD*     nex ;   //: pNext                       ://
            U32      c_f ;   //: VkInstanceCreateFlags flags ://
                             
        CON A_I*     a_i ;   //: pApplicationInfo            ://
                                                             
            U32  lay_num ;   //: enabledLayerCount           ://
            CCC  lay_arr ;   //: ppEnabledLayerNames         ://
                             
            U32  ext_num ;   //: enabledExtensionCount       ://
            CCC  ext_arr ;   //: ppEnabledExtensionNames     ://
        };
        S_A( S_O( C_I ) == 64 );

    #undef  CON
    #undef  C_I
    #undef  A_I
    #undef  CCC

//:VkAllocationCallbacks://
                
    /** typedef void mcv_t_vkallocationcallbacks **/      

//:VkInstance://
            
    /** typedef void mcv_t_vkinstance **/ 

//:VkExtensionProperties://

    struct mcv_t_vkextensionproperties {
        NCC  ext_nam[ mcv_m_men ];           //:extensionName://
        U32  spe_ver             ;           //:specVersion  ://
    };
    S_A( sizeof( struct mcv_t_vkextensionproperties ) == 260 );
    S_A( sizeof( VEP )                                == 260 );

//:VkPhysicalDevice://

    /** **************************************************** **/
    /** DONT CREATE: typedef void MCV_T_VKPHYSICALDEVICE     **/
    /** Just use void* when you want VkPhysicalDevice        **/
    /** Documentation: VK_DEFINE_HANDLE(VkPhysicalDevice)    **/
    /** **************************************************** **/

//:VkPhysicalDeviceType://

    //:------------------------------------------------------://
    //: I find enums kind of useless, so just use a I32      ://
    //: whenever a member variable or parameter says         ://
    //: that it is an enum.                                  ://
    //:------------------------------------------------------://

    //:------------------------------------------------------://
    //:  // Provided by VK_VERSION_1_0                       ://
    //:  enum mcv_t_vkphysicaldevicetype {                   ://
    //:      VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,              ://
    //:      VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,     ://
    //:      VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,       ://
    //:      VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,        ://
    //:      VK_PHYSICAL_DEVICE_TYPE_CPU = 4,                ://
    //:  };                                                  ://
    //:------------------------------------------------------://

//:VkPhysicalDeviceLimits ( PDL ) ://

    //: This struct has about 106 (+-1) members.
    //: That is a lot of bloat. So in our code rather than
    //: paste all of that bloat, we will just make a struct
    //: that has the correct size in bytes of the vulkan
    //: header type[ VkPhysicalDeviceLimits ].
    struct mcv_t_vkphysicaldevicelimits{
        U08 data[ 504 ];
    };
    S_A( sizeof( struct mcv_t_vkphysicaldevicelimits ) == 504 );
    S_A( sizeof( PDL )                                 == 504 );

//:VkPhysicalDeviceSparseProperties://

    struct mcv_t_vkphysicaldevicesparseproperties {
    
        //: rs == "residencyStandard"
        //: re == "residencyExtra" (NOT residencyStandard)

        //: residencyStandard2DBlockShape
        U32 rs_2DBlockShape              ;

        //: residencyStandard2DMultisampleBlockShape 
        U32 rs_2DMultisampleBlockShape   ;

        //: residencyStandard3DBlockShape:
        U32 rs_3DBlockShape              ;

        //: residencyAlignedMipSize
        U32 re_AlignedMipSize            ;

        //: residencyNonResidentStrict
        U32 re_NonResidentStrict         ;
    };
    S_A( S_O( struct mcv_t_vkphysicaldevicesparseproperties ) 
                                                        == 20 );
    S_A( S_O( DSP ) == 20 );

//:VkPhysicalDeviceProperties://

    S_A( sizeof( I32 ) == 4 );
    struct mcv_t_vkphysicaldeviceproperties {
        U32            apiVersion             ;     //:   4  ://
        U32         driverVersion             ;     //:   4  ://
                                                    //:      ://
        U32              vendorID             ;     //:   4  ://
        U32              deviceID             ;     //:   4  ://
                                                    //:      ://
        I32           deviceType              ;     //:   4  ://
                                                    //:      ://
        NCC            deviceName[ mcv_m_mpd ];     //: 256  ://
        U08     pipelineCacheUUID[ mcv_m_uid ];     //:  16  ://
                                                    //:      ://                                      
        U08 pad_001[ 4 ]                      ;              
        PDL                limits             ;     //: 504  ://
        DSP      sparseProperties             ;     //:  20  ://
        U08 pad_002[ 4 ]                      ;
    };
    S_A( (4+4 + 4+4 + 4 + 256+16 + 504+20)             == 816 );
    S_A( S_O( struct mcv_t_vkphysicaldeviceproperties )!= 816 );

    S_A( (816 + 4 + 4 )                                == 824 );
    S_A( S_O( struct mcv_t_vkphysicaldeviceproperties )== 824 ); 

//:VkPhysicalDeviceFeatures

    //:------------------------------------------------------://
    //: Used TWICE:                                          ://
    //:                                                      ://
    //: 1st: To QUERY   physical device      FEATURES.       ://
    //: 2nd: To REQUEST physical device with FEATURES.       ://
    //:                                                      ://
    //: 1st: VT/../Setup/Physical_devices_and_queue_families ://
    //: 2nd: VT/../Setup/Logical_device_and_queues           ://
    //:------------------------------------------------------://

    S_A( 8 * 220 == 32 * 55 );
    struct mcv_t_vkphysicaldevicefeatures {
        //: U08 data[ 220 ];
        U32 data[ 55 ]; //:<--SizeOf[ VkBool32 ]://
    };
    S_A( S_O( struct mcv_t_vkphysicaldevicefeatures ) == 220 );

//:VkQueueFlags

    /** VkQueueFlags is a typedef for uint32_t **/
    /** Just use U32 to reduce abstraction.    **/

//:VkExtent3D

    #define E3D struct mcv_t_vkextent3d

        struct mcv_t_vkextent3d{
            U32 wid ; //: width  ://
            U32 hig ; //: height ://
            U32 dep ; //: depth  ://
        };
        S_A( S_O( E3D ) == 12 , "[E3D]" );

    #undef  E3D

//:VkQueueFamilyProperties

    #define E3D struct mcv_t_vkextent3d
    #define QFP struct mcv_t_vkqueuefamilyproperties

        struct mcv_t_vkqueuefamilyproperties{
            U32 q_f ;        //: queueFlags                  ://
            U32 num ;        //: queueCount                  ://
            U32 tim ;        //: timestampValidBits          ://
            E3D min ;        //: minImageTransferGranularity ://
        };
        S_A( S_O( QFP ) == 24 , "[QFP]" );

    #undef  EXT
    #undef  QFP

//:VkDeviceQueueCreateFlags

    /** Typedef resolves to U32 , so use U32. **/

//:VkDeviceQueueCreateInfo 

    #define C_I struct mcv_t_vkdevicequeuecreateinfo

        // Provided by VK_VERSION_1_0
        struct mcv_t_vkdevicequeuecreateinfo {
                  I32    typ ;    //: sType                  ://
            const VOD*   nex ;    //: pNext                  ://
                  U32    c_f ;    //: flags ( create flags ) ://
                  U32    fam ;    //: queueFamilyIndex       ://
                  U32    num ;    //: queueCount             ://
            const F32*   q_p ;    //: pQueuePriorities       ://
        };
        S_A( S_O( C_I ) == 40 , "[D_Q_C_I]" );

    #undef  C_I

//:VkDevice ( logical device ):

    /** Do not create this. It is just a void pointer. **/
    /** SEE: mcv_d_o_log *************************** **/

//:VkDeviceCreateFlags:

    /** Resolves to a U32 for bit packing flags. **/
    /** So just use   U32.                       **/

//:VkDeviceCreateInfo: (LogicalDevice):

    #define DCI struct mcv_t_vkdevicecreateinfo
    #define C_I struct mcv_t_vkdevicequeuecreateinfo
    #define LIS const char* const* //:Immutable List://
    #define FET struct mcv_t_vkphysicaldevicefeatures

        struct mcv_t_vkdevicecreateinfo {
                  I32       typ; //: sType                   ://
            const VOD*      nex; //: pNext                   ://
                  U32       c_f; //: flags                   ://
                        
                  U32   qci_num; //: queueCreateInfoCount    ://
            const C_I*  qci_arr; //: pQueueCreateInfos       ://
                                                    
                  U32   lay_num; //: enabledLayerCount       ://
                  LIS   lay_arr; //: ppEnabledLayerNames     ://
                                     
                  U32   ext_num; //: enabledExtensionCount   ://
                  LIS   ext_arr; //: ppEnabledExtensionNames ://

            const FET*      fet; //: pEnabledFeatures        ://
        };
        S_A( S_O( DCI ) == 72 , "[CHECKSUM_DCI]" );

    #undef  DCI
    #undef  C_I
    #undef  LIS
    #undef  FET

//:VkAllocationCallbacks:

    #define C_B struct mcv_t_vkallocationcallbacks

        struct mcv_t_vkallocationcallbacks {
            U64 data[ 6 ];   //:Six Pointer Members In Struct://
        };
        S_A( S_O( C_B ) == 48 , "[CHECKSUM:C_B]" );

    #undef  C_B

//:VkSurfaceKHR://

    /** Just use void pointer because is defined as opaque.  **/

//:VkWin32SurfaceCreateFlagsKHR://
    
    /** Just Use U32 because that's what it resolves to. **/

//:VkWin32SurfaceCreateInfoKHR://

    #define W_S struct mcv_t_vkwin32surfacecreateinfokhr

        // Provided by VK_KHR_win32_surface
        struct mcv_t_vkwin32surfacecreateinfokhr{
                  I32   typ;                //: sType        ://
            const VOD*  nex;                //: pNext        ://
                  I32   c_f;                //: Create_Flags ://
                  VOD*  exe;                //: hInstance    ://
                  VOD*  win;                //: hwnd         ://
        };
        S_A( S_O( W_S ) == 40 , "[win32_surf_size]" );
    
    #undef  W_S

//: VkQueue ://

    /** Use void* because: VK_DEFINE_HANDLE(VkQueue) **/

//: VkDeviceQueueCreateInfo ://
//
//  WE ALREADY MADE THIS TYPE. THOUGH I LIKE THE FORMATTING
//  HERE MORE. MAYBE REFACTORE AND USE THIS LATER?
//
//  #define CON const
//  #define TMP struct mcv_t_vkdevicequeuecreateinfo
//   
//      struct mcv_t_vkdevicequeuecreateinfo {
//                  I32     typ ;       //: sType            ://
//          CON     VOD*    nex ;       //: pNext            ://
//                  U32     c_f ;       //: flags            ://
//                  U32     dex ;       //: queueFamilyIndex ://
//                  U32     num ;       //: queueCount       ://
//          CON     F32*    q_p ;       //: pQueuePriorities ://
//      };
//      S_A( S_O( TMP ) == 40 , "[VK_DQCI]" );
//
//  #undef  CON
//  #undef  TMP

//: SwapChainSupportDetails(SCSD) ://

    //:VIDEO_023:--------------------------------------------://
    //:******************************************************://
    //:                                                      ://
    //:   Unlike VulkanTutorial.com , we are not going to    ://
    //:   create a "SwapChainSupportDetails" helper struct.  ://
    //:                                                      ://
    //:******************************************************://
    //:SCSD:Dependency_Cascade:------------------------------://

        //: SCSD:VkExtent2D ://

            #define TYP struct mcv_t_vkextent2d

                    struct mcv_t_vkextent2d {
                        U32  wid ;
                        U32  hig ;
                    };
                    S_A( S_O( TYP ) == 8 , "[VKE2D]" );

            #undef  TYP

        //: SCSD:VkFormat ://

            //: Enum. So Just Use[ I32 ] ://

        //: SCSD:VkColorSpaceKHR ://

            //: Enum. So Just Use[ I32 ] ://

    //:------------------------------:SCSD:Dependency_Cascade://
    //:SCSD:Main_Struct_Members:-----------------------------://

        //: SCSD:VkSurfaceCapabilitiesKHR : - - - - - - - - -://
        #define E2D struct mcv_t_vkextent2d
        #define TYP struct mcv_t_vksurfacecapabilitieskhr

            struct mcv_t_vksurfacecapabilitieskhr {
                U32         img_min      ; //: minImageCount ://
                U32         img_max      ; //: maxImageCount ://
                                           
                E2D         ext_cur      ; //: currentExtent ://
                E2D         ext_min      ; //: minImageExtent://
                E2D         ext_max      ; //: maxImageExtent://

                U32         tra_has ; //: supportedTransforms://
                U32         tra_cur ; //: currentTransform   ://

                U08         therest[ 12 ]; //:Idontgiveafuck ://

            //  U08         therest[ 20 ]; //:IDontGiveAFuck ://
            };
            S_A( 52-4-4-8-8-8     == 20 , "[52_4_4_8_8_8]" );
            S_A( 52-4-4-8-8-8-4-4 == 12 , "[52_44_888_44]" );
            S_A( S_O( TYP )       == 52 , "[VKSCKHR]"      );

        #undef E2D
        #undef TYP

        //: SCSD:VkSurfaceFormatKHR ::::::: - - - - - - - - -://
        #define TYP struct mcv_t_vksurfaceformatkhr

            struct mcv_t_vksurfaceformatkhr {
                I32 fmt ;   //: VkFormat format              ://
                I32 col ;   //: VkColorSpaceKHR  colorSpace  ://
            };
            S_A( S_O( TYP ) == 8 , "[VKSFKHR]" );

        #undef TYP

        //: SCSD:VkPresentModeKHR ::::::::: - - - - - - - - -://

            //: Enum. So Just Use[ I32 ] ://
    
    //:-----------------------------:SCSD:Main_Struct_Members://
    //:--------------------------------------------:VIDEO_023://
    //:VIDEO_024:createSwapChain:----------------------------://

        //: VkSurfaceTransformFlagBitsKHR ://
    
            //: Bitmask , just use U32 ://

        //: VkCompositeAlphaFlagBitsKHR   ://

            //: Bitmaks , just use U32 ://

        //:VkSwapchainKHR://

            //: Opaque Type, use void* ://

        //:VkSwapchainCreateInfoKHR://

        #define CON const
        #define E2D struct mcv_t_vkextent2d
        #define TYP struct mcv_t_vkswapchaincreateinfokhr

            struct mcv_t_vkswapchaincreateinfokhr{
                    I32       typ ; //: sType                ://
                CON VOD*      nex ; //: pNext                ://
                    U32       c_f ; //: Create_Flags         ://
                    VOD*      sur ; //: VkSurfaceKHR         ://
                           
                    U32    img_min; //:minImageCount         ://
                    I32    img_fmt; //:imageFormat           ://
                    I32    img_col; //: imageColorSpace      ://
                    E2D    img_ext; //: imageExtent          ://
                    U32    img_lay_001; //:imageArrayLayers  ://
                    U32    img_use; //: imageUsage           ://
                    I32    img_s_m; //: imageSharingMode     ://
                           
                    U32    qfi_num; //: queueFamilyIndexCount://
                CON U32*   qfi_arr; //: pQueueFamilyIndices  ://
                           
                    U32    tra_pre; //: preTransform         ://
                    U32    com_alp; //: compositeAlpha       ://
                    I32    pre_mod; //: VkPresentModeKHR     ://
                    U32    clipped; //: VkBool32             ://
                    VOD*   oldchan; //: oldSwapChain         ://
            };
            S_A( S_O( TYP ) == 104 , "[SCCI]" );

        #undef  CON
        #undef  E2D
        #undef  TYP

    //:----------------------------:VIDEO_024:createSwapChain://
    
//: VkImage ://

    //: Just use VOD* because :                    ://
    //: VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkImage) ://

//: VkImageViewType ://

    //: Just use I32 because ENUM ://

//: VkComponentSwizzle ://

    //: Just use I32 because ENUM ://

//: VkComponentMapping ://

    //: Just use I32[4] instead of struct ://

//:  VkImageAspectFlags ://
    
    //: Just use U32 because it's array of bitflags. ://

//: VkImageSubresourceRange : ( VIDEO_027 ) ://

    #define TYP struct mcv_t_vkimagesubresourcerange

        struct mcv_t_vkimagesubresourcerange{

            U32 asp_msk ; //: apsectMask           ://
                                                   
            U32 mip_bas ; //: baseMipLevel         ://
            U32 mip_num ; //: levelCount / mip_lev ://

            U32 lay_bas ; //: baseArrayLayer       ://
            U32 lay_num ; //: layerCount / lay_lev ://
        };
        S_A( S_O( TYP ) == 20 , "[VKISRR]" );

    #undef  TYP

//: VkImageViewCreateInfo : ( VIDEO_027 ) ://

    #define TYP struct mcv_t_vkimageviewcreateinfo
    #define RNG struct mcv_t_vkimagesubresourcerange

        struct mcv_t_vkimageviewcreateinfo {
            I32    typ    ;       //: sType                  ://
            VOD*   nex    ;       //: pNext                  ://
            U32    c_f    ;       //: VkImageViewCreateFlags ://
            VOD*   img    ;       //: VkImage                ://
            I32    v_t    ;       //: VkImageViewType        ://
            I32    fmt    ;       //: VkFormat               ://
            I32    com[4] ;       //: VkComponentMapping     ://
            RNG    rng    ;       //: VkImageSubresourceRange://
        };
        S_A( S_O( TYP ) == 80 , "[VKIVCI]" );

    #undef  TYP
    #undef  RNG
    

//:========================================:VULKAN_CORE_TYPES://
//:DATA:=====================================================://

    //:MISC_DATA:--------------------------------------------://

        I32 mcv_d_kot =( 1 );          //:KOT:Keep_On_ticking://

    //:--------------------------------------------:MISC_DATA://
    //:DLL:--------------------------------------------------://
    
        //:Vulkan DLL(s):

            DLL* mcv_d_dll_vul = ((DLL*)0);

        //: Microsoft Windows Window DLL(s):                 ://

            DLL* mcv_d_dll_g32 = ((DLL*)0); //:"gdi32.dll"   ://
            DLL* mcv_d_dll_u32 = ((DLL*)0); //:"kernel32.dll"://
            DLL* mcv_d_dll_k32 = ((DLL*)0); //:"user32.dll"  ://

    //:--------------------------------------------------:DLL://
    //:FPS:FUNCTION_POINTER_STRUCTS:=========================://

        //: #_DO_NOT_POPULATE_FPS_USING_HELPER_FUNCTIONS_#   ://

        struct mcv_t_lib_g32 mcv_d_lib_g32 ={ 0 };
        struct mcv_t_lib_u32 mcv_d_lib_u32 ={ 0 };
        struct mcv_t_lib_k32 mcv_d_lib_k32 ={ 0 };

    //:=========================:FPS:FUNCTION_POINTER_STRUCTS://
    //:WIN32_DATA:-------------------------------------------://

        VOD* mcv_d_exe = ((VOD*)0); //:hInstance ://
        VOD* mcv_d_win = ((VOD*)0); //:hwnd      ://

    //:-------------------------------------------:WIN32_DATA://
    //:VULKAN_MISC:(Not Vulkan Object Instances):------------://

        //:EXTENSIONS:- - - - - - - - - - - - - - - - - - - -://
    
            //: [aie] : Available_Instance_Extensions
            //: [rie] : Required__Instance_Extensions
            //: [ade] : Available___Device_Extensions
            //: [rde] : Required____Device_Extensions

            //::instance_extensions: : : : : : : : : : : : : ://

                //:FOR:VkEnumerateInstanceExtensionProperties://
                
                    //:ins_ext ==           Instance_Extensions
                    //:    aie == Available_Instance_Extensions

                    #define  mcv_m_c_aie                ( 32 )    
                    VEP      mcv_d_a_aie[ mcv_m_c_aie ]={  0 };
                    U32      mcv_d_n_aie               =(  0 ); 
                    #define  mcv_d_c_aie [USE:mcv_m_c_aie]
                    #define  mcv_m_n_aie [USE:mcv_d_n_aie]
                    
                //:FOR: ppEnabledExtensionNames://

                    CHR* mcv_d_a_rie[ mcv_m_n_rie ]={
                        "VK_KHR_surface"
                    ,   "VK_KHR_win32_surface"
                    };  //:#_HOW_DID_I_DECIDE_ON_RIE_#://

            //:: : : : : : : : : : : : : :instance_extensions://
            //:device_extensions:: : : : : : : : : : : : : : ://

                //:FOR:vkEnumerateDeviceExtensionProperties  ://
        
                    #define  mcv_m_c_ade                ( 256)    
                    VEP      mcv_d_a_ade[ mcv_m_c_ade ]={  0 };
                    U32      mcv_d_n_ade               =(  0 ); 
                    #define  mcv_d_c_ade [USE:mcv_m_c_ade]
                    #define  mcv_m_n_ade [USE:mcv_d_n_ade]
                
                //:FOR:cross checking to see if we have what
                //:    we require.

                    CHR* mcv_d_a_rde[ mcv_m_n_rde ]={
                        "VK_KHR_swapchain"  
                    };

            //:: : : : : : : : : : : : : : :device_extensions://

        //:- - - - - - - - - - - - - - - - - - - -:EXTENSIONS://

        //: FOR: VkDeviceQueueCreateInfo

            const F32 mcv_d_q_p =( 1.0 );  //: queuePriority ://

        //: FOR: uniqueQueueFamilies :

            #define mcv_d_c_qfi [USE_MACRO:mcv_m_c_qfi]
            #define mcv_m_c_qfi                  ( 3 )
            U32     mcv_d_a_qfi[ mcv_m_c_qfi ]  ={ 0 };
            U32     mcv_d_n_qfi                 =( 0 );

        //: FOR: VIDEO_024 : createSwapChain

            I32 mcv_d_n_img ; //:SwapChainImageCount://
                              //:[mcv_d_img_num]    ://
            

    //:------------------------------------------:VULKAN_MISC://
    //:VULKAN_OBJECTS:---------------------------------------://
    #define ICI struct mcv_t_vkinstancecreateinfo 
    #define A_I struct mcv_t_vkapplicationinfo
    #define QFP struct mcv_t_vkqueuefamilyproperties

        //:Application_Info:

            A_I   mcv_d_applicationinfo ={ 0 };   
 
        //:Vulkan_Instance :

            ICI   mcv_d_c_instance  ={   0   };
            VOD*  mcv_d_o_instance  =((VOD*)0);

        //: Physical_Device:( phy ):- - - - - - - - - - -://
        //:     m_c : Macro_Capacity                         ://
        //:     d_a : Data__Array                            ://
        //:     d_n : Data__NumberOf( in array )             ://
        //:     d_o : Data__Object( Choosen Physical Device )://

            #define  mcv_m_c_phy (  8 ) 
            VOD*     mcv_d_a_phy[ mcv_m_c_phy ];
            U32      mcv_d_n_phy =( 0 );
            VOD*     mcv_d_o_phy =( NIL ); 
            #define    mcv_d_phy [USE:mcv_d_o_phy]

        //: queueFamilies for the given Physical_Device:- - -://

            #define  mcv_d_c_qfp [USE:mcv_m_c_qfp]
            #define  mcv_m_c_qfp (  16 )  
            QFP      mcv_d_a_qfp[ mcv_m_c_qfp ];
            U32      mcv_d_n_qfp =( 0 );

            I32      mcv_d_i_qfp_com =( 0 - 1 );  //:COMPUTE ://
            I32      mcv_d_i_qfp_gra =( 0 - 1 );  //:GRAPHICS://
            I32      mcv_d_i_qfp_pre =( 0 - 1 );  //:PRESENT ://
            
        //: Logical_Device: ( log ):- - - - - - - - - - - - -://

            VOD*     mcv_d_o_log =( NIL );
            #define  mcv_d_o_log_dev [USE:mcv_d_o_log]

        //: Surface:- - - - - - - - - - - - - - - - - - - - -://
        
            #define C_I struct mcv_t_vkwin32surfacecreateinfokhr
            #define OBJ VOD
        
                //: mcv_d_c_sur =VkWin32SurfaceCreateInfoKHR ://
                //: mcv_d_o_sur =VkSurfaceKHR                ://

                C_I  mcv_d_c_sur ={ 0 }    ;   
                OBJ* mcv_d_o_sur =((VOD*)0);  

            #undef  C_I
            #undef  OBJ

        //: Queue:- - - - - - - - - - - - - - - - - - - - - -://
        #define QCI struct mcv_t_vkdevicequeuecreateinfo

            //: VkQueue(s): Compute,Graphics,Present:        ://
            
                //:      d_q_*** == data_queue_[com|gra|pre] ://
                VOD* mcv_d_q_com =(NIL);    //: computeQueue ://
                VOD* mcv_d_q_gra =(NIL);    //: graphicsQueue://
                VOD* mcv_d_q_pre =(NIL);    //: presentQueue ://

            //:ARRAY: VkDeviceQueueCreateInfo( qci )

                #define mcv_m_c_qci ( 3 )
                #define mcv_d_c_qci [USE_MACRO:mcv_m_c_qci]
                QCI     mcv_d_a_qci[ mcv_m_c_qci ] ={ 0 };
                I32     mcv_d_n_qci                =( 0 );

                S_A( mcv_m_c_qci == mcv_m_c_qfi , "[QCI:QFI]" );

        #undef  QCI

        //: SurfaceCapabilities:- - - - - - - - - - - - - - -://

            #define TYP struct mcv_t_vksurfacecapabilitieskhr
            
                TYP mcv_d_o_cap ={ 0 };

            #undef  TYP

        //: SurfaceFormats::- - - - - - - - - - - - - - - - -://

            #define TYP struct mcv_t_vksurfaceformatkhr

                #define mcv_m_c_sur_fmt ( 16 )
                I32     mcv_d_n_sur_fmt                     ;
                TYP     mcv_d_a_sur_fmt[ mcv_m_c_sur_fmt ]  ;
                #define mcv_d_c_sur_fmt [USE:mcv_m_c_sur_fmt]
                I32     mcv_d_i_sur_fmt =( 0 - 1 ); //:PICKED://
                TYP     mcv_d_o_sur_fmt ={   0   }; //:PICKED://

            #undef  TYP

        //: PresentModes::- - - - - - - - - - - - - - - - - -://

            #define TYP I32 /**mcv_t_vkpresentmodekhr**/

                #define mcv_m_c_sur_pre ( 16 )
                I32     mcv_d_n_sur_pre                     ;
                TYP     mcv_d_a_sur_pre[ mcv_m_c_sur_pre ]  ;
                #define mcv_d_c_sur_pre [USE:mcv_m_c_sur_pre]
                I32     mcv_d_i_sur_pre =( 0 - 1 ); //:PICKED://
                TYP     mcv_d_o_sur_pre =( 0 -666); //:PICKED://

            #undef  TYP

        //: SwapChainExtent:- - - - - - - - - - - - - - - - -://

            #define TYP struct mcv_t_vkextent2d

                TYP  mcv_d_o_swa_ext ={ 0 }; //: Obj:swa_ext ://
                I32  mcv_d_h_swa_ext =( 0 ); //: Has:swa_ext ://

            #undef  TYP

        //: VIDEO_024:createSwapChain:- - - - - - - - - - - -://

            #define C_I struct mcv_t_vkswapchaincreateinfokhr
            #define OBJ VOD

                C_I  mcv_d_c_swa = { 0 };
                VOD* mcv_d_o_swa = (NIL);

            #undef  C_I
            #undef  OBJ

        //: VIDEO_025:GetSwapChainImages::- - - - - - - - - -://

            //: Array Of VkImage      ://
            //: SCI == SwapChainImage ://

            #define  mcv_m_c_sci ( 8 )
            #define  mcv_d_c_sci [USE:mcv_m_c_sci]
            U32      mcv_d_n_sci =( 0 );
            VOD*     mcv_d_a_sci[ mcv_m_c_sci ];

        //: VIDEO_026: StoreFormatAndExtent:- - - - - - - - -://

            #define EXT extern
            #define E2D struct mcv_t_vkextent2d

                     I32     mcv_d_o_swa_fmt =( 0 - 1 );
                EXT  E2D     mcv_d_o_swa_ext ;  
            
            #undef  EXT
            #undef  E2D

        //: VIDEO_027: imageviews:- - - - - - - - - - - - - -://
        //:   swapChainImageViews:- - - - - - - - - - - - - -://

            #define              mcv_d_c_siv [USE:mcv_m_c_siv]
            #define              mcv_m_c_siv ( 8 )
            VOD*    mcv_d_a_siv[ mcv_m_c_siv ]={ 0 };
            U32     mcv_d_n_siv               =( 0 );

    #undef  ICI
    #undef  A_I
    #undef  QFP
    //:---------------------------------------:VULKAN_OBJECTS://

//:=====================================================:DATA://
//:DATA_LIBS:================================================://
//: struct mcv_lib_has{  
//:  
//: 
//: }has;struct mcv_lib_arr{  
//:                             VOD* siv[ mcv_d_c_siv ]; 
//: 
//: }arr;struct mcv lib_num{  
//:  
//: 
//: }num;struct mcv_lib_ind{ 
//: 
//: }ind;struct mcv_lib_cap{   
//:                             I32  siv ;
//: 
//: }cap;struct mcv_lib_obj{  
//: 
//: 
//: 
//: }obj;
//: 
//: 
//: struct mcv_lib_dat_struct{
//:     struct mcv_lib_has has ;
//:     struct mcv_lib_arr arr ;
//:     struct mcv_lib_num num ;
//:     struct mcv_lib_ind ind ;
//:     struct mcv_lib_cap cap ;
//:     struct mcv_lib_obj obj ;
//: }mcv_lib_dat={ 0 };

//:================================================:DATA_LIBS://
//:FUNCTIONS_BASIC:==========================================://

    VOD  mcv_f_err( CHR* msg ){
        P_F( "\n\n\n\n[mcv_f_err]:%s \n\n\n\n\n" , msg );
        F_F( stdout );
        exit( 0xFF );
    }

    VOD  mcv_f_say( CHR* msg ){
        P_F( "[mcv_f_say]:%s \n" , msg );
        F_F( stdout );
    }

    VOD  mcv_f_chk( I32  res , CHR* msg ){
    #define P P_F
    #define B break

        if( 0 != res ){ 
            P_F( "[chk_fail:res]:%d\n" , res );
            P_F( "[chk_fail:msg]:%s\n" , msg );

            switch( res ){
            case (0-7) : P("[EXTENSION_NOT_PRESENT]\n"); B;
            default:
            };;

            ERR("[FAILED_CHECK]");
        }else
        if( 0 == res ){ 
            P_F( "[chk_pass:res]:%d\n" , res );
            P_F( "[chk_pass:msg]:%s\n" , msg );
        };;

    #undef  P
    #undef  B
    }

    VOD  mcv_f_ass( U32 t_f  , CHR* msg ){
        if( 0 == t_f ){
            P_F( "[MCV_ASSERT_FAIL:MSG]:%s" , msg );
            ERR( "[MCV_ASSERT_FAIL:SEE_ABOVE]"    );
        };;
    }

    VOD  mcv_f_n_c( VOD* obj , CHR* msg ){
        if( NIL == obj ){ 

            P_F( "[FAIL:N_C]:%s\n"  ,  msg                  ); 
            ERR( "[FAIL:N_C]:[SEE_ABOVE_TRACEBACK_MESSAGE]" );
        };;
    }

    //:GPA_Basic:--------------------------------------------://

        GI3* mcv_f_gpa( DLL* dll , CHR* nam ){

            if( ((DLL*)0) == dll ){ ERR("[NIL:DLL]"); };
            if( ((CHR*)0) == nam ){ ERR("[NIL:NAM]"); };

            GI3* fun = (GI3*)GetProcAddress( dll , nam );
            if( ((GI3*)0) == fun ){
                P_F("[NAME_OF_FUNCTION]:%s\n" , nam );
                ERR("[FAILED:mcv_f_gpa]\n");
            };;
            return( fun );
        }

    //:--------------------------------------------:GPA_Basic://
    //:GPA_Specific:-----------------------------------------://

        //:GPA: VULKAN DLL://

            GI3* mcv_f_gpa_vul( CHR* nam ){

                DLL* dll =( mcv_d_dll_vul );
                if( ((DLL*)0) == dll ){ ERR("[VUL_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[VUL_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: GDI32 DLL://

            GI3* mcv_f_gpa_g32( CHR* nam ){

                DLL* dll =( mcv_d_dll_g32 );
                if( ((DLL*)0) == dll ){ ERR("[G32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[G32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: USER32 DLL://

            GI3* mcv_f_gpa_u32( CHR* nam ){

                DLL* dll =( mcv_d_dll_u32 );
                if( ((DLL*)0) == dll ){ ERR("[U32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[U32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

        //:GPA: KERNEL32 DLL://

            GI3* mcv_f_gpa_k32( CHR* nam ){

                DLL* dll =( mcv_d_dll_k32 );
                if( ((DLL*)0) == dll ){ ERR("[K32_DLL]"); };
                if( ((CHR*)0) == nam ){ ERR("[K32_NAM]"); };
                GI3* fun =mcv_f_gpa( dll , nam );
                return( fun );
            }

    //:-----------------------------------------:GPA_Specific://
    //:MISC_HELPER_FUNCS:------------------------------------://

        U32 mcv_f_cur_min_max(
            U32 cur
        ,   U32 min
        ,   U32 max
        ){
            //:VIDEO_023://

            if( min > max ){ ERR("[MIN>MAX]"); };
            if( max < min ){ ERR("[MAX<MIN]"); };

            if( cur < min ){ cur = min ; };
            if( cur > max ){ cur = max ; };

            return( cur );
        }

        U32 mcv_f_strcmp( CHR* s_1 , CHR* s_2 ){

            U32 same=( 1 );

            while( 1 ){

                if( *s_1 != *s_2 ){ same=( 0 ); break; };
                if( 0 == *s_1    ){ break; };
                if( 0 == *s_2    ){ break; };
                s_1++;
                s_2++;
            };;

            return( same );
        }


    //:MISC_HELPER_FUNCS:------------------------------------://

//:==========================================:FUNCTIONS_BASIC://
//:FUNCTIONS_DEBUGGING:======================================://

    I32 mcv_f_cra(          //: CRA: Compute_Relative_Address://
        VOD*  a_s           //: Address Of Struct.           ://
    ,   VOD*  a_m           //: Address Of Member.          ://
    ){
        I32  act =  (I32)( a_m - a_s );
        return( act );
    }

    VOD mcv_f_ara(          //: ARA: Assert_Relative_Address ://
        VOD* a_s            //: Address Of Struct.           ://
    ,   VOD* a_m            //: Address Of Member.           ://
    ,   I32  rel            //: Relative Address Of Member   ://
    ,   CHR* msg            //: On Error Message             ://
    ){
        I32  act =  mcv_f_cra( a_s , a_m );
        if(  act != rel ){
            P_F( "[ARA_FAIL:MSG]:%s\n" , msg );
            ERR( "[FAIL:ASSERT_RELATIVE_ADDRESS(ARA)]" );
        };;
    }

//:======================================:FUNCTIONS_DEBUGGING://
//:FUNCTIONS_WIN32:==========================================://
//:WIN32_FUNCTIONS:==========================================://
#define REC mcv_t_rect
#define u32 mcv_d_lib_u32

    #define MCV_F_WIN_WID [USE:MCV_F_G_WIN_WID]
    #define MCV_F_WIN_HIG [USE:MCV_F_G_WIN_HIG]

    I32 MCV_F_G_WIN_WID( VOD ){ //: VIDEO_023:GET_WINDOW_WID ://

        struct REC rec ={ 0 };
        u32.GetClientRect( mcv_d_win , &rec );
        I32 wid = ( rec.rig - rec.lef  ) + 0;  //:#_EXC_REC_#://             
    }                               
                                    
    I32 MCV_F_G_WIN_HIG( VOD ){ //: VIDEO_023:GET_WINDOW_HIG ://
        struct REC rec ={ 0 };
        u32.GetClientRect( mcv_d_win , &rec );
        I32 wid = ( rec.bot - rec.top  ) + 0;  //:#_EXC_REC_#://
    }

#undef  REC
#undef  u32
//:==========================================:FUNCTIONS_WIN32://
//:==========================================:WIN32_FUNCTIONS://
//:FUNCTIONS_VULKAN:=========================================://
//:VULKAN_FUNCTIONS:=========================================://
#define GET mcv_f_gpa_vul

//: vkCreateInstance ://

    RES mcv_f_vkcreateinstance(
        const struct mcv_t_vkinstancecreateinfo*                 
                                            pCreateInfo 
    ,   const VOD*                           pAllocator 
    ,   VOD*                                 pInstance
    ){
        GI3* fun = GET( "vkCreateInstance" );
        return( (RES)fun( pCreateInfo,pAllocator,pInstance ) );
    }

//: VK_MAKE_VERSION ( vmv ) ://

    U32 mcv_f_vmv( U32 maj , U32 min , U32 pat ){
        U32 out =( ((U32)0)
        |   ( maj << 22 )
        |   ( min << 12 )
        |   ( pat <<  0 )
        );;
        return( out );
    }

//: VK_MAKE_API_VERSION ( mav ) ://

    U32 mcv_f_mav( U32 var , U32 maj , U32 min , U32 pat ){
        U32 out =( ((U32)0)
        |   ( var << 29 )
        |   ( maj << 22 )
        |   ( min << 12 )
        |   ( pat <<  0 )
        );;
        return( out );
    }
    
//: vkEnumerateInstanceExtensionProperties ( EIEP ) ://

    RES mcv_f_eiep(
        CHR*    N                  //: Name : pLayerName     ://
    ,   U32*    C                  //: Count: pPropertyCount ://
    ,   VEP*    A                  //: Array: pProperties    ://
    ){
        GI3* fun =GET( "vkEnumerateInstanceExtensionProperties" );;
        return( fun( N,C,A ) );
    }

//: vkEnumeratePhysicalDevices ( EPD ) ://

    RES mcv_f_epd(
        VOD*  I //: VkInstance                               ://
    ,   U32*  N //: NumberOf:Devices ( pPhysicalDeviceCount )://
    ,   VOD** A //: Array_Of:Devices ( pPhysicalDevices     )://
    ){
        GI3* fun =GET( "vkEnumeratePhysicalDevices" );
        return( (RES)fun( I,N,A ) );
    }

//: vkGetPhysicalDeviceProperties ://

    #define TMP struct mcv_t_vkphysicaldeviceproperties

        VOD mcv_f_vkgetphysicaldeviceproperties(
            VOD* phy
        ,   TMP*     pdp
        ){
            GI3* fun =GET( "vkGetPhysicalDeviceProperties" );
            fun( phy , pdp );
        }
    #undef  TMP

//: vkGetPhysicalDeviceFeatures ://

    #define TMP struct mcv_t_vkphysicaldevicefeatures

        VOD mcv_f_vkgetphysicaldevicefeatures(
            VOD* phy
        ,   TMP*     pdf
        ){
            GI3* fun =GET( "vkGetPhysicalDeviceFeatures" );
            fun( phy , pdf );
        }
    #undef  TMP

//: PRINT: PhysicalDeviceProperties:

    VOD mcv_f_p_vkphysicaldeviceproperties(
        struct mcv_t_vkphysicaldeviceproperties * pdp
    ){
        /** mcv_f_p : MCVnamespace_Function_Print **/

        P_F( "[apiVersion]:%d\n"        , (*pdp).apiVersion   );
        P_F( "[driverVersion]:%d\n"     , (*pdp).driverVersion);
        P_F( "[vendorID]:%d\n"          , (*pdp).vendorID     );
        P_F( "[deviceID]:%d\n"          , (*pdp).deviceID     );
        P_F( "[deviceType]:%d\n"        , (*pdp).deviceType   );
                                                        
        P_F( "[deviceName]:%s\n"        , (*pdp).deviceName   );

        P_F( "[pipelineCacheUUID]:%s\n" , "[SKIP_PRINTING]"   );
        P_F( "[limits]:%s\n"            , "[SKIP_PRINTING]"   );
        P_F( "[sparseProperties]:%s\n"  , "[SKIP_PRINTING]"   );
    }

//: vkGetPhysicalDeviceQueueFamilyProperties ://

    #define DEV VOD*   //: MCV_T_VKPHYSICALDEVICE ://
    #define QFP struct     mcv_t_vkqueuefamilyproperties

        VOD mcv_f_g_qfp(
            DEV  phy //: VkPhysicalDevice physicalDevice ://
        ,   U32* qfp_num //: pQueueFamilyPropertyCount       ://
        ,   QFP* qfp_arr //: VkQueueFamilyProperties*        ://
                         //: pQueueFamilyProperties          ://
        ){
            GI3* fun =GET( 
                "vkGetPhysicalDeviceQueueFamilyProperties" );;
            fun( phy , qfp_num , qfp_arr );
        }
    #undef  DEV
    #undef  QFP

//: vkCreateDevice (LogicalDevice) ://

    #define DCI struct mcv_t_vkdevicecreateinfo
    #define C_B struct mcv_t_vkallocationcallbacks
    #define CON const

        RES mcv_f_vkcreatedevice(
                VOD*      phy             //: physicalDevice ://
        ,   CON DCI*      dci             //: pCreateInfo    ://
        ,   CON C_B*  nil_001             //: pAllocator     ://
        ,       VOD*      log             //: pDevice        ://
        ){
            if( ECI >= 1 ){
                //:Hackish Validation:
                if( NIL == phy       ){ ERR("[NIL_PHY]"); };
                if(  3  != dci -> typ){ ERR("[DCI_TYP]"); };
                if( NIL != nil_001   ){ ERR("[NIL!001]"); };
                if( NIL == log       ){ ERR("[NIL_LOG]"); };

                //:Make absolutely fucking sure that
                //:"VK_KHR_swapchain" is in our list.
                I32            ext_num = dci -> ext_num ;
                CHR* const*    ext_arr = dci -> ext_arr ;
                CHR*           ext_cur ; //:Current_Extension://
                CHR*           ext_tar =( "VK_KHR_swapchain" );  
                I32            ext_has =( 0 );

                for( I32 i = 0 ; i <= ( ext_num-1 ); i++ ){
                    ext_cur=ext_arr[i];
                    if( mcv_f_strcmp( ext_cur , ext_tar ) ){
                        ext_has++;
                    };;
                    P_F( "[ext_cur]:%s\n" , ext_cur );
                };;

                if( 1 != ext_has ){
                    ERR("[NO__SWAPCHAIN_SUPPORT_IN_LIST]");
                    
                }else{
                    SAY("[yes:swapchain_support_in_list]");
                };;
            };;

            GI3* fun =GET( "vkCreateDevice" );
            RES  res = ( (RES)fun( phy , dci , nil_001 , log ));
            if( 0 != res ){ ERR("[028]"); };

            return( res );
        };

    #undef  DCI
    #undef  C_B
    #undef  CON

//: vkCreateWin32SurfaceKHR ://

    #define CON const
    #define C_I struct mcv_t_vkwin32surfacecreateinfokhr
    #define C_B struct mcv_t_vkallocationcallbacks

        RES mcv_f_vkcreatewin32surfacekhr(
                VOD*    v_i      //: (vulkan)instance        ://
        ,   CON C_I*    c_i      //: pCreateInfo             ://
        ,   CON C_B*    c_b      //: pAllocator              ://
        ,       VOD*    out      //: VkSurfaceKHR : pSurface ://
        ){
            GI3* fun = GET( "vkCreateWin32SurfaceKHR" );

            if( ECI >= 1 ){  //:- - - - - - - - - - - - - - -://

                if( ((VOD*)0) == v_i ){ ERR("[cw32s:v_i]"); };
                if( ((VOD*)0) == c_i ){ ERR("[cw32s:c_i]"); };
                if( ((VOD*)0) != c_b ){ ERR("[cw32s:c_b]"); };
                if( ((VOD*)0) == out ){ ERR("[cw32s:out]"); };

                //:VK_STRUCTURE_TYPE_...
                //:            WIN32_SURFACE_CREATE_INFO_KHR ://
                if( (*c_i).typ != 1000009000 ){ 
                    ERR("[cw32s:(*c_i).typ]" ); };;

            };; //:- - - - - - - - - - - - - - - - - -( ECI )://

            SAY( "[BEFORE_CALL:vkCreateWin32SurfaceKHR]" );

            RES res = (RES)fun( v_i , c_i , c_b , out  );

            SAY( "[AFTER__CALL:vkCreateWin32SurfaceKHR]" );

            return( (res) );
        }

    #undef  CON
    #undef  C_I
    #undef  C_B

//: vkGetPhysicalDeviceSurfaceSupportKHR ://

    RES mcv_f_g_phy_ssk(
        VOD*    phy                 //: PhysicalDevice       ://
    ,   U32     qfi                 //: queueFamilyIndex     ://
    ,   VOD*    sur                 //: surface              ://
    ,   U32*    out                 //: VkBool32*:pSupported ://
    ){
        GI3* fun = GET( "vkGetPhysicalDeviceSurfaceSupportKHR" );
        return( (RES)fun( phy , qfi , sur , out  ) );
    }

//: vkGetDeviceQueue ://

    VOD mcv_f_vkgetdevicequeue(
        VOD*     log            //:LogicalDevice             ://
    ,   U32      qfi            //:queueFamilyIndex          ://
    ,   U32      _0_            //:#_queueIndex_ZERO_ALWAYS_#://
    ,   VOD*     out            //:VkQueue : pQueue          ://
    ){
        if( ECI >= 1 ){
            if( NIL ==          log  ){ ERR("[LOG]"        ); };
            if( qfi  >           64  ){ ERR("[#_064_QFI_#]"); };
            if( _0_ !=            0  ){ ERR("[NOT_ZERO]"   ); };
            if( NIL ==          out  ){ ERR("[GDQ:@NDP@]"  ); };
            if( NIL != *((VOD**)out) ){ ERR("[004]"        ); };
        };;

        GI3* fun = GET( "vkGetDeviceQueue" );;
        fun( log , qfi , _0_ , out  );
    }

//: vkEnumerateDeviceExtensionProperties ://

    #define E_P struct mcv_t_vkextensionproperties

        RES mcv_f_vkenumeratedeviceextensionproperties(
            VOD*   phy                  //:  physicalDevice  ://
        ,   CHR*   nil                  //:  NIL:pLayerName  ://              
        ,   U32*   num                  //:  pPropertyCount  ://
        ,   E_P*   arr                  //:  pProperties     ://
        ){
            if( ECI >= 1 ){
                if( NIL == phy ){ ERR("[007]"); };
                if( NIL != nil ){ ERR("[008]"); };
                
                if( NIL == arr ){  /** OKAY **/ };
                if( NIL == num ){ 

                    ERR("[009:@NNP@]"); //:NullNumberPointer://

                };;
                if( NIL == arr ){
                    if( ((U32)0) != (*num) ){ 

                        P_F( "[010:NUM]:%d\n" , num );
                        ERR("[010]" ); //:@AMS@://
                    };
                };;
            };;

            GI3* fun = GET( "vkEnumerateDeviceExtensionProperties" );
            fun( phy , nil , num , arr  );

            if( ECI >= 1 ){
                if( NIL == num ){
                    ERR("[num_made_nil]");
                };;
            };;
        }
    #undef  E_P

//:VIDEO_023://

    //:VIDEO_023:--------------------------------------------://

        //: vkGetPhysicalDeviceSurfaceCapabilitiesKHR ://

            #define TYP struct mcv_t_vksurfacecapabilitieskhr

                RES mcv_f_g_phy_sur_cap(
                    VOD*   phy   //: physicalDevice          ://
                ,   VOD*   sur   //: NIL:pLayerName          ://              
                ,   TYP*   cap   //: VkSurfaceCapabilitiesKHR://
                ){
                    GI3* fun = GET( 
                    "vkGetPhysicalDeviceSurfaceCapabilitiesKHR" 
                    );;
                    RES res = (RES)fun( phy , sur , cap );
                    if( ECO >= 1 ){
                        if( 0 != res ){ ERR("[017]"); };
                    };;
                    return( res );
                }
            #undef  TYP

        //: vkGetPhysicalDeviceSurfaceFormatsKHR      ://

            #define TYP struct mcv_t_vksurfaceformatkhr

                RES mcv_f_g_phy_sur_fmt(
                    VOD*   phy       //: physicalDevice      :// 
                ,   VOD*   sur       //: VkSurfaceKHR        ://
                ,   U32*   num       //: pSurfaceFormatCount :// 
                ,   TYP*   arr       //: pSurfaceFormats     ://
                ){
                    if( ECI >= 1 ){
                    
                        if( NIL == phy ){   ERR("[013]"); };
                        if( NIL == sur ){   ERR("[014]"); };      
                        if( NIL == num ){   ERR("[015]"); };
                        if( NIL == arr ){ /** Allowed **/ };
                    
                        //:Memory Stomp Protection:
                        if( NIL == arr ){
                            if( ((U32)0) != (*num) ){
                                ERR("[019]");
                            };;
                        };;
                    };;
                    
                    GI3* fun = GET( 
                    "vkGetPhysicalDeviceSurfaceFormatsKHR" );;
                    RES res = (RES)fun(phy , sur , num , arr);
                    
                    if( ECO >= 1 ){
                    
                        if( NIL == arr ){
                            if( (*num) > mcv_m_c_sur_fmt ){
                                ERR("[012]");
                            };;
                        };;
                    
                        if( 0 != res ){ ERR("[016]"); };
                    };;
                    return( res );
                }
            #undef  TYP

        //: vkGetPhysicalDeviceSurfacePresentModesKHR ://

            #define TYP I32

                RES mcv_f_g_phy_sur_pre(
                    VOD* phy  //: physicalDevice    ://
                ,   VOD* sur  //: VkSurfaceKHR      ://
                ,   U32* num  //: pPresentModeCount ://
                ,   TYP* arr  //: pPresentModes     ://
                ){
                    GI3* fun = GET( 
                    "vkGetPhysicalDeviceSurfacePresentModesKHR" 
                    );;
                    RES res = (RES)fun( phy , sur , num , arr );

                    if( ECO >= 1 ){
                        if( 0 != res ){ ERR("[018]"); };
                    };;
                    return( res );
                }
            #undef  TYP

    //:--------------------------------------------:VIDEO_023://

//:VIDEO_024:Create_Swap_Chain:

    //:VIDEO_024:--------------------------------------------://

        #define CON const
        #define C_I struct mcv_t_vkswapchaincreateinfokhr
        #define OBJ VOD  //: vkswapchainkhr ://

            RES mcv_f_vkcreateswapchainkhr(
                     VOD*  log  //: device(logical)          ://
            ,   CON  C_I*  c_i  //: VkSwapchainCreateInfoKHR ://
            ,        VOD*  nil  //: VkAllocationCallbacks    ://
            ,        OBJ*  obj  //: VkSwapchainKHR           ://
            ){
                if( ECI >= 1 ){
                #define E ERR

                    if( NIL == log ){              E("[020]");};
                    if( NIL == c_i ){              E("[021]");};
                    if( NIL != nil ){              E("[022]");};
                    if( NIL == obj ){              E("[023]");}; 
    
                    //:Memory_Stomp_Protection:
                    if( NIL != (*(void**)obj)    ){E("[024]");};

                    if( log !=  mcv_d_o_log  ){E("[025]");};    
                    if( c_i !=&(mcv_d_c_swa) ){E("[026]");};
                    if( obj !=&(mcv_d_o_swa) ){E("[027]");};

                    if( c_i -> typ !=(1000001000)){E("[029]");};
                    if( c_i -> sur != mcv_d_o_sur){E("[030]");};

                    if( NIL == c_i -> sur        ){E("[031]");};

                #undef  E
                };;

                GI3* fun = GET( "vkCreateSwapchainKHR" );
                if( NIL == fun ){ ERR("[024]"); };

                RES res = (RES)fun( log , c_i , nil , obj );
                return( res );
            }

        #undef  C_I
        #undef  OBJ
        #undef  CON
    //:--------------------------------------------:VIDEO_024://

//:VIDEO_025:GetSwapChainIMages://

    //:VIDEO_025:--------------------------------------------://

        RES mcv_f_vkgetswapchainimageskhr(
            VOD*  log               //: VkDevice             ://
        ,   VOD*  swa               //: VkSwapchainKHR       ://
        ,   U32*  num               //: pSwapchainImageCount ://
        ,   VOD** arr               //: pSwapchainImages     ://
        ){

            GI3* fun = GET( "vkGetSwapchainImagesKHR" );
            if( NIL == fun ){ ERR("[032]"); };
            RES res = fun( log , swa , num , arr );
            if( 0 != res ){ ERR("[033]"); };

            if( ECO >= 1 ){
                if( NIL == arr ){
    
                    //:Array Capacity Exceeded:
                    if( *num > mcv_m_c_sci ){ ERR("[034]"); };

                };;
            };;

            return( res );
        }
    //:--------------------------------------------:VIDEO_025://

//:VIDEO_026:CreateImageViews://

    //:VIDEO_026:--------------------------------------------://
    #define CON const
    #define C_I struct mcv_t_vkimageviewcreateinfo
    #define C_B VOD  //:VkAllocationCallbacks://

        RES mcv_f_vkcreateimageview(
                VOD*  log    //: LogicalDevice ://
        ,   CON C_I*  c_i    //: pCreateInfo   ://
        ,   CON C_B*  nil    //: pAllocator    ://
        ,       VOD*  i_v    //: VkImageView   ://
        ){
            if( ECI >= 1 ){
                if( NIL ==  log ){ ERR("[043]" ); };
                if( NIL ==  c_i ){ ERR("[044]" ); };
                if( NIL !=  nil ){ ERR("[045]" ); };
                if( NIL ==  i_v ){ ERR("[046]" ); };

                //:Memory Stomp Protection:
                if( NIL !=(*((VOD**)i_v)) ){ ERR("[047]"); };
            };;

            GI3* fun = GET( "vkCreateImageView" );
            if( NIL == fun ){ ERR("[041]"); };
            RES res = fun( log , c_i , nil , i_v );
            if( 0 != res ){ ERR("[042]"); };

            return( res );
        } 

    #undef  CON
    #undef  C_I
    #undef  C_B
    //:--------------------------------------------:VIDEO_026://

#undef  GET
//:=========================================:FUNCTIONS_VULKAN://
//:=========================================:VULKAN_FUNCTIONS://
//:FUNCTIONS:================================================://

    DLL* mcv_f_dll_get( CHR* nam ){

        DLL* dll = LoadLibraryA( nam );
        if( ((DLL*)0) == dll ){
            ERR( "[FAILED_TO_LOAD_DLL]" );
        };;
        return( dll );
    }

    //:Default_Win32_WindowProc:-----------------------------://
    //:                                                      ://
    //:  Do __NOT__ Put in WIN32_FUNCTIONS section because   ://
    //:  there is possibility that windowproc will need to   ://
    //:  call __BOTH__ VULKAN_FUNCTIONS and WIN32_FUNCTIONS  ://
    //:                                                      ://
    //:Default_Win32_WindowProc:- - - - - - - - - - - - - - -://

        I64 __stdcall mcv_f_windowproc(
            VOD*    hwnd
        ,   U32     uMsg
        ,   U64   wParam  
        ,   I64   lParam  
        ){

            I64 res =( 64 );        //: init result to error ://

            switch (uMsg){

            case 0x0002 /** WM_DESTROY **/ :{

                mcv_d_lib_u32.PostQuitMessage(0);
                mcv_d_kot =( 0-1 );
                res=( 0 );

            };break;
            case 0x000F /** WM_PAINT **/ :{

                //:DONT DO ANY PAINTING HERE, VULKAN IS GOING
                //:TO TAKE CARE OF THAT FOR US.
                res=( 0 );

            };break;
            default:{

                res =( mcv_d_lib_u32.DefWindowProcW(
                    hwnd, uMsg, wParam, lParam));

            };break;}

            return( res ); 
        }


    //:-----------------------------:Default_Win32_WindowProc://

    PUBLIC_FUNCTION

    VOD  MCV_F_INI( VOD ){              //:Initialize Library://

        

        //:Debug:--------------------------------------------://
        {
        #define A mcv_f_ara

            //:Make sure padding hack has not altered the
            //:relative address of these memebers.
            struct mcv_t_vkphysicaldeviceproperties t={ 0 };
            A( &( t ) , &( t.pipelineCacheUUID ) , 276 ,"[1]");
            A( &( t ) , &( t.limits            ) , 296 ,"[2]");
            A( &( t ) , &( t.sparseProperties  ) , 800 ,"[3]");
            
        #undef  A
        }
        //:--------------------------------------------:Debug://
        //:Declare_Variables:--------------------------------://

            RES res =( 0 );
            SIZ siz =( 0 );

        //:--------------------------------:Declare_Variables://
        //:Load_All_Libraries:-------------------------------://
        //:VIDEO_017:----------------------------------------://
        
            //: Conceptually : mcv_f_dll_all( ) ://        
            #define GET mcv_f_dll_get

                mcv_d_dll_vul = GET( "vulkan-1.dll" );

                mcv_d_dll_g32 = GET(    "gdi32.dll" );
                mcv_d_dll_u32 = GET(   "user32.dll" );
                mcv_d_dll_k32 = GET( "kernel32.dll" );

            #undef  GET

        //:----------------------------------------:VIDEO_017://
        //:-------------------------------:Load_All_Libraries://
        //:VIDEO_017:----------------------------------------://
        //:Function_Pointer_Frontloading:--------------------://

            //:REFERENCE[ <AAC>/AAC2020/LIB/GINAWIN.D._ ]://

            #define g32 mcv_d_lib_g32
            #define u32 mcv_d_lib_u32
            #define k32 mcv_d_lib_k32

            #define   G mcv_f_gpa_g32
            #define   U mcv_f_gpa_u32
            #define   K mcv_f_gpa_k32
            
            //:G32:GDI32:

            g32.ChoosePixelFormat =G( "ChoosePixelFormat" );
            g32.GetStockObject    =G( "GetStockObject"    );
            g32.SetPixelFormat    =G( "SetPixelFormat"    );
            g32.SwapBuffers       =G( "SwapBuffers"       );

            //:U32:USER32:

            u32.CreateWindowExW   =(G00*)U( "CreateWindowExW"    );
            u32.DefWindowProcW    =U( "DefWindowProcW"     );
            u32.DestroyWindow     =U( "DestroyWindow"      );
            u32.DispatchMessageW  =U( "DispatchMessageW"   );
            u32.GetClientRect     =U( "GetClientRect"      );
            u32.GetDesktopWindow  =(G00*)U( "GetDesktopWindow"   );
            u32.GetWindowDC       =U( "GetWindowDC"        );
            u32.LoadCursorA       =U( "LoadCursorA"        );
            u32.LoadIconA         =U( "LoadIconA"          );
            u32.MessageBoxW       =U( "MessageBoxW"        );
            u32.PeekMessageW      =U( "PeekMessageW"       );
            u32.PostQuitMessage   =U( "PostQuitMessage"    );
            u32.RegisterClassExW  =U( "RegisterClassExW"   );
            u32.SetFocus          =U( "SetFocus"           );
            u32.ShowWindow        =U( "ShowWindow"         );
            u32.TranslateMessage  =U( "TranslateMessage"   );
            u32.UpdateWindow      =U( "UpdateWindow"       );

            //:K32:KERNEL32:

            k32.GetModuleHandleW  =(G00*)K( "GetModuleHandleW");

            #undef   g32
            #undef   u32
            #undef   k32

            #undef     G 
            #undef     U 
            #undef     K 
            
        //:--------------------:Function_Pointer_Frontloading://
        //:VIDEO_18:Win32_Window_002:------------------------://
        //:                                                  ://
        //:     #_CREATE_WINDOW_BEFORE_ALL_VULKAN_CODE_#     ://
        //:                                                  ://
        //:VIDEO_18:Win32_Window_002:- - - - - ---- - - - - -://
        #define k32 mcv_d_lib_k32
        #define u32 mcv_d_lib_u32
        #define W_C struct mcv_t_wndclassexw
        #define DEF ((I32)0x80000000)        /**CW_USEDEFAULT**/

            //:REFERENCE[ <AAC>/AAC2020/LIB/GINAWIN.F._ ]://

            //:Misc Variables:

                VOD*  exe = k32.GetModuleHandleW( NIL );
                UNI*  nam = L"SAMPLE_WINDOW_CLASS";
                UNI*  txt = L"LEARN_TO_PROGRAM_WINDOWS"      ;
                U32   w_s = (U32)0x00CF0000 /**OVERLAPPED**/ ;

                if( NIL == exe ){ ERR("[FAIL:GMHW]"); };
                wprintf( L"[nam]:%ls\n" , nam );
                wprintf( L"[txt]:%ls\n" , txt );
        
            //:Window Class:

                W_C w_c = { 0 };
                w_c.cbSize = sizeof( W_C );
                w_c.lpfnWndProc   = (VOD*)&( mcv_f_windowproc );   
                w_c.hInstance     = exe              ;
                w_c.lpszClassName = nam              ;

            //:Register Window Class:

                u32.RegisterClassExW( &( w_c ) );

            //:Create Window:

                VOD* mcv_d_win = u32.CreateWindowExW(
                    //:ExtendedStyle,Class,Text,WindowStyle
                    0 , nam , txt , w_s
                    //: _X_ , _Y_ , WID , HIG - - - - - - - -://
                ,       DEF , DEF , DEF , DEF 

                    //:ParentWin,Menu,exe,ExtraAppData- - - -://
                ,       u32.GetDesktopWindow()   //:ParentWin://
                ,       NIL                      //:hMenu    ://
                ,       exe                      //:hInstance://
                ,       NIL                      //:lParam(?)://
                );;
                if( NIL == mcv_d_win ){ ERR("[WINFAIL]"); };

            //:Make Window Visible:

                u32.ShowWindow( 
                    mcv_d_win
                ,  (I32)1 /**nCmdShow==SW_NORMAL**/ 
                );;

            //:Store Handle To Instance As Global For Later

                mcv_d_exe =( exe );

        #undef  k32
        #undef  u32
        #undef  W_C
        #undef  DEF
        //:------------------------:VIDEO_18:Win32_Window_002://
        //:----------------------------------------:VIDEO_017://
        //:Get_Available_Instance_Extensions( aie ):---------://

            #define NUM mcv_d_n_aie
            #define ARR mcv_d_a_aie
            #define CAP mcv_m_c_aie
            
                res = mcv_f_eiep( NIL , &NUM , NIL );
                CHK( res , "[mcv_f_eiep:GET_NUM]"  );
                if( NUM > CAP ){ ERR("[NUM>CAP]"); };
                if( NUM <= 0  ){ ERR("[NUM<=00]"); };
          
                res = mcv_f_eiep( NIL, &(NUM) , &( ARR[ 0 ] ) );
                CHK( res , "[mcv_f_eiep:GET_ARR]"  );

                P_F("[mcv_d_n_aie]:%d\n", NUM );
                for( I32 i = 0 ; i <= (NUM-1) ; i++ ){
                    P_F( 
                        "ARR[%2d]( %42s )\n"
                    ,        i
                    ,   &( ARR[ i ].ext_nam[ 0 ] )
                    );;
                };;

            #undef  NUM  
            #undef  ARR  
            #undef  CAP  

        //:---------:Get_Available_Instance_Extensions( aie )://
        //:VIDEO_012:----------------------------------------://
        //:VIDEO_012 : Has_Instance_Extensions ? :- - - - - -://
        //:Required_Instance_Extensions_All_Available? :- - -://
        {
        //:Available_Instance_Extensions :
        #define NUM_AIE mcv_d_n_aie
        #define ARR_AIE mcv_d_a_aie
        {
        //:Required__Instance_Extensions :
        #define NUM_RIE mcv_m_n_rie
        #define ARR_RIE mcv_d_a_rie
        {

            //:Compare_Available_And_Required:- - - - - - - -://
            I32            sm ; //:sm: Strings_Match         ://
            CHR* a_n ; I32 ai ; //:Available[ Name | Index ] ://
            CHR* r_n ; I32 ri ; //:Required[  Name | Index ] ://
            
            for( I32 r = 0 ; r <= (NUM_RIE-1) ; r++ ){
            for( I32 a = 0 ; a <= (NUM_AIE-1) ; a++ ){
            
                a_n = &( ARR_AIE[ a ].ext_nam[ 0 ] );
                r_n = &( ARR_RIE[ r ]        [ 0 ] );
            
                //:compare strings without strcmp://
                sm =(   1   );       //: Matches_By_Default  ://
                ai =(   0   );       //: CharIndex:AVAILABLE ://
                ri =(   0   );       //: CharIndex:REQUIRED  ://
                while(  1  ){
                    if( a_n[ ai ] != r_n[ ri ] ){ sm-- ; };
                    if( 0 == a_n[ ai ] ){ break; };
                    if( 0 == r_n[ ri ] ){ break; };
                    ai++;
                    ri++;
                };;
            
                if( sm >= 1 ){ break; }; 
            };;
                if( sm <= 0 ){
                    P_F( "[sm]:%d\n"           , sm );
                    P_F( "[Missing_RIE]:%s\n" , r_n );
                    P_F( "[a_n]:%s\n"         , a_n );
                    ERR( "[RIE_Not_Found]"          );
                };;
            };;

        }
        #undef  NUM_AIE 
        #undef  ARR_AIE 
        }
        #undef  NUM_RIE 
        #undef  ARR_RIE 
        }
        //:----------------------------------------:VIDEO_012://
        //+==================================================+//
        //|INSTANCE_CREATION:THEN:WINDOW_SURFACE:============|//
        //|-- - - - - - - - - - - -- - - - - - - - - - - - --|//
        //:SECTION_VIDEO_URL[ xxxxxxxxxxxxxxxxxxxxxxxxxxxxx ]://
        //:SECTION_VIDEO_NUM[ VIDEO_019                     ]://

                //:INSTANCE_CREATION:------------------------://
                #define A_I  mcv_d_applicationinfo
                #define C_I  mcv_d_c_instance
                
                    //:VkApplicationInfo://
                
                        A_I.typ     =(I32 )( 0 )           ;
                        A_I.nex     =(VOD*)( 0 )           ;
                        A_I.app_nam = "[Hello Triangle]"   ;
                        A_I.app_ver = mcv_f_vmv(   1, 0, 0);
                        A_I.eng_nam = "[No Engine]"        ;
                        A_I.eng_ver = mcv_f_vmv(   1, 0, 0);
                        A_I.api_ver = mcv_f_mav(0, 1, 2, 0);
                
                    //:VkInstanceCreateInfo:://
                    
                        C_I.typ     = ((I32 )(  1  )) ;
                        C_I.nex     = ((VOD*)(  0  )) ;
                        C_I.a_i     =&( A_I )         ;  
                        C_I.ext_num = mcv_m_n_rie     ;  
                        C_I.ext_arr = mcv_d_a_rie     ;  
                        C_I.lay_num       = 0         ;  
                        C_I.lay_arr =((VOD*)0)        ;  
                    
                    //:VkCreateInstance:://
                
                        res = mcv_f_vkcreateinstance(
                            &( mcv_d_c_instance )
                        ,    (       0          )    //:@A_C@://          
                        ,   &( mcv_d_o_instance )
                        );;
                        CHK( res , "[Instance_Create]" );
                
                #undef  A_I
                #undef  C_I
                //:------------------------:INSTANCE_CREATION://
                //:WINDOW_SURFACE:---------------------------://
                #define FUN mcv_f_vkcreatewin32surfacekhr
                #define V_I mcv_d_o_instance   //:Vulkan_Inst://
                #define C_I mcv_d_c_sur        //:Create_Info://
                #define C_B ((VOD*)0)          //:A_Call_Back://
                #define OBJ mcv_d_o_sur        //:Output_Obj ://
                
                    //: C_I : vkwin32surfacecreateinfokhr    ://
                    //: TYP : WIN32_SURFACE_CREATE_INFO_KHR  ://

                        C_I  .  typ = ((I32 )( 1000009000  )) ; 
                        C_I  .  nex = ((VOD*)(      0      )) ;  
                        C_I  .  c_f = ((U32 )(      0      )) ;  
                        C_I  .  exe = ((VOD*)(  mcv_d_exe  )) ;
                        C_I  .  win = ((VOD*)(  mcv_d_win  )) ;

                    //: OBJ : VkSurfaceKHR ( void* )         ://

                        res = FUN( V_I , &(C_I) , C_B , &(OBJ));
                        CHK( res , "[WINDOW_SURFACE]" );
                        
                #undef  FUN
                #undef  V_I
                #undef  C_I
                #undef  C_B
                #undef  OBJ
                //:---------------------------:WINDOW_SURFACE://

        
        //|-- - - - - - - - - - - -- - - - - - - - - - - - --|//
        //|============:INSTANCE_CREATION:THEN:WINDOW_SURFACE|//
        //+==================================================+//
        //:VIDEO_013:----------------------------------------://
        //:vkEnumeratePhysicalDevices:-----------------------://

            #define INS mcv_d_o_instance      //:[ vul_ins  ]://
            #define NUM mcv_d_n_phy       //:[ number of]://
            #define ARR mcv_d_a_phy       //:[ array  of]://
            #define CAP mcv_m_c_phy       //:[ capacity ]://
        
                //:Get number of physical devices :

                    res = mcv_f_epd( INS , &NUM , NIL );
                    CHK( res , "[Enum_Phy_Dev:001]" );
                    if( NUM > CAP ){ ERR("[2MANY_PHY_DEV]"); };

                //:Load physical devices into array :

                    res = mcv_f_epd( INS , &NUM , ARR );
                    CHK( res , "[Enum_Phy_Dev:002]" );

                //:Smoke Test : Print Number Of[ phy_dev ]:

                    P_F( "[num_phy]:%d\n" , NUM );

            #undef  INS  //:---------------------------------://
            #undef  NUM  //:---------------------------------://
            #undef  ARR  //:---------------------------------://
            #undef  CAP  //:---------------------------------://

        //:-----------------------:vkEnumeratePhysicalDevices://
        //:----------------------------------------:VIDEO_013://
       
//:MCV_F_INI:GET_PHYSICAL_DEVICE:############################://
//:                                                          ://
//:     VIDEO_020:GET_PHYSICAL_DEVICE:                       ://
//:     This stuff got a bit more complex than I expected.   ://
//:     we need more column space, so just un-indent here.   ://
//:                                                          ://
//:     TAG[isdevicesuitable]TAG[isDeviceSuitable]           ://
//:                                                          ://
//:MCV_F_INI:GET_PHYSICAL_DEVICE:::::::::::::::::::::::::::::://
#define     N_C mcv_f_n_c           //:------------:NillCheck://
                                    //:----------------:-----://
#define GET_QFP mcv_f_g_qfp                          //:-----://
#define GET_D_P mcv_f_vkgetphysicaldeviceproperties  //:-----://
#define GET_D_F mcv_f_vkgetphysicaldevicefeatures    //:-----://
#define GET_SSK mcv_f_g_phy_ssk     //:---------:GET_SSK     ://
                                    //:                      ://
#define     P_A mcv_d_a_phy     //:---------:PHY_ARR     ://
#define     P_N mcv_d_n_phy     //:---------:PHY_NUM     ://
#define     P_D mcv_d_o_phy     //:---------:PHY_DEV     ://
                                    //:                      :// 
#define     Q_A mcv_d_a_qfp         //:---------:QFP_ARR     ://
#define     Q_N mcv_d_n_qfp         //:---------:QFP_NUM     ://
#define     Q_C mcv_m_c_qfp         //:---------:QFP_CAP     ://
                                    //:                      ://
#define     I_C mcv_d_i_qfp_com     //:---------:QFI:COMPUTE ://
#define     I_G mcv_d_i_qfp_gra     //:---------:QFI:GRAPHICS://
#define     I_P mcv_d_i_qfp_pre     //:---------:QFI:PRESENT ://
                                    //:                      ://                
#define     SUR mcv_d_o_sur         //:---------:VkSurfaceKHR://
{

    I32     o_k =(    0    ); //: Undefined State.           ://
    I32 dev_pik =(    1    ); //: picking_a_physical_device ?://
    I32 dev_dex =(   0-1   ); //: current device index       :// 
    I32 dev_m_i =( P_N - 1 ); //: max device dex             ://

    if( P_N <= 0 ){ ERR("[NO_PHYSICAL_DEVICES]"); };

    while( dev_pik /**picking_a_physical_device**/ >= 1 ){

        //:What Device Are We Looking At Now?

            dev_dex++; if( dev_dex > dev_m_i ){

                ERR("[CANT_FIND_SUITABLE_PHYSICAL_DEVICE]");
            };;

        //:Reset Our Okay Status To Innocent/NoProblem/Positive:
    
            o_k =( 0+1 );

        //:Reset Criteria We Want:
        
            I_C = I_G = I_P = ( 0 - dev_dex - 1000 );//:#CGP#://

            ASS( I_C < 0 , "[I_C<0]" );   P_F("[I_C]:%d\n",I_C);
            ASS( I_G < 0 , "[I_G<0]" );   P_F("[I_G]:%d\n",I_G);
            ASS( I_P < 0 , "[I_P<0]" );   P_F("[I_P]:%d\n",I_P);
            
        //:VIDEO_014:----------------------------------------://
        //:1: vkGetPhysicalDeviceProperties
        //:2: vkGetPhysicalDeviceFeatures
        {
            struct mcv_t_vkphysicaldeviceproperties d_p ={ 0 };
            struct mcv_t_vkphysicaldevicefeatures   d_f ={ 0 };
        
            I32 y =( 0 ); //:Y:YES:Has feature.
            I32 n =( 0 ); //:N:NO :Missing Feature.
        
            P_D = P_A[    dev_dex   ];  N_C( P_D , "[P_D:014]");
            GET_D_P( P_D , &( d_p ) );     
            GET_D_F( P_D , &( d_f ) );     
    
            //:Todo: Make choice based on[ d_p ]&[ d_f ]

                //: ...0101010101010101010... ://
    
            //:Something Something Device PROPERTIES:
    
                //:No Logic Here Yet.://
    
            //:Gather Number Of Active Device FEATURES:
    
                for( I32 f = 0 ; f <=(55-1) ; f++ ){
    
                    if( 1 == d_f.data[ f ] ){ y++ ; }else
                    if( 0 == d_f.data[ f ] ){ n++ ; }else
                    {
                        ERR("[EXP:1_OR_ZERO]");
                    };; 
                };;
    
            //: Is device suitable? (isDeviceSuitable):      ://
            //: We no longer know, as we have further        ://
            //: criteria to evaluate.                        ://

                if( ( y > n ) ){ P_F("[NICE_DEVICE!]\n"); };;

                P_F( "\n"                                   );
                P_F( "[yes_features]:%d\n", y               );
                P_F( "[not_features]:%d\n", n               );
                P_F( "\n"                                   );
                mcv_f_p_vkphysicaldeviceproperties( &(d_p)  );
                P_F( "\n"                                   );
        }
        if( NIL == P_D ){ ERR("[NIL_PHYSICAL_DEVICE]"); };
        //:----------------------------------------:VIDEO_014://
        //:VIDEO_015:( KanjiCoder_IID_0338 ):----------------://
        
            GET_QFP( P_D , &Q_N ,  ( NIL  ) );
            if(  Q_N >  Q_C                 ){ ERR( "[001]" );};
            GET_QFP( P_D , &Q_N , &(Q_A[0]) );
        
            P_F( "[Number_Of_QFP:Q_N]:%d\n\n" , Q_N );
            
            for( I32 qfi = 0 ; qfi <=( Q_N-1 ) ; qfi++ ){

                U32 QFI = ((U32)qfi);
                U32 yes=( 0 ); /** supported? **/

                res = GET_SSK( P_D , QFI , SUR , &yes );
                CHK( res , "[G_S:GET_SSK]" );
        
                //: #NODEBUG0YES#( 0  ==  yes ) - - - - - - -://
                if( Q_A[qfi].q_f & 0x00000002 ){ I_C =(qfi); };
                if( Q_A[qfi].q_f & 0x00000001 ){ I_G =(qfi); };
                if(                1  ==  yes ){ I_P =(qfi); };

                P_F( "\n" );
            };;

            if( I_C >= 0 && I_G >= 0 && I_P >= 0 ){ 
                //:Device Is Still Suitable.
                //:Do nothing.
            }else{
                o_k=( 0-1 ); //:UnsuitableDevice
            };;
        
        //:----------------------------------------:VIDEO_015://
        //:VIDEO_022:DeviceExtensionSupport:-----------------://
        #define FUN mcv_f_vkenumeratedeviceextensionproperties
        #define   P mcv_d_o_phy
        #define   _ NIL
        #define   N mcv_d_n_ade
        #define   A mcv_d_a_ade
        #define   C mcv_m_c_ade

            P_F("[VIDEO_022:DeviceExtensionSupport]\n");

            if( o_k >= 1 ){                     SAY("[OK:001]");

                SAY( "\n[DeviceExtensionSupport:CHK:...]\n\n" );

                          N=( 0 ); //:Reset_From_Prev_Loop://
                ASS(     &N != NIL , "[AND_N_NIL]" );
                FUN( P,_,&N, _ ); 
                if(  N> C ){ 
                    P_F( "\n"               );
                    P_F( "[N:ade]:%d\n" , N );
                    P_F( "[C:ade]:%d\n" , C );
                    P_F( "\n"               );
                };;
                ASS( N<=C,"[011]");
                FUN( P,_,&N,(A));

                //:Paired Array Checklist:
                I32      chk_A[ mcv_m_n_rde ]={ 0 };
                I32      chk_N =mcv_m_n_rde ;
                #define  chk_C [NO_CAPACITY_SIZE_KNOWN]
                #undef   chk_C
                CHR*     rde =(NIL); //:Current:@RDE@://
                VEP  ent_ade ={ 0 }; //:Current:@ADE@://
                CHR*     ade =(NIL); //:Current:@ADE@://

                //:[r]:Loop over all required extensions:
                //:[a]:Check Against All Available Extensions:
                for( I32 r = 0 ; r <=(chk_N-1) ; r++ ){
                for( I32 a = 0 ; a <=(    N-1) ; a++ ){

                        rde = mcv_d_a_rde[ r ];//:mcv_d_a_rde://
                    ent_ade =           A[ a ];//:-----------://
                        ade = ent_ade.ext_nam ;//:mcv_d_a_ade://

                    if( 0==strcmp(ade,rde) ){ chk_A[ r ]=(1); };
                    if( 1==chk_A[ r ] ){ break; };
                };;};;
                for( I32 r = 0 ; r <=(chk_N-1) ; r++ ){

                    if( 1 != chk_A[ r ] ){ o_k =( 0-1); };
                    if( 1 != chk_A[ r ] ){ break;       };
                };;
            };;
            #define     PHY mcv_d_o_phy
            #define     SUR mcv_d_o_sur
            
            #define CAP_GET mcv_f_g_phy_sur_cap
            #define CAP_OBJ mcv_d_o_cap
            
            #define FMT_GET mcv_f_g_phy_sur_fmt
            #define FMT_NUM mcv_d_n_sur_fmt
            #define FMT_ARR mcv_d_a_sur_fmt
            #define FMT_OBJ mcv_d_o_sur_fmt
            #define FMT_DEX mcv_d_i_sur_fmt
            
            #define PRE_GET mcv_f_g_phy_sur_pre
            #define PRE_NUM mcv_d_n_sur_pre
            #define PRE_ARR mcv_d_a_sur_pre
            #define PRE_OBJ mcv_d_o_sur_pre
            #define PRE_DEX mcv_d_i_sur_pre
            if( o_k >= 1 ){                     SAY("[OK:002]");

                //: VIDEO_0023:SwapChainSupportDetails   ://
                
                CAP_GET( PHY , SUR , &( CAP_OBJ ) );
                
                FMT_GET( PHY , SUR , &(FMT_NUM) , ( NIL ) );
                FMT_GET( PHY , SUR , &(FMT_NUM) , FMT_ARR );
                
                PRE_GET( PHY , SUR , &(PRE_NUM) , ( NIL ) );
                PRE_GET( PHY , SUR , &(PRE_NUM) , PRE_ARR );
            };;
            if( o_k >= 1 ){                     SAY("[OK:003]");

                //:Vulkan Tutorial Does This ( VIDEO_0023 ):

                if( FMT_NUM >= 1 
                &&  PRE_NUM >= 1
                ){
                    //:Do nothing. Still Okay.
                }else{
                    P_F("\n***[EMPTY:sur_fmt|sur_pre]***\n\n");
                    o_k =( 0 - 1 );
                };;

                //:Vulkan Tutorial Made Us GET surface
                //:capabilities, but never check them.
                //:Here is my check.
                //:(Actually, I just didn't read far enough.)

                if( CAP_OBJ.img_min >= 1
                &&  CAP_OBJ.img_max >= 1

                &&  CAP_OBJ.ext_cur.wid >= 0
                &&  CAP_OBJ.ext_cur.hig >= 0

                &&  CAP_OBJ.ext_min.wid >= 0
                &&  CAP_OBJ.ext_min.hig >= 0

                &&  CAP_OBJ.ext_max.wid >= 0
                &&  CAP_OBJ.ext_max.hig >= 0
                ){
                    //:Do nothing. Still Okay.
                }else{
                    P_F("\n***[IMG_OR_EXT_PROBLEM]***\n\n");
                    o_k =( 0 - 1 );
                };;

            };;
            if( o_k >= 1 ){                     SAY("[OK:004]");

                //:Pick Surface Format ( VIDEO_0023 ):

                #define B8G8R8A8_SRGB   50
                #define B8G8R8A8_UINT   48
                #define R8G8B8A8_UINT   41
                #define SRGB_NONLINEAR   0

                    ASS( FMT_NUM >= 1 , "[ASS:n_sur_fmt:001]" );
                    ASS( PRE_NUM >= 1 , "[ASS:n_sur_pre:001]" );

                    for( I32 f = 0 ; f <=(FMT_NUM-1) ; f++ ){

                        if( FMT_ARR[ f ].fmt == B8G8R8A8_SRGB ){
                        if( FMT_ARR[ f ].col == SRGB_NONLINEAR){

                            FMT_OBJ =( FMT_ARR[ f ] );
                            FMT_DEX =(          f   );
                            break;
                        };;};;
                    };;
                    if( FMT_DEX < 0 ){ o_k =( 0 - 1 );};
                
                #undef  B8G8R8A8_SRGB    
                #undef  B8G8R8A8_UINT    
                #undef  R8G8B8A8_UINT   //: <-- AAC2020_FMT  ://
                #undef  SRGB_NONLINEAR   
            };;
            if( o_k >= 1 ){                     SAY("[OK:005]");

                //:Pick Best Present Mode ( VIDEO_0023 ):

                #define MAILBOX ( 1 )
                #define FIFO    ( 2 )

                    ASS( FMT_NUM >= 1 , "[ASS:n_sur_fmt:002]" );
                    ASS( PRE_NUM >= 1 , "[ASS:n_sur_pre:002]" );

                    for( I32 p = 0 ; p <=(PRE_NUM-1) ; p++ ){

                        if( 0
                        ||  FIFO    == PRE_ARR[ p ]  
                        ||  MAILBOX == PRE_ARR[ p ]  
                        ){
                            //:Great Or Good Enough:
                            PRE_OBJ = PRE_ARR[ p ];
                            PRE_DEX =(         p );

                            //:Found the one we really want:
                            if( MAILBOX == PRE_ARR[ p ] ){
                                break;
                            };;
                        };;
                    };;
                    if( PRE_DEX < 0 ){ o_k =( 0 - 1 );};

                #undef  MAILBOX
                #undef  FIFO
            };;
            if( o_k >= 1 ){                     SAY("[OK:006]");
 
                //: chooseSwapExtent ( VIDEO_0023 ) ://

                if( CAP_OBJ.ext_cur.wid != 0xFFFFFFFF 
                &&  CAP_OBJ.ext_cur.hig != 0xFFFFFFFF
                ){
                    mcv_d_h_swa_ext =( 1 );
                    mcv_d_o_swa_ext.wid = CAP_OBJ.ext_cur.wid ;
                    mcv_d_o_swa_ext.hig = CAP_OBJ.ext_cur.hig ;

                    P_F("\n[YAY]\n\n");
                }else{
                    //:Screen Coords Don't Match Pixel Coords:
                    //:Set to size of native window in pixels,
                    //:and clamp between allowed size range.

                    P_F("\n[HACKISH_UNTESTED_CODE]\n\n");

                    mcv_d_h_swa_ext =( 2 );

                    mcv_d_o_swa_ext    .wid=mcv_f_cur_min_max( 
                            MCV_F_G_WIN_WID() 
                    ,   CAP_OBJ.ext_min.wid
                    ,   CAP_OBJ.ext_max.wid
                    );;

                    mcv_d_o_swa_ext    .hig=mcv_f_cur_min_max( 
                            MCV_F_G_WIN_HIG() 
                    ,   CAP_OBJ.ext_min.hig
                    ,   CAP_OBJ.ext_max.hig
                    );;
                };;

                if( mcv_d_h_swa_ext <= 0 ){
                    o_k = ( 0 - 1 );
                    ERR("[NO:SWA_EXT]");
                };;
            };;
            #undef      PHY  //:-----------------------------://
            #undef      SUR  //:-----------------------------://
                             //:-----------------------------://
            #undef  CAP_GET  //:-----------------------------://
            #undef  CAP_OBJ  //:-----------------------------://
                             //:-----------------------------://
            #undef  FMT_GET  //:-----------------------------://
            #undef  FMT_NUM  //:-----------------------------://
            #undef  FMT_ARR  //:-----------------------------://
            #undef  FMT_OBJ  //:-----------------------------://
            #undef  FMT_DEX  //:-----------------------------://
                             //:-----------------------------://
            #undef  PRE_GET  //:-----------------------------://
            #undef  PRE_NUM  //:-----------------------------://
            #undef  PRE_ARR  //:-----------------------------://
            #undef  PRE_OBJ  //:-----------------------------://
            #undef  PRE_DEX  //:-----------------------------://
            if( o_k >= 1 ){                     SAY("[OK:007]");

                dev_pik=( 0 ); //:No_Longer_Searching://

                P_F( "\n[PHY_DEV:PICKED!]\n\n" );

                P_F( "\t[mcv_d_i_sur_pre:PRE_DEX]:%d\n"
                     ,   mcv_d_i_sur_pre );;

                P_F( "\t[mcv_d_i_sur_fmt:FMT_DEX]:%d\n"
                     ,   mcv_d_i_sur_fmt );;

                P_F( "\t[mcv_d_i_qfp_com:(I_C)]:%d\n" , I_C );
                P_F( "\t[mcv_d_i_qfp_gra:(I_G)]:%d\n" , I_G );
                P_F( "\t[mcv_d_i_qfp_pre:(I_P)]:%d\n" , I_P );

                P_F( "\n" );
            };;

            if( o_k >= 1 ){ SAY("[OK:FINAL]"); };

        #undef FUN  //:--------------------------------------://
        #undef   P  //:--------------------------------------://
        #undef   _  //:--------------------------------------://
        #undef   N  //:--------------------------------------://
        #undef   A  //:--------------------------------------://
        #undef   C  //:--------------------------------------://
        //:-----------------:VIDEO_022:DeviceExtensionSupport://

    };; //:<<<<<<<<<<<<<<< dev_pik:picking_a_physical_device ://

    if( dev_pik >= 1 ){
        /** Catches problems with above loop. **/
        ERR("[SHOULD_HAVE_CAUGHT_FAIL_EARLIER!]\n");
    }else{
        P_F("[DEVICE_WAS_PICKED]\n");
    };;

}
#undef      N_C  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef  GET_QFP  //:-----------------------------------------://
#undef  GET_D_P  //:-----------------------------------------://
#undef  GET_D_F  //:-----------------------------------------://
#undef  GET_SSK  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef      P_A  //:-----------------------------------------://
#undef      P_N  //:-----------------------------------------://
#undef      P_D  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef      Q_A  //:-----------------------------------------://
#undef      Q_N  //:-----------------------------------------://
#undef      Q_C  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef      I_G  //:-----------------------------------------://
#undef      I_C  //:-----------------------------------------://
#undef      I_P  //:-----------------------------------------://
                 //:-----------------------------------------://
#undef      SUR  //:-----------------------------------------://
//::::::::::::::::::::::::::::::MCV_F_INI:GET_PHYSICAL_DEVICE://
//:                                                          ://
//:     Physical device should have the ability of:          ://
//:     1. Graphics : USE: ( q_f & 0x00000001 )              ://
//:     2. Compute  : USE: ( q_f & 0x00000002 )              ://
//:     3. Present                                           ://
//:             USE: vkGetPhysicalDeviceSurfaceSupportKHR(   ://
//:                   device, i, surface, &presentSupport);  ://
//:                                                          ://
//:############################:MCV_F_INI:GET_PHYSICAL_DEVICE://
//:MCF_F_INI:CREATE_LOGICAL_DEVICE:##########################://
//:MCV_F_INI:createLogicalDevice:############################://
//:                                                          ://
//:  VIDEO_021 :                                             ://
//:         1. Create Logical Device                         ://
//:         2. Get The Different Queues                      ://
//:                                                          ://
//:MCF_F_INI:CREATE_LOGICAL_DEVICE:::::::::::::::::::::::::::://
//:MCV_F_INI:createLogicalDevice:::::::::::::::::::::::::::::://

    //:VIDEO_021:STEP_001:-----------------------------------://
    //:Create_Set_Of_Unique_Queue_Families:------------------://
    #define ARR mcv_d_a_qfi      /** Unique Set   As Array   **/
    #define CAP mcv_m_c_qfi      /** Capacity     Of Array   **/
    #define NUM mcv_d_n_qfi      /** Final Length Of Array   **/
    {
        //:Hackish Array "Zero Out" :

            ASS( 0 == NUM , "[ZER_NUM]" );
            ASS( 3 == CAP , "[CAP_NUM]" );

            for( I32 hak = 0 ; hak <=( CAP-1 ) ; hak++ ){
                //:Zero is value value, so set to highest
                //:possible value and pray never used.
                ARR[ hak ]=( 0x7FFFFFFF );
            };;
            ASS( ARR[ 0 ] == 0x7FFFFFFF , "[ARR_000]" );;
            ASS( ARR[ 1 ] == 0x7FFFFFFF , "[ARR_001]" );;
            ASS( ARR[ 2 ] == 0x7FFFFFFF , "[ARR_002]" );;

        //:Variables To Work With:

            I32     out ;
            I32     m_i ;
            I32     qfi =( 0-666 ); //:Cur[ QFI ]To_Add_To_Set
            I32     has =( 0-444 ); //:Already_Has[ QFI ]In_SET
            U32 chk_bit =(   0   ); //:Double_Check:Set
            U32 chk_num =(   0   ); //:Double_Check:Number/Count
            U32 chk_dex =(   0   ); //:Double_check:INDEX
        
        //:Creating The Set:
        for( I32 cur = 0 ; cur <= (CAP-1) ; cur++ ){

            //: Filter down these[ qfi ]to[ set/unique ]

                if( 0 == cur ){ qfi = mcv_d_i_qfp_com ; }else
                if( 1 == cur ){ qfi = mcv_d_i_qfp_gra ; }else
                if( 2 == cur ){ qfi = mcv_d_i_qfp_pre ; }else{
                    ERR("[CUR_OOB]");
                };;

            //: Bit flag debugging logic wont work if we have
            //: queue indexes (qfi) above 31 because U32 bits.

                ASS( qfi >= 0 || qfi <= 31 , "[QFI_BOUNDS]" );

            //:Was[ qfi ]found within our set[ ARR/mcv_d_a_qfi ]

                has=( 0 );
                out=( 0 );
                m_i=(   ((I32)NUM) - 1 );
                for( out = 0 ; out <= m_i ; out++ ){
                
                    if( out > (CAP-1) ){ 
                        P_F("[OUT+0]:%d \n" , out   );
                        P_F("[CAP-1]:%d \n" , CAP-1 );
                        P_F("[NUM-1]:%d \n" , NUM-1 );
                        P_F("[m_i+0]:%d \n" , m_i   );
                        ERR("[OOB:OUT]");
                    };;

                    if( ((U32)(qfi)) == ARR[ out ] ){
                        has =( 1 ); 
                        break;
                    };;
                };;

            //:Add to set if not already in the set:

                if( 0 == has ){
                    NUM++ ; if( NUM > CAP ){ ERR("[002]"); };
                    ARR[ NUM-1 ]=( qfi );
                    chk_bit =( chk_bit | ( 1 << qfi ) );

                    P_F("[SET_ADD:QFI] \n");
                }else{
                    P_F("[set_has:qfi] \n");
                };;
        };;

        //:Checking Our Logic:
        for( chk_dex = 0 ; chk_dex <=(32-1) ; chk_dex ++ ){

            if( 0 != ((1<<chk_dex)&(chk_bit)) ){ chk_num++; };
        };;
        if( chk_num != NUM ){
            P_F( "[chk_bit]:%0x \n" , chk_bit );
            P_F( "[chk_num]%d   \n" , chk_num );
            P_F( "[::::NUM]%d   \n" ,     NUM );
            ERR("[SET_DOUBLE_CHECK_FAIL]");
        };;

        //: Smoke Test To Make Sure We Didn't Confuse These:
        //:           qfp  !=            qfi
        //: &(mcv_d_a_qfp) !=  &(mcv_d_a_qfi)
        //: &(mcv_m_c_qfp) !=  &(mcv_m_c_qfi)
        //: &(mcv_d_n_qfp) !=  &(mcv_d_n_qfi)
        #define E ERR

            VOD* a_1 = &(mcv_d_a_qfi[0]) ;
            VOD* a_2 = &(mcv_d_a_qfp[0]) ;
            
            if(          a_1     ==         a_2    ){E("[5]");};
            if(  mcv_m_c_qfi     >  mcv_m_c_qfp    ){E("[6]");};
            if(  mcv_d_n_qfi     >  mcv_d_n_qfp    ){E("[7]");};
            if(  mcv_d_n_qfi     <=           0    ){E("[8]");};
            if(  mcv_d_n_qfp     <=           0    ){E("[9]");};
            
        #undef  E
    }
    #undef  ARR  //:-----------------------------------------://
    #undef  CAP  //:-----------------------------------------://
    #undef  NUM  //:-----------------------------------------://
    //:------------------:Create_Set_Of_Unique_Queue_Families://
    //:-----------------------------------:VIDEO_021:STEP_001://
    //:VIDEO_021:STEP_002:-----------------------------------://
    #define QFI_ARR mcv_d_a_qfi /** Unique Set   As Array   **/
    #define QFI_NUM mcv_d_n_qfi /** Final Length Of Array   **/
    #define QFI_CAP mcv_m_c_qfi /** Capacity     Of Array   **/

                                //: QCI : Queue_Create_Info  ://
    #define QCI_ARR mcv_d_a_qci /** QCI : ARRAY   **/
    #define QCI_NUM mcv_d_n_qci /** QCI : NUMBER  **/
    #define QCI_CAP mcv_m_c_qci /** QCI : Capacity**/

    #define QCI     struct mcv_t_vkdevicequeuecreateinfo 
    {

        //: We make one[ QCI ]per[ QFI ]in our set:

            QCI_NUM = QFI_NUM ;
    
        //:QCI_NUM & QFI_NUM printout because errors:

            P_F("\n\n");

            if( QCI_NUM <=  0 ){
                P_F( "[QCI_NUM]:%d <<[BAD_QCI]\n" , QCI_NUM );
            };;
            if( QFI_NUM <=  0 ){
                P_F( "[QFI_NUM]:%d <<[BAD_QFI]\n" , QFI_NUM );
            };;

            if( QCI_NUM >   0 ){
                P_F( "[QCI_NUM]:%d <<[OK]     \n" , QCI_NUM );
            };;
            if( QFI_NUM >   0 ){
                P_F( "[QFI_NUM]:%d <<[OK]     \n" , QFI_NUM );
            };;

            P_F("\n\n");

        //:"Allocate" number of elements:

            S_A( QCI_CAP == QFI_CAP , "[QFI_CAP:QFI_CAP]" );

            ASS( QCI_NUM > 0 , "[QCI_NUM>0]" );
            ASS( QFI_NUM > 0 , "[QFI_NUM>0]" );

            I32  dex;     //: qfi index. Not the qfi itself. ://
            U32  qfi;     //: qfi = ARR[ not_qfi ]           ://
            QCI* qci;     //: selected QueueCreateInfo struct://

        //:Populate:

            //: I hate assymetry and arbitrary choice.
            //: calculate max valid index ( m_i ) this way.
            I32  m_i =(( QFI_NUM | QCI_NUM )-1   );
            ASS( m_i ==( QFI_NUM - 1 ) , "[008]" );
            ASS( m_i ==( QCI_NUM - 1 ) , "[009]" );

            //: Populate Our Structs:
            #define  q_f [USE:c_f:(Create_Flags!Queue_Flags)]

            for( dex = 0 ; dex <= m_i ; dex++ ){
           
                qfi =   QFI_ARR[ dex ]  ; //:QueueFamilyIndex://
                qci =&( QCI_ARR[ dex ] ); //:QueueCreateInfo ://

                qci  ->  typ = (        2  ); //:    sType   ://
                qci  ->  nex = (       NIL ); //:    NO_PNEXT://
                qci  ->  c_f = ( (U32)( 0 )); //:  #_QCI_F0_#://
                qci  ->  fam = (       qfi ); //:Q_Family_Dex://
                qci  ->  num = (        1  ); //:Only 1 Queue://
                qci  ->  q_p =&( mcv_d_q_p ); //:  Q_Priority://
            };;

            #undef  q_f
    }
    #undef  QFI_ARR  //:-------------------------------------://
    #undef  QFI_NUM  //:-------------------------------------://
    #undef  QFI_CAP  //:-------------------------------------://
                     //:-------------------------------------://
    #undef  QCI_ARR  //:-------------------------------------://
    #undef  QCI_NUM  //:-------------------------------------://
    #undef  QCI_CAP  //:-------------------------------------://
                     //:-------------------------------------://
    #undef  QCI      //:-------------------------------------://
    //:-----------------------------------:VIDEO_021:STEP_002://
    //:VIDEO_021:STEP_003:MODIFY_QCI_ARR:--------------------://

        //:VIDEO_016:----------------------------------------://
        #define QCI struct mcv_t_vkdevicequeuecreateinfo
        #define D_V struct mcv_t_vkphysicaldevicefeatures
        #define DCI struct mcv_t_vkdevicecreateinfo
        #define C_D mcv_f_vkcreatedevice
        #define PHY mcv_d_o_phy
        #define LOG mcv_d_o_log

            //:QCI: Queue Create Info ( queueCreateInfo ) ://

                U32  qci_num = ((U32)( mcv_d_n_qci     ));
                QCI* qci_arr =&(     ( mcv_d_a_qci[ 0 ]));
                
            //:D_V: Specifiy[ deviceFeatures ]we will be using:

                D_V d_v = { 0 }; //:REQUESTING_NO_FEATURES://
                //: d_v <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< d_v = &( d_f ) maybe from previous device selection that got what device features we had?

            //:DCI: Device Create Info:

                DCI dci     ={ 0 };

                dci.typ     =( 3 /**Device_Create_Info==3**/);
                dci.nex     =(  NIL  );
                dci.c_f     =((U32)0 );

                dci.qci_num =(qci_num);  //:Q_CreateInfoCount://
                dci.qci_arr =(qci_arr);  //:p_Q_CreateInfos  ://

                dci.lay_num =(   0   );
                dci.lay_arr =(   0   );

                //:VIDEO_022: #_ENABLING_DEVICE_EXTENSIONS_# ://
                dci.ext_num =( mcv_m_n_rde );
                dci.ext_arr =( mcv_d_a_rde );

                dci.fet     = &( d_v );  //:pEnabledFeatures ://

            //: vkCreateDevice

                res = C_D(  PHY, &dci, NIL, &LOG  );
                CHK( res , "[C_D:vkCreateDevice]" );

        #undef  QCI
        #undef  D_V
        #undef  DCI
        #undef  C_D
        #undef  PHY
        #undef  LOG
        //:----------------------------------------:VIDEO_016://

    //:--------------------:VIDEO_021:STEP_003:MODIFY_QCI_ARR://
    //:VIDEO_021:STEP_004:GET_DEVICE_QUEUES:-----------------://
    #define GET_D_Q mcv_f_vkgetdevicequeue
    #define     LOG mcv_d_o_log

        ASS( NIL == mcv_d_q_com , "[HAS:mcv_d_q_com]" );
        ASS( NIL == mcv_d_q_gra , "[HAS:mcv_d_q_gra]" );
        ASS( NIL == mcv_d_q_pre , "[HAS:mcv_d_q_pre]" );

        //#  #_QCI_F0_# : VkDeviceQueueCreateInfo.q_f === 0  #//
        
        GET_D_Q( LOG , mcv_d_i_qfp_com , 0 , &( mcv_d_q_com ) );
        GET_D_Q( LOG , mcv_d_i_qfp_gra , 0 , &( mcv_d_q_gra ) );
        GET_D_Q( LOG , mcv_d_i_qfp_pre , 0 , &( mcv_d_q_pre ) );

        ASS( NIL != mcv_d_q_com , "[NIL:mcv_d_q_com]" );
        ASS( NIL != mcv_d_q_gra , "[NIL:mcv_d_q_gra]" );
        ASS( NIL != mcv_d_q_pre , "[NIL:mcv_d_q_pre]" );

        printf( "\n\n" );
        printf( "[ADDR:mcv_d_q_com]:%0x \n", mcv_d_q_com );
        printf( "[ADDR:mcv_d_q_gra]:%0x \n", mcv_d_q_gra );
        printf( "[ADDR:mcv_d_q_pre]:%0x \n", mcv_d_q_pre );
        printf( "\n\n" );

    #undef  GET_D_Q
    #undef      LOG
    //:-----------------:VIDEO_021:STEP_004:GET_DEVICE_QUEUES://

//:############################:MCV_F_INI:createLogicalDevice://
//:##########################:MCF_F_INI:CREATE_LOGICAL_DEVICE://
//:MCV_F_INI:CreateSwapChain:################################://

    //:VIDEO_024:createSwapChain:----------------------------://
    {
    SAY("[BEG:VIDEO_024:createSwapChain]");

        //:Declare Variables:

            I32 all_queues_have_different_indexes =( 0 );

        //:SwapChainImageCount:
        #define NO_MAXIMUM_LIMIT ( 0 == mcv_d_o_cap.img_max )
            if( 0
            ||  NO_MAXIMUM_LIMIT  
            ||  mcv_d_o_cap.img_max > mcv_d_o_cap.img_min
            ){
                mcv_d_n_img = mcv_d_o_cap.img_min + 1;
            }else{
                mcv_d_n_img = mcv_d_o_cap.img_min + 0;
            };;
        #undef  NO_MAXIMUM_LIMIT
    
        //:Fill Create Info:
        #define TYP struct mcv_t_vkswapchaincreateinfokhr
        #define C_I        mcv_d_c_swa
        #define OBJ        mcv_d_o_swa

        #define FUN mcv_f_vkcreateswapchainkhr
        #define LOG mcv_d_o_log

        #define CAB 0x00000010 //: #_COL_ATT_BIT_#     ://
        #define C_A 0x00000001 //: #_CA_ALPHA_OPAQUE_# ://

            S_A( S_O( C_I ) == S_O( TYP ) ); //:TypeCheck://

            //: Vulkan Tutorial Misses These In Main Text    ://
            //: (I am sure it is in the source code though)  ://

                C_I.typ =(  1000001000  );
                C_I.nex =(      NIL     );
                C_I.c_f =( (U32)(0x00 ) );
                C_I.sur =( mcv_d_o_sur  );

            //: Covered By Vulkan Tutorial.com :

                C_I.img_min     =( mcv_d_n_img         );
                C_I.img_fmt     =( mcv_d_o_sur_fmt.fmt );
                C_I.img_col     =( mcv_d_o_sur_fmt.col );
                C_I.img_ext     =( mcv_d_o_swa_ext     );
                C_I.img_lay_001 =(        1            );
                C_I.img_use     =(       CAB           );
                C_I.tra_pre     =( mcv_d_o_cap.tra_cur );
                C_I.com_alp     =( C_A                 ); 
                C_I.pre_mod     =( mcv_d_o_sur_pre     );
                C_I.clipped     =(        1            ); 
                C_I.oldchan     =(       NIL           );

            //: EXCLUSIVE OR CONCURRENT ?

                if( mcv_d_i_qfp_com != mcv_d_i_qfp_gra
                &&  mcv_d_i_qfp_gra != mcv_d_i_qfp_pre
                &&  mcv_d_i_qfp_pre != mcv_d_i_qfp_com
                ){
                    all_queues_have_different_indexes=( 0+1 );
                }else{
                    all_queues_have_different_indexes=( 0-1 );
                };;

                if( all_queues_have_different_indexes >= 1 ){
                    ERR("[BRANCH_IS_UNTESTED_ON_MY_MACHINE]");
                
                    C_I.img_s_m = ((I32)1)   ;//: CONCURRENT ://
                    C_I.qfi_num = (   3  )   ;   
                    C_I.qfi_arr = mcv_d_a_qfi;   
                }else
                if( all_queues_have_different_indexes <= 0 ){
                
                    C_I.img_s_m = ((I32)0)   ;//: EXCLUSIVE  ://
                    C_I.qfi_num = (   0  )   ;//: OPTIONAL   ://
                    C_I.qfi_arr = (   0  )   ;//: OPTIONAL   ://
                }else{
                    ERR("[INVALIDVALUE]");
                };;

            //: CreateSwapChain:

                res = FUN( LOG , &(C_I) , NIL , &( OBJ ) );
                CHK( res , "[vkCreateSwapChainKHR]" );

        #undef  TYP
        #undef  C_I
        #undef  OBJ
   
        #undef  FUN
        #undef  LOG
        
        #undef  CAB
        #undef  C_A

    SAY("[END:VIDEO_024:createSwapChain]");
    }
    //:----------------------------:VIDEO_024:createSwapChain://

//:################################:MCV_F_INI:CreateSwapChain://

        //:VIDEO_025:GetSwapChainImages:---------------------://
        #define FUN mcv_f_vkgetswapchainimageskhr
        #define LOG mcv_d_o_log 
        #define SWA mcv_d_o_swa 
        #define NUM mcv_d_n_sci
        #define ARR mcv_d_a_sci

            VOD** arr_type_check =( ARR );

            FUN( LOG , SWA , &( NUM ) ,  ( NIL ) );
            FUN( LOG , SWA , &( NUM ) ,  ( ARR ) );

            P_F( "[num_swapchain_images]:%d\n" , NUM );

        #undef  FUN
        #undef  LOG
        #undef  SWA
        #undef  NUM
        #undef  ARR
        //:---------------------:VIDEO_025:GetSwapChainImages://
        //:VIDEO_026:STORE_FORMAT_AND_EXTENT:----------------://

            //:Seems Kind Of Fucking Redundant... Okay.

            //: mcv_d_o_swa_fmt = mcv_d_o_sur_fmt.fmt ;
            //: mcv_d_o_swa_ext = mcv_d_o_sur_ext     ;

            ASS( mcv_d_o_swa_ext.wid > 0 , "[035]" );
            ASS( mcv_d_o_swa_ext.hig > 0 , "[036]" );

            mcv_d_o_swa_fmt = mcv_d_o_sur_fmt.fmt ;


        //:----------------:VIDEO_026:STORE_FORMAT_AND_EXTENT://
        //:VIDEO_027:IMAGE_VIEWS:----------------------------://
        #define FUN        mcv_f_vkcreateimageview
        #define C_I struct mcv_t_vkimageviewcreateinfo
        #define LOG mcv_d_o_log
        #define TYP ((I32)15 )      //:IMAGE_VIEW_CREATE_INFO://
        #define V_T ((I32) 1 )      //: VK_IMAGE_VIEW_TYPE_2D://
        #define A_M ((U32) 1 )      //:      ASPECT_COLOR_BIT://
        #define ARR mcv_d_a_siv

            mcv_d_n_siv = mcv_d_n_sci ;
            if( mcv_d_n_siv > mcv_m_c_siv ){ ERR("[037]"); };
            for( I32 i = 0 ; i <= mcv_d_n_siv-1 ; i++ ){

                //:SwapChainImageView[ i ]==SwapChainImage[ i ]

                C_I c_i ={ 0 };
                    c_i.img =( mcv_d_a_sci[ i ]  );
                    c_i.fmt =( mcv_d_o_swa_fmt   );
                    c_i.typ =( TYP );
                    c_i.v_t =( V_T );
                
                    c_i.com[ 0 ]=( 0 ); //:R:SWIZZEL_IDENTITY://
                    c_i.com[ 1 ]=( 0 ); //:G:SWIZZEL_IDENTITY://
                    c_i.com[ 2 ]=( 0 ); //:B:SWIZZEL_IDENTITY://
                    c_i.com[ 3 ]=( 0 ); //:A:SWIZZEL_IDENTITY://
    
                    c_i.rng.asp_msk =( A_M );//:ASPECTMASK   ://

                    c_i.rng.mip_bas =(  0  );//:MIP_MAPPINGSl://
                    c_i.rng.mip_num =(  1  );

                    c_i.rng.lay_bas =(  0  );//:IMAGE_LAYERS ://
                    c_i.rng.lay_num =(  1  );
                    
                if( NIL != ARR[ i ] ){ ERR("[040]"); };
                res = FUN( LOG , &(c_i) , NIL , &(ARR[ i ]) );
                if( 0 != res ){ ERR("[038]"); };
                if( NIL == ARR[ i ] ){ ERR("[039]"); };
            };;

            SAY("[CHECKPOINT:VIDEO_027:IMAGE_VIEWS]" );

        #undef  FUN
        #undef  C_I
        #undef  LOG
        #undef  TYP
        #undef  V_T
        #undef  A_M
        #undef  ARR
        //:----------------------------:VIDEO_027:IMAGE_VIEWS://

//:MCV_F_INI:CREATE_GRAPHICS_PIPELINE:=======================://
//:MCV_F_INI:CREATEGRAPHICSPIPELINE:=========================://

    //: ADDED_FILE_HERE[ MCV.VERT ] :::::::::::::::::::::://
    //: ADDED_FILE_HERE[ MVC.FRAG ] :::::::::::::::::::::://

    //:--------------------------------------------------://
    //:     64bit glslc found here:                      ://
    //:     github.com/pixeljetstream                    ://
    //:         /glslc/tree/master/bin_Windows_64        ://
    //:--------------------------------------------------://




//:=========================:MCV_F_INI:CREATEGRAPHICSPIPELINE://
//:=======================:MCV_F_INI:CREATE_GRAPHICS_PIPELINE://


        SAY( "[EXITING:MCV_F_INI]" );

    } //:<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<[ MCV_F_INI ]://

    PUBLIC_FUNCTION 

        VOD MCV_F_TIK( VOD ){

            /** Tick Function. Once Per Frame. **/

            #define u32    mcv_d_lib_u32
            #define P_M u32.PeekMessageW
            #define MSG struct mcv_t_msg  
            #define WIN        mcv_d_win 
            #define REM        (U32)0x0001 /** PM_REMOVE **/

                //: Exit Once Drained. DON'T use      ://
                //: "GetMessage" because "GetMessage" ://
                //: will block.                       ://

                MSG msg = { 0 };
                while( P_M( &msg , WIN , 0 , 0 , REM ) > 0){

                    u32.TranslateMessage( &msg );
                    u32.DispatchMessageW( &msg );
                };;
     
            #undef  u32
            #undef  P_M
            #undef  MSG
            #undef  WIN
            #undef  REM
        }

    PUBLIC_FUNCTION  

        I32 MCV_F_DEM( VOD ){ 

            /** MCV_F_DEM == Library_Demonstration **/

            MCV_F_INI( ); 
            F_F( stdout );

            while( mcv_d_kot >= 1 ){

                MCV_F_TIK();
        
            };;
            P_F( "\n\n[Outside_Of_Window_Loop]\n\n\n" );

            return( 0 );
        }

//:================================================:FUNCTIONS://
//:FILE_MACROS:==============================================://

//: MISC_FILE_MACROS ://

    #undef PUBLIC_FUNCTION
    #undef PRIVATE_FUNCTION

//: MONKEY_WRENCH_MACROS ://

    #undef num_qci  
    #undef arr_qci  
                    
    #undef num_lay  
    #undef arr_lay  
                    
    #undef num_ext  
    #undef arr_ext  

    #undef mcv_f_dll_all
    #undef QFC_NUM

//: Basic_File_Macros ://
                    
//:  #undef    H
//:  #undef    A
//:  #undef    N
//:  #undef    I
//:  #undef    C
//:  #undef    O

    #undef  ECI
    #undef  ECO
    #undef  NIL  
    #undef  VOD  
    #undef  DLL  
    #undef  U08
    #undef  U16
    #undef  I32  
    #undef  U32 
    #undef  U64
    #undef  I64
    #undef  F32
    #undef  CHR 
    #undef  UNI
    #undef  NCC
    #undef  ERR  
    #undef  SAY  
    #undef  CHK  
    #undef  ASS
    #undef  RES   
    #undef  GI3 
    #undef  G00
    #undef  P_F
    #undef  F_F
    #undef  S_A
    #undef  S_O
    #undef  SIZ 

//: Vulkan_Macros_To_Keep_Stuff_Terse ://

    #undef  VEP  //: <-- TODO: REMOVE THESE... TOO SPECIFIC FOR ENTIRE FILE SCOPE
    #undef  PDL  //: <-- TODO: REMOVE THESE... TOO SPECIFIC FOR ENTIRE FILE SCOPE
    #undef  DSP  //: <-- TODO: REMOVE THESE... TOO SPECIFIC FOR ENTIRE FILE SCOPE

//:==============================================:FILE_MACROS://
//::SHORTHAND_COMMENTS:======================================://
/** SHORTHAND_COMMENTS ************************************* ***

    @ MWM @ : Monkey Wrench Macro
    @ KOT @ : Keep_On_Ticking
    @ A_C @ : Allocation_Callbacks
    @ VIL @ : Vestigial "i" Loop (Loop Can Be Removed From Code)
    @ NDP @ : NIL_DOUBLE_POINTER
    @ AMS @ : Avoid_Memory_Stomping
    @ RDE @ : Required__Device_Extension (Name/String)
    @ ADE @ : Available_Device_Extension (Name/String)
    @ NNP @ : Nill_Number_Pointer

    @ men @ : Max_Extension_Name
    @ mpd @ : Max_PhyDev_Name   
    @ uid @ : VK_UUID_SIZE      


*** ************************************* SHORTHAND_COMMENTS **/
//:======================================:SHORTHAND_COMMENTS:://
//::LONGHAND_COMMENTS:=======================================://
/** LONGHAND_COMMENTS ************************************** ***

    #_DO_NOT_POPULATE_FPS_USING_HELPER_FUNCTIONS_#

        Do not use helper function to populate function
        pointer structs for different DLL files.
        Reasoning: Creates spaghetti code. Do not create
        helper functions that are only called once.
        Makes it harder to understand the linear narrative
        when reading code from top to bottom.

    #_CREATE_WINDOW_BEFORE_ALL_VULKAN_CODE_#

        :::VIDEO_18:Win32_Window_002:------------------------:::
        :::                                                  :::
        :::     Window Creation Added Before All Vulkan      :::
        :::     Init because SOME (not all) vulkan code      :::
        :::     depends on Win32 window existing.            :::
        :::                                                  :::
        :::     SPECIFICALLY:                                :::
        :::                                                  :::
        :::     VkSurfaceKHR                                 :::
        :::                                                  :::
        :::     ALSO:                                        :::
        :::                                                  :::
        :::     The window surface needs to be created       :::
        :::     right after the instance creation, because   :::
        :::     it can  actually influence the physical      :::
        :::     device selection. The reason we postponed    :::
        :::     this is because window surfaces are part     :::
        :::     of the larger topic of render targets        :::
        :::     and presentation for which the explanation   :::
        :::     would have cluttered the basic setup.        :::
        :::                                                  :::
        :::VIDEO_18:Win32_Window_002:- - - - - ---- - - - - -:::

    #NODEBUG0YES#

        I was trying to figure out why setting ( 0 == yes )
        was _NOT_ causing a failure to pick physical device.
        The reason was because that just inverted the
        queue family for PRESENT capability. It didn't cause
        a present queue to not be found. DATE[2021_11_14]

    #CGP#

        Compute
        Graphics
        Present

        Keep these queue types in alphabetical order to
        avoid arbitraryness in our code.

    #_queueIndex_ZERO_ALWAYS_#

        When using vkGetDeviceQueue , the queueIndex property
        is always zero because in this library we only make
        one queue of any given [type/ability].

        1 compute  queue
        1 graphics queue
        1 present  queue
        
        Thus sub index for queue is always zero.

    #_064_QFI_#
    
        A QFI over 64 is probably wrong. But it might not
        be if graphics card actually has more than 64
        queues. I just find it highly unlikely.

        Remove this error if graphics cards start to support
        higher numbers.

    #_QCI_F0_#

        //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//
        //# vkGetDeviceQueue must only be used to get  #//
        //# queues that were created with the flags    #//
        //# parameter of VkDeviceQueueCreateInfo set   #//
        //# to zero. To get queues  that were created  #//
        //# with a non-zero flags parameter use        #//
        //# vkGetDeviceQueue2.                         #//
        //[ !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ]//

    #_HOW_DID_I_DECIDE_ON_RIE_#

        /// ******************************************** ///                                 
        /// www.khronos.org/registry/vulkan/specs/       ///
        /// 1.2-khr-extensions/html/chap47.html          ///
        ///                                              ///
        /// Also: Cross Checked: GLFW Library            ///
        /// glfwGetRequiredInstanceExtensions            ///
        /// _glfwPlatformGetRequiredInstanceExtensions   ///
        /// ******************************************** ///
        //: "VK_KHR_external_memory_win32"  
        //: "VK_KHR_win32_keyed_mutex"  
        //: "VK_KHR_external_semaphore_win32"  
        //: "VK_KHR_external_fence_win32" 

    #_ENABLING_DEVICE_EXTENSIONS_#

        Enabling device extensions
        Using a swapchain requires enabling the 
        VK_KHR_swapchain extension first. Enabling the 
        extension just requires a small change to the  
        logical device creation structure:

        createInfo.enabledExtensionCount = 
            static_cast<uint32_t>(deviceExtensions.size());
        createInfo.ppEnabledExtensionNames = 
            deviceExtensions.data();

        Make sure to replace the existing line
        createInfo.enabledExtensionCount = 0; 
        when you do so.

        https://vulkan-tutorial.com/.../Swap_chain

    #_EXC_REC_#
        Win32 rect uses an EXCLUSIVE RECTANGLE. Hence there
        is no minus one after taking delta between bounds.

    #_COL_ATT_BIT_# :
        
        KHRONOS_DOT_COM:
        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010
        specifies that the image can be used to create 
        a VkImageView suitable for use as a color or 
        resolve attachment in a VkFramebuffer.

        VULKAN_TUTORIAL_DOT_COM:
        The imageUsage bit field specifies what kind of 
        operations we'll use the images in the swap chain for. 
        In this tutorial we're going to render directly to 
        them, which means that they're used as color attachment. 
        It is also possible that you'll render images to a 
        separate image first to perform operations like 
        post-processing. In that case you may use a value like 
        VK_IMAGE_USAGE_TRANSFER_DST_BIT instead and use a 
        memory operation to transfer the rendered image to 
        a swap chain image.

    #_CA_ALPHA_OPAQUE_# :

        VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: 
        The alpha component, if it exists, of the images 
        is ignored in the compositing process. Instead, the 
        image is treated as if it has a constant alpha of 1.0.

    #_CONSISTENT_FRAMERATE_60_FPS_#

        If you want to limit to 60 fps then you
        should use VK_PRESENT_MODE_FIFO_KHR instead
        of VK_PRESENT_MODE_MAILBOX_KHR. The mailbox
        mode is about rendering as many frames as
        possible to ensure that the one presented to
        the screen is as "fresh" as possible.
        -Alexander Overvoorde
        -https://vulkan-tutorial.com/Drawing_a_triangle
                               /Presentation/Swap_chain
        

*** ************************************** LONGHAND_COMMENTS **/
//:=======================================:LONGHAND_COMMENTS:://
//::HELP_FINDING_THINGS:=====================================://
/** ******************************************************** ***

    computeFamily  | computeFamilyIndex
    mcv_d_i_qfp_com
    PASTE_LINE

    graphicsFamily | grapicsFamilyIndex
    mcv_d_i_qfp_gra
    PASTE_LINE

    presentFamily | presentFamilyIndex    
    mcv_d_i_qfp_pre
    PASTE_LINE
    
    ------------------------------------------------------------

    mcv_d_i_qfi_com | mcv_d_i_com | mcv_qfi_com | qfi_com
    mcv_d_i_qfp_com
    PASTE_LINE

    mcv_d_i_qfi_gra | mcv_d_i_gra | mcv_qfi_gra | qfi_gra
    mcv_d_i_qfp_gra
    PASTE_LINE

    mcv_d_i_qfi_pre | mcv_d_i_pre | mcv_qfi_pre | qfi_pre
    mcv_d_i_qfp_pre
    PASTE_LINE

    ------------------------------------------------------------

    VkQueueCreateInfo | QueueCreateInfo
    YOU_MEAN[ VkDeviceQueueCreateInfo ]
    PASTE_LINE

    mcv_t_vkqueuecreateinfo
    YOU_MEAN[ mcv_t_vkdevicequeuecreateinfo ]
    PASTE_LINE
    
    mcv_d_ade_arr | mcv_data_available_device_extension_array
    USE[ mcv_d_a_ade ]
    PASTE_LINE

    mcv_d_ade_num | mcv_data_available_device_extension_count
    USE[ mcv_d_n_ade ]
    PASTE_LINE

    mcv_d_ade_cap | mcv_data_available_device_extension_capacity
    USE[ mcv_m_c_ade ]
    PASTE_LINE

    mcv_t_vksurfaceformatskhr | vksurfaceformatskhr
    YOU_WANT[ mcv_t_vksurfaceformatkhr ]
    PASTE_LINE

    mcv_t_surfacecapabilitieskhr | surfacecapabilitieskhr   
    YOU_WANT[ mcv_t_vksurfacecapabilitieskhr ]
    PASTE_LINE

    mcv_t_vkpresentmodekhr | vkpresentmodekhr 
    JUST_USE[ I32 ]BECAUSE_ENUM
    PASTE_LINE

    mcv_t_vksurfacepresentmodekhr | vksurfacepresentmode
    JUST_USE[ I32 ]BECAUSE_ENUM
    PASTE_LINE

    mcv_d_o_win
    USE[ mcv_d_win ]
    PASTE_LINE

    mcv_d_swa_cap | swapchaincapabilities | mcv_d_o_swa_cap
    USE[ mcv_d_o_cap ]
    PASTE_LINE

    mcv_d_fmt | mcv_data_format | swapchain_data_format
    mcv_d_o_sur_fmt
    PASTE_LINE

    mcv_d_o_sur_ext | surface_extent | swapchain_extent
    USE[ mcv_d_o_swa_ext.[wid|hig] ]
    PASTE_LINE

    curtran | cur_tran | cur_tra
    USE[ mcv_d_o_cap.tra_cur ]
    PASTE_LINE
 
    pretran | pre_tran | pretransform
    USE[ tra_pre ]( TransformPre )
    PASTE_LINE

    presentmode | presentMode | present_mode
    SEE[ C_I.pre_mod     =( mcv_d_o_sur_pre     ); ]
    PASTE_LINE

    mcv_t_vkswapchainkhr | vkswapchainkhr
    USE[ VOD* ]( void* because opaque type )
    PASTE_LINE

    STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR
    PASTE_LINE
    
    mcv_d_o_swachan | mcv_d_swachan | mcv_d_c_swapcha 
    USE[ mcv_d_o_swa ]
    PASTE_LINE

    swapcha
    PIK[ mcv_d_o_swa | mcv_d_c_swa ]
    PASTE_LINE

    imageviews | image_views | img_vew | imgvew | imgvews
    xxxxxxxxxxxxxxxx
    PASTE_LINE
    
    swapChainImageFormat | swap_chain_image_format
    USE[ mcv_d_o_swa_fmt ]
    PASTE_LINE

    imageformat
    TRY[ img_fmt | fmt | mcv_d_o_swa_fmt ]
    PASTE_LINE

*** ******************************************************** **/
//:=====================================:HELP_FINDING_THINGS:://
//:YOU_CANT_TYPE_WORTH_SHIT:=================================://
/** ******************************************************** ***

    mcv_f_enumeratedeviceextensionproperties
    YOU_MEAN[ mcv_f_vkenumeratedeviceextensionproperties ]
    PASTE_LINE

*** ******************************************************** **/
//:YOU_CANT_TYPE_WORTH_SHIT:=================================://
